import BigNumber$1 from 'bignumber.js';
import { z } from 'zod';
import { Client, AccountId, TokenId, TopicId, ScheduleId, Transaction, PublicKey, LedgerId } from '@hashgraph/sdk';
import { StructuredTool, BaseToolkit } from '@langchain/core/tools';
import { CallbackManagerForToolRun } from '@langchain/core/callbacks/manager';
import { RunnableConfig } from '@langchain/core/runnables';
import { McpServer } from '@modelcontextprotocol/sdk/server/mcp.js';
import { Tool as Tool$1, LanguageModelV1Middleware } from 'ai';
import { Action, Handler, ActionExample, Validator } from '@elizaos/core';

type TopicMessagesQueryParams = {
    topicId: string;
    lowerTimestamp: string;
    upperTimestamp: string;
    limit: number;
};
type TopicMessage = {
    topicId: string;
    message: string;
    consensus_timestamp: string;
};
type TopicMessagesResponse = {
    topicId: string;
    messages: TopicMessage[];
};
type TopicInfo = {
    topic_id?: string;
    memo?: string | null;
    admin_key?: {
        _type?: string;
        key?: string;
    } | null;
    submit_key?: {
        _type?: string;
        key?: string;
    } | null;
    auto_renew_account?: string | null;
    auto_renew_period?: number | null;
    created_timestamp?: string | null;
    deleted?: boolean;
    sequence_number?: number | null;
    running_hash?: string | null;
    running_hash_version?: number | null;
};
type TokenBalance = {
    automatic_association: boolean;
    created_timestamp: string;
    token_id: string;
    freeze_status: string;
    kyc_status: string;
    balance: number;
    decimals: number;
};
type TokenBalancesResponse = {
    tokens: TokenBalance[];
};
type AccountResponse = {
    accountId: string;
    accountPublicKey: string;
    balance: AccountBalanceResponse;
    evmAddress: string;
};
type AccountBalanceResponse = {
    balance: BigNumber$1;
    timestamp: string;
    tokens: TokenBalance[];
};
/**
 * This type matches responses from Hedera Mirror Node API
 */
type TokenInfo = {
    token_id?: string;
    name: string;
    symbol: string;
    type?: string;
    memo?: string;
    decimals: string;
    initial_supply?: string;
    total_supply?: string;
    max_supply?: string;
    supply_type?: string;
    treasury_account_id?: string;
    auto_renew_account?: string;
    auto_renew_period?: number;
    deleted: boolean;
    freeze_default?: boolean;
    pause_status?: string;
    created_timestamp?: string;
    modified_timestamp?: string;
    expiry_timestamp?: number;
    admin_key?: {
        _type: string;
        key: string;
    } | null;
    supply_key?: {
        _type: string;
        key: string;
    } | null;
    kyc_key?: {
        _type: string;
        key: string;
    } | null;
    freeze_key?: {
        _type: string;
        key: string;
    } | null;
    wipe_key?: {
        _type: string;
        key: string;
    } | null;
    pause_key?: {
        _type: string;
        key: string;
    } | null;
    fee_schedule_key?: {
        _type: string;
        key: string;
    } | null;
    metadata_key?: {
        _type: string;
        key: string;
    } | null;
    metadata?: string;
    custom_fees?: {
        created_timestamp: string;
        fixed_fees: any[];
        fractional_fees: any[];
    };
};
type TransferData = {
    account: string;
    amount: number;
    is_approval: boolean;
};
type TransactionData = {
    batch_key: string | null;
    bytes: string | null;
    charged_tx_fee: number;
    consensus_timestamp: string;
    entity_id: string;
    max_fee: string;
    max_custom_fees: any[];
    memo_base64: string;
    name: string;
    nft_transfers: any[];
    node: string;
    nonce: number;
    parent_consensus_timestamp: string | null;
    result: string;
    scheduled: boolean;
    staking_reward_transfers: any[];
    token_transfers: any[];
    transaction_hash: string;
    transaction_id: string;
    transfers: TransferData[];
    valid_duration_seconds: string;
    valid_start_timestamp: string;
};
type TransactionDetailsResponse = {
    transactions: TransactionData[];
};
interface ContractInfo {
    admin_key?: {
        description?: string;
        _type?: string;
        example?: string;
        key?: string;
    } | null;
    auto_renew_account?: string | null;
    auto_renew_period?: number | null;
    contract_id?: string | null;
    created_timestamp?: string | null;
    deleted?: boolean;
    evm_address?: string;
    expiration_timestamp?: string | null;
    file_id?: string | null;
    max_automatic_token_associations?: number | null;
    memo?: string;
    nonce?: number | null;
    obtainer_id?: string | null;
    permanent_removal?: boolean | null;
    proxy_account_id?: string | null;
    timestamp?: {
        description?: string;
        from: string;
        to?: string | null;
    };
}
type ExchangeRate = {
    hbar_equivalent: number;
    cent_equivalent: number;
    expiration_time: number;
};
type ExchangeRateResponse = {
    current_rate: ExchangeRate;
    next_rate: ExchangeRate;
    timestamp: string;
};
interface TokenAirdropsResponse {
    airdrops: TokenAirdrop[];
    links: Links;
}
interface TokenAirdrop {
    amount: number;
    receiver_id: string | null;
    sender_id: string | null;
    serial_number: number | null;
    timestamp: TimestampRange;
    token_id: string | null;
}
interface TimestampRange {
    from: string;
    to: string | null;
}
interface Links {
    next: string | null;
}

interface IHederaMirrornodeService {
    getAccount(accountId: string): Promise<AccountResponse>;
    getAccountHBarBalance(accountId: string): Promise<BigNumber>;
    getAccountTokenBalances(accountId: string): Promise<TokenBalancesResponse>;
    getTopicMessages(queryParams: TopicMessagesQueryParams): Promise<TopicMessagesResponse>;
    getTopicInfo(topicId: string): Promise<TopicInfo>;
    getTokenInfo(tokenId: string): Promise<TokenInfo>;
    getContractInfo(contractId: string): Promise<ContractInfo>;
    getTransactionRecord(transactionId: string, nonce?: number): Promise<TransactionDetailsResponse>;
    getExchangeRate(timestamp?: string): Promise<ExchangeRateResponse>;
    getPendingAirdrops(accountId: string): Promise<TokenAirdropsResponse>;
    getOutstandingAirdrops(accountId: string): Promise<TokenAirdropsResponse>;
}

type Tool = {
    method: string;
    name: string;
    description: string;
    parameters: z.ZodObject<any, any>;
    execute: (client: Client, context: Context, params: any) => Promise<any>;
};

interface Plugin {
    name: string;
    version?: string;
    description?: string;
    tools: (context: Context) => Tool[];
}
declare class PluginRegistry {
    private plugins;
    register(plugin: Plugin): void;
    getPlugins(): Plugin[];
    private loadCorePlugins;
    private loadPlugins;
    getTools(context: Context): Tool[];
    clear(): void;
}

declare enum AgentMode {
    AUTONOMOUS = "autonomous",
    RETURN_BYTES = "returnBytes"
}
type Context = {
    accountId?: string;
    accountPublicKey?: string;
    mode?: AgentMode;
    mirrornodeService?: IHederaMirrornodeService;
};
type Configuration = {
    tools?: string[];
    plugins?: Plugin[];
    context?: Context;
};

declare class HederaAgentAPI {
    client: Client;
    context: Context;
    tools: Tool[];
    constructor(client: Client, context?: Context, tools?: Tool[]);
    run(method: string, arg: unknown): Promise<string>;
}

interface TxModeStrategy {
    handle<T extends Transaction>(tx: T, client: Client, context: Context, postProcess?: (response: RawTransactionResponse) => unknown): Promise<unknown>;
}
interface RawTransactionResponse {
    status: string;
    accountId: AccountId | null;
    tokenId: TokenId | null;
    transactionId: string;
    topicId: TopicId | null;
    scheduleId: ScheduleId | null;
}
interface ExecuteStrategyResult {
    raw: RawTransactionResponse;
    humanMessage: string;
}
declare class ExecuteStrategy implements TxModeStrategy {
    defaultPostProcess(response: RawTransactionResponse): string;
    handle(tx: Transaction, client: Client, _context: Context, postProcess?: (response: RawTransactionResponse) => string): Promise<{
        raw: RawTransactionResponse;
        humanMessage: string;
    }>;
}
declare const handleTransaction: (tx: Transaction, client: Client, context: Context, postProcess?: (response: RawTransactionResponse) => string) => Promise<{
    bytes: Uint8Array<ArrayBufferLike>;
} | {
    raw: RawTransactionResponse;
    humanMessage: string;
}>;

declare class AccountResolver {
    /**
     * Gets the default account based on the agent mode and context.
     * In RETURN_BYTES mode, prefers context.accountId (user's account).
     * In AUTONOMOUS mode or when no context account, uses an operator account.
     */
    static getDefaultAccount(context: Context, client: Client): string;
    static getDefaultPublicKey(context: Context, client: Client): Promise<PublicKey>;
    /**
     * Resolves an account ID, using the provided account or falling back to the default.
     */
    static resolveAccount(providedAccount: string | undefined, context: Context, client: Client): string;
    /**
     * Gets a description of which account will be used as default for prompts.
     */
    static getDefaultAccountDescription(context: Context): string;
    static isHederaAddress(address: string): boolean;
    static getHederaEVMAddress(address: string, mirrorNode: IHederaMirrornodeService): Promise<string>;
}

declare class PromptGenerator {
    /**
     * Generates a consistent context snippet for tool prompts.
     */
    static getContextSnippet(context: Context): string;
    static getAnyAddressParameterDescription(paramName: string, context: Context, isRequired?: boolean): string;
    /**
     * Generates a consistent description for optional account parameters.
     */
    static getAccountParameterDescription(paramName: string, context: Context, isRequired?: boolean): string;
    /**
     * Generates consistent parameter usage instructions.
     */
    static getParameterUsageInstructions(): string;
}

declare const ERC20_FACTORY_ADDRESSES: Map<string, string>;
declare const ERC721_FACTORY_ADDRESSES: Map<string, string>;
declare const ERC20_FACTORY_ABI: string[];
declare const ERC721_FACTORY_ABI: string[];
declare const ERC20_TRANSFER_FUNCTION_NAME = "transfer";
declare const ERC20_TRANSFER_FUNCTION_ABI: string[];
declare const ERC721_TRANSFER_FUNCTION_NAME = "transferFrom";
declare const ERC721_TRANSFER_FUNCTION_ABI: string[];
declare const ERC721_MINT_FUNCTION_NAME = "safeMint";
declare const ERC721_MINT_FUNCTION_ABI: string[];
/**
 * Get the ERC20 factory contract address for the specified network
 * @param ledgerId - The Hedera network ledger ID
 * @returns The factory contract address for the network
 * @throws Error if the network is not supported
 */
declare function getERC20FactoryAddress(ledgerId: LedgerId): string;
/**
 * Get the ERC721 factory contract address for the specified network
 * @param ledgerId - The Hedera network ledger ID
 * @returns The factory contract address for the network
 * @throws Error if the network is not supported
 */
declare function getERC721FactoryAddress(ledgerId: LedgerId): string;

declare class HederaAgentKitTool$1 extends StructuredTool {
    hederaAPI: HederaAgentAPI;
    method: string;
    name: string;
    description: string;
    schema: z.ZodObject<any, any>;
    constructor(HederaAgentKitAPI: HederaAgentAPI, method: string, description: string, schema: z.ZodObject<any, any>);
    _call(arg: z.output<typeof this.schema>, _runManager?: CallbackManagerForToolRun, _parentConfig?: RunnableConfig): Promise<any>;
}

declare class HederaLangchainToolkit implements BaseToolkit {
    private _hederaAgentKit;
    tools: HederaAgentKitTool$1[];
    constructor({ client, configuration }: {
        client: Client;
        configuration: Configuration;
    });
    getTools(): HederaAgentKitTool$1[];
    getHederaAgentKitAPI(): HederaAgentAPI;
}

declare class HederaMCPToolkit extends McpServer {
    private _hederaAgentKit;
    constructor({ client, configuration }: {
        client: Client;
        configuration: Configuration;
    });
}

declare class HederaAIToolkit {
    private _hedera;
    tools: {
        [key: string]: Tool$1;
    };
    constructor({ client, configuration }: {
        client: Client;
        configuration: Configuration;
    });
    middleware(): LanguageModelV1Middleware;
    getTools(): {
        [key: string]: Tool$1;
    };
}

declare const coreTokenPlugin: Plugin;
declare const coreTokenPluginToolNames: {
    readonly AIRDROP_FUNGIBLE_TOKEN_TOOL: "airdrop_fungible_token_tool";
    readonly CREATE_FUNGIBLE_TOKEN_TOOL: "create_fungible_token_tool";
    readonly MINT_FUNGIBLE_TOKEN_TOOL: "mint_fungible_token_tool";
    readonly CREATE_NON_FUNGIBLE_TOKEN_TOOL: "create_non_fungible_token_tool";
    readonly MINT_NON_FUNGIBLE_TOKEN_TOOL: "mint_non_fungible_token_tool";
    readonly DISSOCIATE_TOKEN_TOOL: "dissociate_token_tool";
    readonly ASSOCIATE_TOKEN_TOOL: "associate_token_tool";
    readonly UPDATE_TOKEN_TOOL: "update_token_tool";
};

declare const coreAccountPlugin: Plugin;
declare const coreAccountPluginToolNames: {
    readonly TRANSFER_HBAR_TOOL: "transfer_hbar_tool";
    readonly APPROVE_HBAR_ALLOWANCE_TOOL: "approve_hbar_allowance_tool";
    readonly CREATE_ACCOUNT_TOOL: "create_account_tool";
    readonly DELETE_ACCOUNT_TOOL: "delete_account_tool";
    readonly UPDATE_ACCOUNT_TOOL: "update_account_tool";
    readonly SIGN_SCHEDULE_TRANSACTION_TOOL: "sign_schedule_transaction_tool";
    readonly SCHEDULE_DELETE_TOOL: "schedule_delete_tool";
};

declare const coreConsensusPlugin: Plugin;
declare const coreConsensusPluginToolNames: {
    readonly CREATE_TOPIC_TOOL: "create_topic_tool";
    readonly SUBMIT_TOPIC_MESSAGE_TOOL: "submit_topic_message_tool";
    readonly DELETE_TOPIC_TOOL: "delete_topic_tool";
    readonly UPDATE_TOPIC_TOOL: "update_topic_tool";
};

/**
 * @deprecated This plugin is deprecated. Use the specific query plugins instead:
 * - coreAccountQueryPlugin for account-related queries
 * - coreTokenQueryPlugin for token-related queries
 * - coreConsensusQueryPlugin for consensus-related queries
 * This export will be removed in a future version.
 */
declare const coreQueriesPlugin: Plugin;
/**
 * @deprecated Use the specific query plugin tool names instead:
 * - coreAccountQueryPluginToolNames for account-related query tools
 * - coreTokenQueryPluginToolNames for token-related query tools
 * - coreConsensusQueryPluginToolNames for consensus-related query tools
 * This export will be removed in a future version.
 */
declare const coreQueriesPluginToolNames: {
    readonly GET_HBAR_BALANCE_QUERY_TOOL: "get_hbar_balance_query_tool";
    readonly GET_ACCOUNT_QUERY_TOOL: "get_account_query_tool";
    readonly GET_ACCOUNT_TOKEN_BALANCES_QUERY_TOOL: "get_account_token_balances_query_tool";
    readonly GET_TOPIC_MESSAGES_QUERY_TOOL: "get_topic_messages_query_tool";
    readonly GET_TOKEN_INFO_QUERY_TOOL: "get_token_info_query_tool";
};

declare const coreMiscQueriesPlugin: Plugin;
declare const coreMiscQueriesPluginsToolNames: {
    readonly GET_EXCHANGE_RATE_TOOL: "get_exchange_rate_tool";
};

declare const coreEVMPlugin: Plugin;
declare const coreEVMPluginToolNames: {
    readonly TRANSFER_ERC721_TOOL: "transfer_erc721_tool";
    readonly MINT_ERC721_TOOL: "mint_erc721_tool";
    readonly CREATE_ERC20_TOOL: "create_erc20_tool";
    readonly TRANSFER_ERC20_TOOL: "transfer_erc20_tool";
    readonly CREATE_ERC721_TOOL: "create_erc721_tool";
};

declare const coreAccountQueryPlugin: Plugin;
declare const coreAccountQueryPluginToolNames: {
    readonly GET_HBAR_BALANCE_QUERY_TOOL: "get_hbar_balance_query_tool";
    readonly GET_ACCOUNT_QUERY_TOOL: "get_account_query_tool";
    readonly GET_ACCOUNT_TOKEN_BALANCES_QUERY_TOOL: "get_account_token_balances_query_tool";
};

declare const coreTokenQueryPlugin: Plugin;
declare const coreTokenQueryPluginToolNames: {
    readonly GET_TOKEN_INFO_QUERY_TOOL: "get_token_info_query_tool";
    readonly GET_PENDING_AIRDROP_TOOL: "get_pending_airdrop_tool";
};

declare const coreConsensusQueryPlugin: Plugin;
declare const coreConsensusQueryPluginToolNames: {
    readonly GET_TOPIC_MESSAGES_QUERY_TOOL: "get_topic_messages_query_tool";
    readonly GET_TOPIC_INFO_QUERY_TOOL: "get_topic_info_query_tool";
};

declare const coreEVMQueryPlugin: Plugin;
declare const coreEVMQueryPluginToolNames: {
    readonly GET_CONTRACT_INFO_QUERY_TOOL: "get_contract_info_query_tool";
};

declare const coreTransactionQueryPlugin: Plugin;
declare const coreTransactionQueryPluginToolNames: {
    readonly GET_TRANSACTION_RECORD_QUERY_TOOL: "get_transaction_record_query_tool";
};

/**
 * @deprecated Use coreTokenPlugin instead. This export will be removed in a future version.
 */
declare const coreHTSPlugin: Plugin;
/**
 * @deprecated Use coreTokenPluginToolNames instead. This export will be removed in a future version.
 */
declare const coreHTSPluginToolNames: {
    readonly AIRDROP_FUNGIBLE_TOKEN_TOOL: "airdrop_fungible_token_tool";
    readonly CREATE_FUNGIBLE_TOKEN_TOOL: "create_fungible_token_tool";
    readonly MINT_FUNGIBLE_TOKEN_TOOL: "mint_fungible_token_tool";
    readonly CREATE_NON_FUNGIBLE_TOKEN_TOOL: "create_non_fungible_token_tool";
    readonly MINT_NON_FUNGIBLE_TOKEN_TOOL: "mint_non_fungible_token_tool";
    readonly DISSOCIATE_TOKEN_TOOL: "dissociate_token_tool";
    readonly ASSOCIATE_TOKEN_TOOL: "associate_token_tool";
    readonly UPDATE_TOKEN_TOOL: "update_token_tool";
};
/**
 * @deprecated Use coreEVMPlugin instead. This export will be removed in a future version.
 */
declare const coreSCSPlugin: Plugin;
/**
 * @deprecated Use coreEVMPluginToolNames instead. This export will be removed in a future version.
 */
declare const coreSCSPluginToolNames: {
    readonly TRANSFER_ERC721_TOOL: "transfer_erc721_tool";
    readonly MINT_ERC721_TOOL: "mint_erc721_tool";
    readonly CREATE_ERC20_TOOL: "create_erc20_tool";
    readonly TRANSFER_ERC20_TOOL: "transfer_erc20_tool";
    readonly CREATE_ERC721_TOOL: "create_erc721_tool";
};

declare class HederaAgentKitTool implements Action {
    description: string;
    handler: Handler;
    similes?: string[] | undefined;
    examples?: ActionExample[][] | undefined;
    name: string;
    validate: Validator;
    constructor(client: Client, context: Context, tool: Tool);
}

declare class HederaElizaOSToolkit {
    private readonly tools;
    private readonly client;
    private readonly context;
    constructor({ client, configuration }: {
        client: Client;
        configuration: Configuration;
    });
    /**
     * Maps hedera-agent-kit tools and returns ElizaOS compatible actions
     */
    getTools(): HederaAgentKitTool[];
}

export { AccountResolver, AgentMode, type Configuration, type Context, ERC20_FACTORY_ABI, ERC20_FACTORY_ADDRESSES, ERC20_TRANSFER_FUNCTION_ABI, ERC20_TRANSFER_FUNCTION_NAME, ERC721_FACTORY_ABI, ERC721_FACTORY_ADDRESSES, ERC721_MINT_FUNCTION_ABI, ERC721_MINT_FUNCTION_NAME, ERC721_TRANSFER_FUNCTION_ABI, ERC721_TRANSFER_FUNCTION_NAME, ExecuteStrategy, type ExecuteStrategyResult, HederaAIToolkit, HederaElizaOSToolkit, HederaLangchainToolkit, HederaMCPToolkit, type Plugin, PluginRegistry, PromptGenerator, type RawTransactionResponse, type Tool, coreAccountPlugin, coreAccountPluginToolNames, coreAccountQueryPlugin, coreAccountQueryPluginToolNames, coreConsensusPlugin, coreConsensusPluginToolNames, coreConsensusQueryPlugin, coreConsensusQueryPluginToolNames, coreEVMPlugin, coreEVMPluginToolNames, coreEVMQueryPlugin, coreEVMQueryPluginToolNames, coreHTSPlugin, coreHTSPluginToolNames, coreMiscQueriesPlugin, coreMiscQueriesPluginsToolNames, coreQueriesPlugin, coreQueriesPluginToolNames, coreSCSPlugin, coreSCSPluginToolNames, coreTokenPlugin, coreTokenPluginToolNames, coreTokenQueryPlugin, coreTokenQueryPluginToolNames, coreTransactionQueryPlugin, coreTransactionQueryPluginToolNames, getERC20FactoryAddress, getERC721FactoryAddress, handleTransaction };
