// src/shared/api.ts
var HederaAgentAPI = class {
  client;
  context;
  tools;
  constructor(client, context, tools) {
    this.client = client;
    if (!this.client.ledgerId) {
      throw new Error("Client must be connected to a network");
    }
    this.context = context || {};
    this.tools = tools || [];
  }
  async run(method, arg) {
    const tool41 = this.tools.find((t) => t.method === method);
    if (tool41) {
      const output = JSON.stringify(await tool41.execute(this.client, this.context, arg));
      return output;
    } else {
      throw new Error("Invalid method " + method);
    }
  }
};
var api_default = HederaAgentAPI;

// src/shared/configuration.ts
var AgentMode = /* @__PURE__ */ ((AgentMode2) => {
  AgentMode2["AUTONOMOUS"] = "autonomous";
  AgentMode2["RETURN_BYTES"] = "returnBytes";
  return AgentMode2;
})(AgentMode || {});

// src/shared/parameter-schemas/token.zod.ts
import { z } from "zod";
import { AccountId, PublicKey, TokenId, TokenSupplyType, TokenType } from "@hashgraph/sdk";
var createFungibleTokenParameters = (_context = {}) => z.object({
  tokenName: z.string().describe("The name of the token."),
  tokenSymbol: z.string().describe("The symbol of the token."),
  initialSupply: z.number().int().optional().default(0).describe("The initial supply of the token."),
  supplyType: z.enum(["finite", "infinite"]).optional().default("finite").describe("Supply type of the token."),
  maxSupply: z.number().int().optional().describe("The maximum supply of the token."),
  decimals: z.number().int().optional().default(0).describe("The number of decimals."),
  treasuryAccountId: z.string().optional().describe("The treasury account of the token."),
  isSupplyKey: z.boolean().optional().describe("Determines if the token supply key should be set.")
});
var createNonFungibleTokenParameters = (_context = {}) => z.object({
  tokenName: z.string().describe("The name of the token."),
  tokenSymbol: z.string().describe("The symbol of the token."),
  maxSupply: z.number().int().optional().default(100).describe("The maximum supply of the token."),
  treasuryAccountId: z.string().optional().describe("The treasury account of the token.")
});
var AirdropRecipientSchema = z.object({
  accountId: z.string().describe('Recipient account ID (e.g., "0.0.xxxx").'),
  amount: z.union([z.number(), z.string()]).describe("Amount in base unit.")
});
var airdropFungibleTokenParameters = (_context = {}) => z.object({
  tokenId: z.string().describe("The id of the token."),
  sourceAccountId: z.string().optional().describe("The account to airdrop the token from."),
  recipients: z.array(AirdropRecipientSchema).min(1).describe("Array of recipient objects, each with accountId and amount.")
});
var mintFungibleTokenParameters = (_context = {}) => z.object({
  tokenId: z.string().describe("The id of the token."),
  amount: z.number().describe("The amount of tokens to mint.")
});
var mintNonFungibleTokenParameters = (_context = {}) => z.object({
  tokenId: z.string().describe("The id of the NFT class."),
  uris: z.array(z.string().max(100)).max(10).describe("An array of URIs hosting NFT metadata.")
});
var tokenInfoQueryParameters = (_context = {}) => z.object({
  tokenId: z.string().optional().describe("The token ID to query.")
});
var updateTokenParameters = (_context = {}) => z.object({
  tokenId: z.string().describe("The ID of the token to update (e.g., 0.0.12345)."),
  tokenDesc: z.string().optional().describe("Optional description of the token update operation."),
  tokenName: z.string().max(100).optional().describe("New name for the token. Up to 100 characters."),
  tokenSymbol: z.string().max(100).optional().describe("New symbol for the token. Up to 100 characters."),
  treasuryAccountId: z.string().optional().describe("New treasury account for the token (Hedera account ID)."),
  adminKey: z.union([z.boolean(), z.string()]).optional().describe(
    "New admin key. Pass boolean `true` to use the operator/user key, or provide a Hedera-compatible public key string. Required for most property updates."
  ),
  kycKey: z.union([z.boolean(), z.string()]).optional().describe(
    "New KYC key. Pass boolean `true` to use the operator/user key, or provide a public key string."
  ),
  freezeKey: z.union([z.boolean(), z.string()]).optional().describe(
    "New freeze key. Pass boolean `true` to use the operator/user key, or provide a public key string."
  ),
  wipeKey: z.union([z.boolean(), z.string()]).optional().describe(
    "New wipe key. Pass boolean `true` to use the operator/user key, or provide a public key string."
  ),
  supplyKey: z.union([z.boolean(), z.string()]).optional().describe(
    "New supply key. Pass boolean `true` to use the operator/user key, or provide a public key string."
  ),
  feeScheduleKey: z.union([z.boolean(), z.string()]).optional().describe(
    "New fee schedule key. Pass boolean `true` to use the operator/user key, or provide a public key string."
  ),
  pauseKey: z.union([z.boolean(), z.string()]).optional().describe(
    "New pause key. Pass boolean `true` to use the operator/user key, or provide a public key string."
  ),
  metadataKey: z.union([z.boolean(), z.string()]).optional().describe(
    "New metadata key. Pass boolean `true` to use the operator/user key, or provide a public key string."
  ),
  metadata: z.string().optional().describe("New metadata for the token, in bytes (as base64 or hex)."),
  tokenMemo: z.string().max(100).optional().describe("Short public memo for the token, up to 100 characters."),
  autoRenewAccountId: z.string().optional().describe("Account to automatically pay for token renewal (Hedera account ID).")
});
var associateTokenParameters = (_context = {}) => z.object({
  // If not passed, will be injected from context in normalisation
  accountId: z.string().optional().describe(
    "Account ID to associate tokens with (e.g., 0.0.xxxxx). If not provided, operator account ID will be used"
  ),
  // One or more token IDs to associate
  tokenIds: z.array(z.string()).min(1).describe("Array of token IDs to associate")
});
var pendingAirdropQueryParameters = (_context = {}) => z.object({
  accountId: z.string().optional().describe("The account ID to query.")
});
var dissociateTokenParameters = (_context = {}) => z.object({
  tokenIds: z.array(z.string()).min(1).describe("The list of Hedera token IDs (strings) to dissociate. Must provide at least one."),
  accountId: z.string().optional().describe(
    "The account ID from which to dissociate the tokens. Defaults to operator account."
  ),
  transactionMemo: z.string().optional().describe("Optional memo for the transaction.")
});

// src/shared/parameter-schemas/account.zod.ts
import { z as z2 } from "zod";
import { AccountId as AccountId2, Hbar, Key, Transaction, HbarAllowance } from "@hashgraph/sdk";
import BigNumber from "bignumber.js";
import Long from "long";
var transferHbarParameters = (_context = {}) => z2.object({
  transfers: z2.array(
    z2.object({
      accountId: z2.string().describe("Recipient account ID"),
      amount: z2.number().describe("Amount of HBAR to transfer")
    })
  ).describe("Array of HBAR transfers"),
  sourceAccountId: z2.string().optional().describe("Sender account ID"),
  transactionMemo: z2.string().optional().describe("Memo to include with the transaction")
});
var createAccountParameters = (_context = {}) => z2.object({
  publicKey: z2.string().optional().describe("Account public key. If not provided, a public key of the operator will be used"),
  accountMemo: z2.string().optional().describe("Optional memo for the account"),
  initialBalance: z2.number().optional().default(0).describe("Initial HBAR balance to fund the account (defaults to 0)"),
  maxAutomaticTokenAssociations: z2.number().optional().default(-1).describe("Max automatic token associations (-1 for unlimited)")
});
var deleteAccountParameters = (_context = {}) => z2.object({
  accountId: z2.string().describe("The account ID to delete."),
  transferAccountId: z2.string().optional().describe(
    "The ID of the account to transfer the remaining funds to. If not provided, the operator account ID will be used."
  )
});
var updateAccountParameters = (_context = {}) => z2.object({
  // If not passed, will be injected from context in normalisation
  accountId: z2.string().optional().describe(
    "Account ID to update (e.g., 0.0.xxxxx). If not provided, operator account ID will be used"
  ),
  maxAutomaticTokenAssociations: z2.number().int().optional().describe("Max automatic token associations, positive, zero or -1 if unlimited"),
  stakedAccountId: z2.string().optional().describe("Staked account ID"),
  accountMemo: z2.string().optional().describe("Account memo"),
  declineStakingReward: z2.boolean().optional().describe("Decline staking rewards")
});
var accountQueryParameters = (_context = {}) => z2.object({
  accountId: z2.string().describe("The account ID to query.")
});
var accountBalanceQueryParameters = (_context = {}) => z2.object({
  accountId: z2.string().optional().describe("The account ID to query.")
});
var accountTokenBalancesQueryParameters = (_context = {}) => z2.object({
  accountId: z2.string().optional().describe("The account ID to query. If not provided, this accountId will be used."),
  tokenId: z2.string().optional().describe("The token ID to query.")
});
var signScheduleTransactionParameters = (_context = {}) => z2.object({
  scheduleId: z2.string().describe("The ID of the scheduled transaction to sign")
});
var scheduleDeleteTransactionParameters = (_context = {}) => z2.object({
  scheduleId: z2.string().describe("The ID of the scheduled transaction to delete")
});
var approveHbarAllowanceParameters = (_context = {}) => z2.object({
  ownerAccountId: z2.string().optional().describe("Owner account ID (defaults to operator account ID if omitted)"),
  spenderAccountId: z2.string().describe("Spender account ID"),
  amount: z2.number().describe("Amount of HBAR to approve as allowance (can be decimal, not negative)"),
  transactionMemo: z2.string().optional().describe("Memo to include with the transaction")
});

// src/shared/parameter-schemas/consensus.zod.ts
import { z as z3 } from "zod";
import { AccountId as AccountId3, PublicKey as PublicKey2, TopicId } from "@hashgraph/sdk";
var getTopicInfoParameters = (_context = {}) => {
  return z3.object({
    topicId: z3.string().describe("The topic ID to query.")
  });
};
var createTopicParameters = (_context = {}) => {
  return z3.object({
    isSubmitKey: z3.boolean().optional().default(false).describe("Whether to set a submit key for the topic (optional)"),
    topicMemo: z3.string().optional().describe("Memo for the topic (optional)"),
    transactionMemo: z3.string().optional().describe("An optional memo to include on the submitted transaction (optional).")
  });
};
var submitTopicMessageParameters = (_context = {}) => {
  return z3.object({
    topicId: z3.string().describe("The ID of the topic to submit the message to"),
    message: z3.string().describe("The message to submit to the topic"),
    transactionMemo: z3.string().optional().describe("An optional memo to include on the submitted transaction (optional).")
  });
};
var deleteTopicParameters = (_context = {}) => z3.object({
  topicId: z3.string().describe("The ID of the topic to delete.")
});
var deleteTopicParametersNormalised = (_context = {}) => deleteTopicParameters(_context).extend({});
var topicMessagesQueryParameters = (_context = {}) => z3.object({
  topicId: z3.string().describe("The topic ID to query."),
  startTime: z3.string().datetime().optional().describe(
    "The start time to query. If set, the messages will be returned after this timestamp."
  ),
  endTime: z3.string().datetime().optional().describe(
    "The end time to query. If set, the messages will be returned before this timestamp."
  ),
  limit: z3.number().optional().describe("The limit of messages to query. If set, the number of messages to return.")
});
var updateTopicParameters = (_context = {}) => z3.object({
  topicId: z3.string().describe("The ID of the topic to update (e.g., 0.0.12345)."),
  topicMemo: z3.string().optional().describe("Optional new memo for the topic."),
  adminKey: z3.union([z3.boolean(), z3.string()]).optional().describe(
    "New admin key. Pass boolean `true` to use the operator/user key, or provide a Hedera-compatible public key string."
  ),
  submitKey: z3.union([z3.boolean(), z3.string()]).optional().describe(
    "New submit key. Pass boolean `true` to use the operator/user key, or provide a Hedera-compatible public key string."
  ),
  autoRenewAccountId: z3.string().optional().describe("Account to automatically pay for topic renewal (Hedera account ID)."),
  autoRenewPeriod: z3.number().optional().describe("Auto renew period in seconds."),
  expirationTime: z3.union([z3.string(), z3.instanceof(Date)]).optional().describe("New expiration time for the topic (ISO string or Date).")
});

// src/shared/hedera-utils/hedera-parameter-normaliser.ts
import {
  AccountId as AccountId4,
  Hbar as Hbar2,
  PublicKey as PublicKey4,
  TokenId as TokenId2,
  TokenSupplyType as TokenSupplyType2,
  TokenType as TokenType2,
  TopicId as TopicId2,
  HbarAllowance as HbarAllowance2
} from "@hashgraph/sdk";
import z6 from "zod";

// src/shared/hedera-utils/decimals-utils.ts
import BigNumber2 from "bignumber.js";
function toBaseUnit(amount, decimals) {
  const amountBN = new BigNumber2(amount);
  const multiplier = new BigNumber2(10).pow(decimals);
  return amountBN.multipliedBy(multiplier).integerValue(BigNumber2.ROUND_FLOOR);
}
function toDisplayUnit(baseAmount, decimals) {
  const baseAmountBN = new BigNumber2(baseAmount);
  const divisor = new BigNumber2(10).pow(decimals);
  return baseAmountBN.dividedBy(divisor);
}

// src/shared/hedera-utils/hedera-parameter-normaliser.ts
import Long2 from "long";

// src/shared/utils/account-resolver.ts
import { PublicKey as PublicKey3 } from "@hashgraph/sdk";
var AccountResolver = class _AccountResolver {
  /**
   * Gets the default account based on the agent mode and context.
   * In RETURN_BYTES mode, prefers context.accountId (user's account).
   * In AUTONOMOUS mode or when no context account, uses an operator account.
   */
  static getDefaultAccount(context, client) {
    if (context.accountId) {
      return context.accountId;
    }
    const operatorAccount = client.operatorAccountId?.toString();
    if (!operatorAccount) {
      throw new Error("No account available: neither context.accountId nor operator account");
    }
    return operatorAccount;
  }
  static async getDefaultPublicKey(context, client) {
    if (context.mode === "autonomous" /* AUTONOMOUS */) {
      return client.operatorPublicKey;
    }
    const defaultAccount = this.getDefaultAccount(context, client);
    const defaultAccountDetails = await context.mirrornodeService?.getAccount(defaultAccount);
    if (!defaultAccountDetails?.accountPublicKey) {
      throw new Error("No public key available for the default account");
    }
    return PublicKey3.fromString(defaultAccountDetails.accountPublicKey);
  }
  /**
   * Resolves an account ID, using the provided account or falling back to the default.
   */
  static resolveAccount(providedAccount, context, client) {
    return providedAccount || this.getDefaultAccount(context, client);
  }
  /**
   * Gets a description of which account will be used as default for prompts.
   */
  static getDefaultAccountDescription(context) {
    if (context.mode === "returnBytes" /* RETURN_BYTES */ && context.accountId) {
      return `user account (${context.accountId})`;
    }
    return "operator account";
  }
  static isHederaAddress(address) {
    return address.startsWith("0.") || address.startsWith("0.0.");
  }
  static async getHederaEVMAddress(address, mirrorNode) {
    if (!_AccountResolver.isHederaAddress(address)) {
      return address;
    }
    const account = await mirrorNode.getAccount(address);
    return account.evmAddress;
  }
};

// src/shared/hedera-utils/hedera-parameter-normaliser.ts
import { ethers } from "ethers";

// src/shared/parameter-schemas/evm.zod.ts
import { z as z4 } from "zod";
var transferERC20Parameters = (_context = {}) => z4.object({
  contractId: z4.string().describe("The id of the ERC20 contract."),
  recipientAddress: z4.string().describe("Address to which the tokens will be transferred."),
  amount: z4.number().describe("The amount of tokens to transfer.")
});
var createERC721Parameters = (_context = {}) => z4.object({
  tokenName: z4.string().describe("The name of the token."),
  tokenSymbol: z4.string().describe("The symbol of the token."),
  baseURI: z4.string().default("").describe("The base URI for token metadata.")
});
var createERC20Parameters = (_context = {}) => z4.object({
  tokenName: z4.string().describe("The name of the token."),
  tokenSymbol: z4.string().describe("The symbol of the token."),
  decimals: z4.number().int().min(0).optional().default(18).describe("The number of decimals the token supports."),
  initialSupply: z4.number().int().min(0).optional().default(0).describe("The initial supply of the token.")
});
var transferERC721Parameters = (_context = {}) => z4.object({
  contractId: z4.string().describe("The id of the ERC721 contract."),
  fromAddress: z4.string().optional().describe("Address from which the token will be transferred."),
  toAddress: z4.string().describe("Address to which the token will be transferred."),
  tokenId: z4.number().describe("The ID of the token to transfer.")
});
var mintERC721Parameters = (_context = {}) => z4.object({
  contractId: z4.string().describe("The id of the ERC721 contract."),
  toAddress: z4.string().optional().describe("Address to which the token will be minted.")
});
var contractInfoQueryParameters = (_context = {}) => z4.object({
  contractId: z4.string().describe("The token ID to query.")
});

// src/shared/parameter-schemas/transaction.zod.ts
import { z as z5 } from "zod";
var transactionRecordQueryParameters = (_context = {}) => {
  return z5.object({
    transactionId: z5.string().describe(
      'The transaction ID to fetch details for. Should be in format \\"shard.realm.num-sss-nnn\\" format where sss are seconds and nnn are nanoseconds'
    ),
    nonce: z5.number().nonnegative().optional().describe("Optional nonnegative nonce value for the transaction")
  });
};

// src/shared/hedera-utils/hedera-parameter-normaliser.ts
var HederaParameterNormaliser = class _HederaParameterNormaliser {
  static parseParamsWithSchema(params, schema, context = {}) {
    let parsedParams;
    try {
      parsedParams = schema(context).parse(params);
    } catch (e) {
      if (e instanceof z6.ZodError) {
        const issues = this.formatZodIssues(e);
        throw new Error(`Invalid parameters: ${issues}`);
      }
      throw e;
    }
    return parsedParams;
  }
  static formatZodIssues(error) {
    return error.errors.map((err) => `Field "${err.path.join(".")}" - ${err.message}`).join("; ");
  }
  static async normaliseCreateFungibleTokenParams(params, context, client, mirrorNode) {
    const parsedParams = this.parseParamsWithSchema(params, createFungibleTokenParameters, context);
    const defaultAccountId = AccountResolver.getDefaultAccount(context, client);
    const treasuryAccountId = parsedParams.treasuryAccountId ?? defaultAccountId;
    if (!treasuryAccountId) throw new Error("Must include treasury account ID");
    const initialSupply = toBaseUnit(
      parsedParams.initialSupply ?? 0,
      parsedParams.decimals
    ).toNumber();
    const isFinite = (parsedParams.supplyType ?? "infinite") === "finite";
    const supplyType = isFinite ? TokenSupplyType2.Finite : TokenSupplyType2.Infinite;
    const maxSupply = isFinite ? toBaseUnit(parsedParams.maxSupply ?? 1e6, parsedParams.decimals).toNumber() : void 0;
    if (maxSupply !== void 0 && initialSupply > maxSupply) {
      throw new Error(`Initial supply (${initialSupply}) cannot exceed max supply (${maxSupply})`);
    }
    const publicKey = await mirrorNode.getAccount(defaultAccountId).then((r) => r.accountPublicKey) ?? client.operatorPublicKey?.toStringDer();
    return {
      ...parsedParams,
      supplyType,
      treasuryAccountId,
      maxSupply,
      initialSupply,
      autoRenewAccountId: defaultAccountId,
      supplyKey: parsedParams.isSupplyKey === true ? PublicKey4.fromString(publicKey) : void 0
    };
  }
  static async normaliseCreateNonFungibleTokenParams(params, context, client, mirrorNode) {
    const parsedParams = this.parseParamsWithSchema(params, createNonFungibleTokenParameters, context);
    const defaultAccountId = AccountResolver.getDefaultAccount(context, client);
    const treasuryAccountId = parsedParams.treasuryAccountId ?? defaultAccountId;
    if (!treasuryAccountId) throw new Error("Must include treasury account ID");
    const publicKey = await mirrorNode.getAccount(defaultAccountId).then((r) => r.accountPublicKey) ?? client.operatorPublicKey?.toStringDer();
    if (!publicKey) throw new Error("Could not determine public key for supply key");
    const maxSupply = parsedParams.maxSupply ?? 100;
    return {
      ...parsedParams,
      treasuryAccountId,
      maxSupply,
      supplyKey: PublicKey4.fromString(publicKey),
      // the supply key is mandatory in the case of NFT
      supplyType: TokenSupplyType2.Finite,
      // NFTs supply must be finite
      autoRenewAccountId: defaultAccountId,
      tokenType: TokenType2.NonFungibleUnique
    };
  }
  static normaliseTransferHbar(params, context, client) {
    const parsedParams = this.parseParamsWithSchema(params, transferHbarParameters, context);
    const sourceAccountId = AccountResolver.resolveAccount(
      parsedParams.sourceAccountId,
      context,
      client
    );
    const hbarTransfers = [];
    let totalTinybars = Long2.ZERO;
    for (const transfer of parsedParams.transfers) {
      const amount = new Hbar2(transfer.amount);
      if (amount.isNegative() || amount.toTinybars().equals(Long2.ZERO)) {
        throw new Error(`Invalid transfer amount: ${transfer.amount}`);
      }
      totalTinybars = totalTinybars.add(amount.toTinybars());
      hbarTransfers.push({
        accountId: transfer.accountId,
        amount
      });
    }
    hbarTransfers.push({
      accountId: sourceAccountId,
      amount: Hbar2.fromTinybars(totalTinybars.negate())
    });
    return {
      hbarTransfers,
      transactionMemo: parsedParams.transactionMemo
    };
  }
  static normaliseApproveHbarAllowance(params, context, client) {
    const parsedParams = this.parseParamsWithSchema(params, approveHbarAllowanceParameters, context);
    const ownerAccountId = AccountResolver.resolveAccount(
      parsedParams.ownerAccountId,
      context,
      client
    );
    const spenderAccountId = parsedParams.spenderAccountId;
    const amount = new Hbar2(parsedParams.amount);
    if (amount.isNegative()) {
      throw new Error(`Invalid allowance amount: ${parsedParams.amount}`);
    }
    return {
      hbarApprovals: [
        new HbarAllowance2({
          ownerAccountId: AccountId4.fromString(ownerAccountId),
          spenderAccountId: AccountId4.fromString(spenderAccountId),
          amount
        })
      ],
      transactionMemo: parsedParams.transactionMemo
    };
  }
  static async normaliseAirdropFungibleTokenParams(params, context, client, mirrorNode) {
    const parsedParams = this.parseParamsWithSchema(params, airdropFungibleTokenParameters, context);
    const sourceAccountId = AccountResolver.resolveAccount(
      parsedParams.sourceAccountId,
      context,
      client
    );
    const tokenInfo = await mirrorNode.getTokenInfo(parsedParams.tokenId);
    const tokenDecimals = parseInt(tokenInfo.decimals, 10);
    if (isNaN(tokenDecimals)) {
      throw new Error(`Invalid token decimals for token ${parsedParams.tokenId}`);
    }
    const tokenTransfers = [];
    let totalAmount = Long2.ZERO;
    for (const recipient of parsedParams.recipients) {
      const amountRaw = Number(recipient.amount);
      if (amountRaw <= 0) {
        throw new Error(`Invalid recipient amount: ${recipient.amount}`);
      }
      const amount = Long2.fromString(toBaseUnit(amountRaw, tokenDecimals).toNumber().toString());
      totalAmount = totalAmount.add(amount);
      tokenTransfers.push({
        tokenId: parsedParams.tokenId,
        accountId: recipient.accountId,
        amount
      });
    }
    tokenTransfers.push({
      tokenId: parsedParams.tokenId,
      accountId: sourceAccountId,
      amount: totalAmount.negate()
    });
    return {
      tokenTransfers
    };
  }
  static normaliseAssociateTokenParams(params, context, client) {
    const parsedParams = this.parseParamsWithSchema(params, associateTokenParameters, context);
    const accountId = AccountResolver.resolveAccount(parsedParams.accountId, context, client);
    return {
      accountId,
      tokenIds: parsedParams.tokenIds
    };
  }
  static async normaliseDissociateTokenParams(params, context, client) {
    const parsedParams = this.parseParamsWithSchema(params, dissociateTokenParameters, context);
    if (parsedParams.accountId === void 0) {
      parsedParams.accountId = AccountResolver.getDefaultAccount(context, client);
      if (!parsedParams.accountId) {
        throw new Error("Could not determine default account ID");
      }
    }
    return {
      ...parsedParams,
      accountId: AccountId4.fromString(parsedParams.accountId),
      tokenIds: parsedParams.tokenIds.map((id) => TokenId2.fromString(id))
    };
  }
  static async normaliseCreateTopicParams(params, context, client, mirrorNode) {
    const parsedParams = this.parseParamsWithSchema(params, createTopicParameters, context);
    const defaultAccountId = AccountResolver.getDefaultAccount(context, client);
    if (!defaultAccountId) throw new Error("Could not determine default account ID");
    const normalised = {
      ...parsedParams,
      autoRenewAccountId: defaultAccountId
    };
    if (parsedParams.isSubmitKey) {
      const publicKey = await mirrorNode.getAccount(defaultAccountId).then((r) => r.accountPublicKey) ?? client.operatorPublicKey?.toStringDer();
      if (!publicKey) {
        throw new Error("Could not determine public key for submit key");
      }
      normalised.submitKey = PublicKey4.fromString(publicKey);
    }
    return normalised;
  }
  static normaliseDeleteTopic(params, context, _client, _mirrorNode) {
    const parsedParams = this.parseParamsWithSchema(params, deleteTopicParameters, context);
    return this.parseParamsWithSchema(parsedParams, deleteTopicParametersNormalised, context);
  }
  static normaliseUpdateTopic = async (params, context, client) => {
    const parsedParams = this.parseParamsWithSchema(params, updateTopicParameters, context);
    const topicId = TopicId2.fromString(parsedParams.topicId);
    const userPublicKey = await AccountResolver.getDefaultPublicKey(context, client);
    const normalised = {
      topicId
    };
    const maybeKeys = {
      adminKey: parsedParams.adminKey,
      submitKey: parsedParams.submitKey
    };
    for (const [field, rawVal] of Object.entries(maybeKeys)) {
      const resolved = this.resolveKey(rawVal, userPublicKey);
      if (resolved) {
        normalised[field] = resolved;
      }
    }
    if (parsedParams.topicMemo) normalised.topicMemo = parsedParams.topicMemo;
    if (parsedParams.autoRenewAccountId)
      normalised.autoRenewAccountId = parsedParams.autoRenewAccountId;
    if (parsedParams.autoRenewPeriod) normalised.autoRenewPeriod = parsedParams.autoRenewPeriod;
    if (parsedParams.expirationTime) {
      normalised.expirationTime = parsedParams.expirationTime instanceof Date ? parsedParams.expirationTime : new Date(parsedParams.expirationTime);
    }
    return normalised;
  };
  static async normaliseCreateAccount(params, context, client, mirrorNode) {
    const parsedParams = this.parseParamsWithSchema(params, createAccountParameters, context);
    let publicKey = parsedParams.publicKey ?? client.operatorPublicKey?.toStringDer();
    if (!publicKey) {
      const defaultAccountId = AccountResolver.getDefaultAccount(context, client);
      if (defaultAccountId) {
        const account = await mirrorNode.getAccount(defaultAccountId);
        publicKey = account?.accountPublicKey;
      }
    }
    if (!publicKey) {
      throw new Error(
        "Unable to resolve public key: no param, mirror node, or client operator key available."
      );
    }
    return {
      ...parsedParams,
      key: PublicKey4.fromString(publicKey)
    };
  }
  static normaliseHbarBalanceParams(params, context, client) {
    const parsedParams = this.parseParamsWithSchema(params, accountBalanceQueryParameters, context);
    const accountId = AccountResolver.resolveAccount(parsedParams.accountId, context, client);
    return {
      ...parsedParams,
      accountId
    };
  }
  static normaliseAccountTokenBalancesParams(params, context, client) {
    const parsedParams = this.parseParamsWithSchema(params, accountTokenBalancesQueryParameters, context);
    const accountId = AccountResolver.resolveAccount(parsedParams.accountId, context, client);
    return {
      ...parsedParams,
      accountId
    };
  }
  static normaliseCreateERC20Params(params, factoryContractId, factoryContractAbi, factoryContractFunctionName, context) {
    const parsedParams = this.parseParamsWithSchema(params, createERC20Parameters, context);
    const iface = new ethers.Interface(factoryContractAbi);
    const encodedData = iface.encodeFunctionData(factoryContractFunctionName, [
      parsedParams.tokenName,
      parsedParams.tokenSymbol,
      parsedParams.decimals,
      parsedParams.initialSupply
    ]);
    const functionParameters = ethers.getBytes(encodedData);
    return {
      ...parsedParams,
      contractId: factoryContractId,
      functionParameters,
      gas: 3e6
      //TODO: make this configurable
    };
  }
  static normaliseCreateERC721Params(params, factoryContractId, factoryContractAbi, factoryContractFunctionName, context) {
    const parsedParams = this.parseParamsWithSchema(params, createERC721Parameters, context);
    const iface = new ethers.Interface(factoryContractAbi);
    const encodedData = iface.encodeFunctionData(factoryContractFunctionName, [
      parsedParams.tokenName,
      parsedParams.tokenSymbol,
      parsedParams.baseURI
    ]);
    const functionParameters = ethers.getBytes(encodedData);
    return {
      ...parsedParams,
      contractId: factoryContractId,
      functionParameters,
      gas: 3e6
      //TODO: make this configurable
    };
  }
  static async normaliseMintFungibleTokenParams(params, context, mirrorNode) {
    const parsedParams = this.parseParamsWithSchema(params, mintFungibleTokenParameters, context);
    const tokenInfo = await mirrorNode.getTokenInfo(parsedParams.tokenId);
    const decimals = Number(tokenInfo.decimals);
    const safeDecimals = Number.isFinite(decimals) ? decimals : 0;
    const baseAmount = toBaseUnit(parsedParams.amount, safeDecimals).toNumber();
    return {
      tokenId: parsedParams.tokenId,
      amount: baseAmount
    };
  }
  static normaliseMintNonFungibleTokenParams(params, context) {
    const parsedParams = this.parseParamsWithSchema(params, mintNonFungibleTokenParameters, context);
    const encoder = new TextEncoder();
    const metadata = parsedParams.uris.map((uri) => encoder.encode(uri));
    return {
      ...parsedParams,
      metadata
    };
  }
  static async normaliseTransferERC20Params(params, factoryContractAbi, factoryContractFunctionName, context, mirrorNode) {
    const parsedParams = this.parseParamsWithSchema(params, transferERC20Parameters, context);
    const recipientAddress = await AccountResolver.getHederaEVMAddress(
      parsedParams.recipientAddress,
      mirrorNode
    );
    const contractId = await _HederaParameterNormaliser.getHederaAccountId(
      parsedParams.contractId,
      mirrorNode
    );
    const iface = new ethers.Interface(factoryContractAbi);
    const encodedData = iface.encodeFunctionData(factoryContractFunctionName, [
      recipientAddress,
      parsedParams.amount
    ]);
    const functionParameters = ethers.getBytes(encodedData);
    return {
      contractId,
      functionParameters,
      gas: 1e5
    };
  }
  static async normaliseTransferERC721Params(params, factoryContractAbi, factoryContractFunctionName, context, mirrorNode, client) {
    const parsedParams = this.parseParamsWithSchema(params, transferERC721Parameters, context);
    const resolvedFromAddress = AccountResolver.resolveAccount(
      parsedParams.fromAddress,
      context,
      client
    );
    const fromAddress = await AccountResolver.getHederaEVMAddress(resolvedFromAddress, mirrorNode);
    const toAddress = await AccountResolver.getHederaEVMAddress(parsedParams.toAddress, mirrorNode);
    const contractId = await _HederaParameterNormaliser.getHederaAccountId(
      parsedParams.contractId,
      mirrorNode
    );
    const iface = new ethers.Interface(factoryContractAbi);
    const encodedData = iface.encodeFunctionData(factoryContractFunctionName, [
      fromAddress,
      toAddress,
      parsedParams.tokenId
    ]);
    const functionParameters = ethers.getBytes(encodedData);
    return {
      contractId,
      functionParameters,
      gas: 1e5
    };
  }
  static async normaliseMintERC721Params(params, factoryContractAbi, factoryContractFunctionName, context, mirrorNode, client) {
    const parsedParams = this.parseParamsWithSchema(params, mintERC721Parameters, context);
    const resolvedToAddress = AccountResolver.resolveAccount(
      parsedParams.toAddress,
      context,
      client
    );
    const toAddress = await AccountResolver.getHederaEVMAddress(resolvedToAddress, mirrorNode);
    const contractId = await _HederaParameterNormaliser.getHederaAccountId(
      parsedParams.contractId,
      mirrorNode
    );
    const iface = new ethers.Interface(factoryContractAbi);
    const encodedData = iface.encodeFunctionData(factoryContractFunctionName, [toAddress]);
    const functionParameters = ethers.getBytes(encodedData);
    return {
      contractId,
      functionParameters,
      gas: 1e5
    };
  }
  static normaliseDeleteAccount(params, context, client) {
    const parsedParams = this.parseParamsWithSchema(params, deleteAccountParameters, context);
    if (!AccountResolver.isHederaAddress(parsedParams.accountId)) {
      throw new Error("Account ID must be a Hedera address");
    }
    const transferAccountId = parsedParams.transferAccountId ?? AccountResolver.getDefaultAccount(context, client);
    if (!transferAccountId) {
      throw new Error("Could not determine transfer account ID");
    }
    return {
      accountId: AccountId4.fromString(parsedParams.accountId),
      transferAccountId: AccountId4.fromString(transferAccountId)
    };
  }
  static normaliseUpdateAccount(params, context, client) {
    const parsedParams = this.parseParamsWithSchema(params, updateAccountParameters, context);
    const accountId = AccountId4.fromString(
      AccountResolver.resolveAccount(parsedParams.accountId, context, client)
    );
    const normalised = {
      accountId
    };
    if (parsedParams.maxAutomaticTokenAssociations !== void 0) {
      normalised.maxAutomaticTokenAssociations = parsedParams.maxAutomaticTokenAssociations;
    }
    if (parsedParams.stakedAccountId !== void 0) {
      normalised.stakedAccountId = parsedParams.stakedAccountId;
    }
    if (parsedParams.accountMemo !== void 0) {
      normalised.accountMemo = parsedParams.accountMemo;
    }
    if (parsedParams.declineStakingReward !== void 0) {
      normalised.declineStakingReward = parsedParams.declineStakingReward;
    }
    return normalised;
  }
  static normaliseGetTransactionRecordParams(params, context) {
    const parsedParams = this.parseParamsWithSchema(params, transactionRecordQueryParameters, context);
    const normalised = {
      nonce: parsedParams.nonce
    };
    if (!parsedParams.transactionId) {
      throw new Error("transactionId is required");
    }
    const mirrorNodeStyleRegex = /^\d+\.\d+\.\d+-\d+-\d+$/;
    const sdkStyleRegex = /^(\d+\.\d+\.\d+)@(\d+)\.(\d+)$/;
    if (mirrorNodeStyleRegex.test(parsedParams.transactionId)) {
      normalised.transactionId = parsedParams.transactionId;
    } else {
      const match = parsedParams.transactionId.match(sdkStyleRegex);
      if (!match) {
        throw new Error(`Invalid transactionId format: ${parsedParams.transactionId}`);
      }
      const [, accountId, seconds, nanos] = match;
      normalised.transactionId = `${accountId}-${seconds}-${nanos}`;
    }
    return normalised;
  }
  static async getHederaAccountId(address, mirrorNode) {
    if (AccountResolver.isHederaAddress(address)) {
      return address;
    }
    const account = await mirrorNode.getAccount(address);
    return account.accountId;
  }
  static async normaliseUpdateToken(params, context, client) {
    const parsedParams = this.parseParamsWithSchema(params, updateTokenParameters, context);
    const tokenId = TokenId2.fromString(parsedParams.tokenId);
    const userPublicKey = await AccountResolver.getDefaultPublicKey(context, client);
    const normalised = {
      tokenId
    };
    const maybeKeys = {
      adminKey: parsedParams.adminKey,
      supplyKey: parsedParams.supplyKey,
      wipeKey: parsedParams.wipeKey,
      freezeKey: parsedParams.freezeKey,
      kycKey: parsedParams.kycKey,
      feeScheduleKey: parsedParams.feeScheduleKey,
      pauseKey: parsedParams.pauseKey,
      metadataKey: parsedParams.metadataKey
    };
    for (const [field, rawVal] of Object.entries(maybeKeys)) {
      const resolved = this.resolveKey(rawVal, userPublicKey);
      if (resolved) {
        normalised[field] = resolved;
      }
    }
    if (parsedParams.tokenName) {
      normalised.tokenName = parsedParams.tokenName;
    }
    if (parsedParams.tokenSymbol) {
      normalised.tokenSymbol = parsedParams.tokenSymbol;
    }
    if (parsedParams.treasuryAccountId) {
      normalised.treasuryAccountId = parsedParams.treasuryAccountId;
    }
    if (parsedParams.tokenMemo) {
      normalised.tokenMemo = parsedParams.tokenMemo;
    }
    if (parsedParams.metadata) {
      normalised.metadata = new TextEncoder().encode(parsedParams.metadata);
    }
    if (parsedParams.autoRenewAccountId) {
      normalised.autoRenewAccountId = parsedParams.autoRenewAccountId;
    }
    return normalised;
  }
  static resolveKey(rawValue, userKey) {
    if (rawValue === void 0) return void 0;
    if (typeof rawValue === "string") {
      try {
        return PublicKey4.fromStringED25519(rawValue);
      } catch {
        return PublicKey4.fromStringECDSA(rawValue);
      }
    }
    if (rawValue) {
      return userKey;
    }
    return void 0;
  }
};

// src/plugins/core-token-plugin/tools/fungible-token/airdrop-fungible-token.ts
import { Status } from "@hashgraph/sdk";

// src/shared/strategies/tx-mode-strategy.ts
import { AccountId as AccountId5, TransactionId } from "@hashgraph/sdk";
var ExecuteStrategy = class {
  defaultPostProcess(response) {
    return JSON.stringify(response, null, 2);
  }
  async handle(tx, client, _context, postProcess35 = this.defaultPostProcess) {
    const submit = await tx.execute(client);
    const receipt = await submit.getReceipt(client);
    const rawTransactionResponse = {
      status: receipt.status.toString(),
      accountId: receipt.accountId,
      tokenId: receipt.tokenId,
      transactionId: tx.transactionId?.toString() ?? "",
      topicId: receipt.topicId,
      scheduleId: receipt.scheduleId
    };
    return {
      raw: rawTransactionResponse,
      humanMessage: postProcess35(rawTransactionResponse)
    };
  }
};
var ReturnBytesStrategy = class {
  async handle(tx, _client, context) {
    if (!context.accountId) throw new Error("\u2026");
    const id = TransactionId.generate(context.accountId);
    tx.setNodeAccountIds([new AccountId5(4), new AccountId5(5)]).setTransactionId(id).freeze();
    return { bytes: tx.toBytes() };
  }
};
var getStrategyFromContext = (context) => {
  if (context.mode === "returnBytes" /* RETURN_BYTES */) {
    return new ReturnBytesStrategy();
  }
  return new ExecuteStrategy();
};
var handleTransaction = async (tx, client, context, postProcess35) => {
  const strategy = getStrategyFromContext(context);
  return await strategy.handle(tx, client, context, postProcess35);
};

// src/shared/hedera-utils/hedera-builder.ts
import {
  TokenAirdropTransaction,
  TokenCreateTransaction,
  TokenDeleteTransaction,
  TopicCreateTransaction,
  TopicDeleteTransaction,
  TopicMessageSubmitTransaction,
  TransferTransaction,
  ContractExecuteTransaction,
  TokenMintTransaction,
  TokenAssociateTransaction,
  AccountCreateTransaction,
  AccountDeleteTransaction,
  AccountUpdateTransaction,
  ScheduleSignTransaction,
  ScheduleCreateTransaction,
  TokenUpdateTransaction,
  ScheduleDeleteTransaction,
  TokenDissociateTransaction,
  TopicUpdateTransaction,
  AccountId as AccountId6,
  TokenId as TokenId4,
  AccountAllowanceApproveTransaction
} from "@hashgraph/sdk";
var HederaBuilder = class {
  static createScheduleTransaction(params) {
    return new ScheduleCreateTransaction(params.params).setScheduledTransaction(
      params.scheduledTransaction
    );
  }
  static createFungibleToken(params) {
    return new TokenCreateTransaction(params);
  }
  static createNonFungibleToken(params) {
    return new TokenCreateTransaction(params);
  }
  static transferHbar(params) {
    return new TransferTransaction(params);
  }
  static airdropFungibleToken(params) {
    return new TokenAirdropTransaction(params);
  }
  static updateToken(params) {
    return new TokenUpdateTransaction(params);
  }
  static createTopic(params) {
    const { transactionMemo, ...rest } = params;
    const tx = new TopicCreateTransaction(rest);
    if (transactionMemo) tx.setTransactionMemo(transactionMemo);
    return tx;
  }
  static submitTopicMessage(params) {
    const { transactionMemo, ...rest } = params;
    const tx = new TopicMessageSubmitTransaction(rest);
    if (transactionMemo) tx.setTransactionMemo(transactionMemo);
    return tx;
  }
  static updateTopic(params) {
    return new TopicUpdateTransaction(params);
  }
  static executeTransaction(params) {
    return new ContractExecuteTransaction(params);
  }
  static mintFungibleToken(params) {
    return new TokenMintTransaction(params);
  }
  static mintNonFungibleToken(params) {
    return new TokenMintTransaction(params);
  }
  static dissociateToken(params) {
    return new TokenDissociateTransaction(params);
  }
  static createAccount(params) {
    return new AccountCreateTransaction(params);
  }
  static deleteAccount(params) {
    return new AccountDeleteTransaction(params);
  }
  static updateAccount(params) {
    return new AccountUpdateTransaction(params);
  }
  static deleteToken(params) {
    return new TokenDeleteTransaction(params);
  }
  static deleteTopic(params) {
    return new TopicDeleteTransaction(params);
  }
  static signScheduleTransaction(params) {
    return new ScheduleSignTransaction(params);
  }
  static deleteScheduleTransaction(params) {
    return new ScheduleDeleteTransaction(params);
  }
  static associateToken(params) {
    return new TokenAssociateTransaction({
      accountId: AccountId6.fromString(params.accountId),
      tokenIds: params.tokenIds.map((t) => TokenId4.fromString(t))
    });
  }
  static approveHbarAllowance(params) {
    const tx = new AccountAllowanceApproveTransaction(params);
    if (params.transactionMemo) {
      tx.setTransactionMemo(params.transactionMemo);
    }
    return tx;
  }
};

// src/shared/hedera-utils/mirrornode/types.ts
import { LedgerId } from "@hashgraph/sdk";
var LedgerIdToBaseUrl = /* @__PURE__ */ new Map([
  [LedgerId.MAINNET.toString(), "https://mainnet-public.mirrornode.hedera.com/api/v1"],
  [LedgerId.TESTNET.toString(), "https://testnet.mirrornode.hedera.com/api/v1"]
]);

// src/shared/hedera-utils/mirrornode/hedera-mirrornode-service-default-impl.ts
import BigNumber3 from "bignumber.js";
var HederaMirrornodeServiceDefaultImpl = class {
  constructor(ledgerId) {
    this.ledgerId = ledgerId;
    if (!LedgerIdToBaseUrl.has(ledgerId.toString())) {
      throw new Error(`Network type ${ledgerId} not supported`);
    }
    this.baseUrl = LedgerIdToBaseUrl.get(ledgerId.toString());
  }
  baseUrl;
  async getAccount(accountId) {
    const url = `${this.baseUrl}/accounts/${accountId}`;
    const response = await fetch(url);
    if (!response.ok) {
      throw new Error(
        `Failed to fetch account ${accountId}: ${response.status} ${response.statusText}`
      );
    }
    const data = await response.json();
    if (!data.account) {
      throw new Error(`Account ${accountId} not found`);
    }
    return {
      accountId: data.account,
      accountPublicKey: data?.key?.key,
      balance: data.balance,
      evmAddress: data.evm_address
    };
  }
  async getAccountHBarBalance(accountId) {
    let account;
    try {
      account = await this.getAccount(accountId);
    } catch (error) {
      throw Error(`Failed to fetch hbar balance for ${accountId}: ${error}`);
    }
    return new BigNumber3(account.balance.balance);
  }
  async getAccountTokenBalances(accountId, tokenId) {
    const tokenIdParam = tokenId ? `&token.id=${tokenId}` : "";
    const url = `${this.baseUrl}/accounts/${accountId}/tokens?${tokenIdParam}`;
    const response = await fetch(url);
    if (!response.ok) {
      throw new Error(
        `Failed to fetch balance for an account ${accountId}: ${response.status} ${response.statusText}`
      );
    }
    return await response.json();
  }
  async getTopicMessages(queryParams) {
    const lowerThreshold = queryParams.lowerTimestamp ? `&timestamp=gte:${queryParams.lowerTimestamp}` : "";
    const upperThreshold = queryParams.upperTimestamp ? `&timestamp=lte:${queryParams.upperTimestamp}` : "";
    const baseParams = `&order=desc&limit=100`;
    let url = `${this.baseUrl}/topics/${queryParams.topicId}/messages?${lowerThreshold}${upperThreshold}${baseParams}`;
    const arrayOfMessages = [];
    let fetchedMessages = 0;
    try {
      while (url) {
        fetchedMessages += 1;
        const response = await fetch(url);
        if (!response.ok) {
          throw new Error(
            `Failed to get topic messages for ${queryParams.topicId}: ${response.status} ${response.statusText}`
          );
        }
        const data = await response.json();
        arrayOfMessages.push(...data.messages);
        if (fetchedMessages >= 100) {
          break;
        }
        url = data.links.next ? this.baseUrl + data.links.next : null;
      }
    } catch (error) {
      console.error(`Failed to fetch topic messages for ${queryParams.topicId}. Error:`, error);
      throw error;
    }
    return {
      topicId: queryParams.topicId,
      messages: arrayOfMessages.slice(0, queryParams.limit)
    };
  }
  async getTokenInfo(tokenId) {
    const url = `${this.baseUrl}/tokens/${tokenId}`;
    const response = await fetch(url);
    if (!response.ok) {
      throw new Error(
        `Failed to get token info for a token ${tokenId}: ${response.status} ${response.statusText}`
      );
    }
    return await response.json();
  }
  async getTopicInfo(topicId) {
    const url = `${this.baseUrl}/topics/${topicId}`;
    const response = await fetch(url);
    if (!response.ok) {
      throw new Error(
        `Failed to get topic info for ${topicId}: ${response.status} ${response.statusText}`
      );
    }
    return await response.json();
  }
  async getTransactionRecord(transactionId, nonce) {
    let url = `${this.baseUrl}/transactions/${transactionId}`;
    if (nonce !== void 0) {
      url += `?nonce=${nonce}`;
    }
    const response = await fetch(url);
    if (!response.ok) {
      throw new Error(
        `Failed to get transaction record for ${transactionId}: ${response.status} ${response.statusText}`
      );
    }
    return await response.json();
  }
  async getContractInfo(contractId) {
    const url = `${this.baseUrl}/contracts/${contractId}`;
    const response = await fetch(url);
    if (!response.ok) {
      throw new Error(
        `Failed to get contract info for ${contractId}: ${response.status} ${response.statusText}`
      );
    }
    return await response.json();
  }
  async getPendingAirdrops(accountId) {
    const url = `${this.baseUrl}/accounts/${accountId}/airdrops/pending`;
    const response = await fetch(url);
    if (!response.ok) {
      throw new Error(
        `Failed to fetch pending airdrops for an account ${accountId}: ${response.status} ${response.statusText}`
      );
    }
    return await response.json();
  }
  async getOutstandingAirdrops(accountId) {
    const url = `${this.baseUrl}/accounts/${accountId}/airdrops/outstanding`;
    const response = await fetch(url);
    if (!response.ok) {
      throw new Error(
        `Failed to fetch outstanding airdrops for an account ${accountId}: ${response.status} ${response.statusText}`
      );
    }
    return await response.json();
  }
  async getExchangeRate(timestamp) {
    const timestampParam = timestamp ? `?timestamp=${encodeURIComponent(timestamp)}` : "";
    const url = `${this.baseUrl}/network/exchangerate${timestampParam}`;
    const response = await fetch(url);
    if (!response.ok) {
      throw new Error(`HTTP error! status: ${response.status}. Message: ${response.statusText}`);
    }
    return await response.json();
  }
};

// src/shared/hedera-utils/mirrornode/hedera-mirrornode-utils.ts
var getMirrornodeService = (mirrornodeService, ledgerId) => {
  if (mirrornodeService) {
    return mirrornodeService;
  }
  return new HederaMirrornodeServiceDefaultImpl(ledgerId);
};

// src/shared/utils/prompt-generator.ts
var PromptGenerator = class {
  /**
   * Generates a consistent context snippet for tool prompts.
   */
  static getContextSnippet(context) {
    const lines = ["Context:"];
    if (context.mode === "returnBytes" /* RETURN_BYTES */) {
      lines.push(`- Mode: Return Bytes (preparing transactions for user signing)`);
      if (context.accountId) {
        lines.push(`- User Account: ${context.accountId} (default for transaction parameters)`);
        lines.push(`- When no account is specified, ${context.accountId} will be used`);
      } else {
        lines.push(`- User Account: Not specified`);
        lines.push(`- When no account is specified, the operator account will be used`);
      }
    } else if (context.mode === "autonomous" /* AUTONOMOUS */) {
      lines.push(`- Mode: Autonomous (agent executes transactions directly)`);
      if (context.accountId) {
        lines.push(`- User Account: ${context.accountId}`);
      }
      lines.push(`- When no account is specified, the operator account will be used`);
    } else {
      lines.push(`- Mode: ${context.mode || "Not specified"}`);
      if (context.accountId) {
        lines.push(`- User Account: ${context.accountId}`);
      }
      lines.push(`- Default account will be determined at execution time`);
    }
    return lines.join("\n");
  }
  static getAnyAddressParameterDescription(paramName, context, isRequired = false) {
    if (isRequired) {
      return `${paramName} (str, required): The account address. This can be the EVM address or the Hedera account id`;
    }
    return `${paramName} (str, optional): The Hedera account ID or EVM address. If not provided, defaults to the ${AccountResolver.getDefaultAccountDescription(context)}`;
  }
  /**
   * Generates a consistent description for optional account parameters.
   */
  static getAccountParameterDescription(paramName, context, isRequired = false) {
    if (isRequired) {
      return `${paramName} (str, required): The Hedera account ID`;
    }
    const defaultAccountDesc = AccountResolver.getDefaultAccountDescription(context);
    return `${paramName} (str, optional): The Hedera account ID. If not provided, defaults to the ${defaultAccountDesc}`;
  }
  /**
   * Generates consistent parameter usage instructions.
   */
  static getParameterUsageInstructions() {
    return `
Important:
- Only include optional parameters if explicitly provided by the user
- Do not generate placeholder values for optional fields
- Leave optional parameters undefined if not specified by the user`;
  }
};

// src/plugins/core-token-plugin/tools/fungible-token/airdrop-fungible-token.ts
var airdropFungibleTokenPrompt = (context = {}) => {
  const contextSnippet = PromptGenerator.getContextSnippet(context);
  const sourceAccountDesc = PromptGenerator.getAccountParameterDescription(
    "sourceAccountId",
    context
  );
  const usageInstructions = PromptGenerator.getParameterUsageInstructions();
  return `
${contextSnippet}

This tool will airdrop a fungible token on Hedera.

Parameters:
- tokenId (str, required): The id of the token
- ${sourceAccountDesc}
- recipients (array, required): A list of recipient objects, each containing:
  - accountId (string): The recipient's account ID (e.g., "0.0.1234")
  - amount (number or string): The amount of tokens to send to that recipient (in base units)
- transactionMemo (str, optional): Optional memo for the transaction
${usageInstructions}

If the user specifies multiple recipients in a single request, include them all in **one tool call** as a list of recipients.
`;
};
var postProcess = (response) => {
  return `Token successfully airdropped with transaction id ${response.transactionId.toString()}`;
};
var airdropFungibleToken = async (client, context, params) => {
  try {
    const mirrornodeService = getMirrornodeService(context.mirrornodeService, client.ledgerId);
    const normalisedParams = await HederaParameterNormaliser.normaliseAirdropFungibleTokenParams(
      params,
      context,
      client,
      mirrornodeService
    );
    const tx = HederaBuilder.airdropFungibleToken(normalisedParams);
    const result = await handleTransaction(tx, client, context, postProcess);
    return result;
  } catch (error) {
    const desc = "Failed to airdrop fungible token";
    const message = desc + (error instanceof Error ? `: ${error.message}` : "");
    console.error("[airdrop_fungible_token_tool]", message);
    return { raw: { status: Status.InvalidTransaction, error: message }, humanMessage: message };
  }
};
var AIRDROP_FUNGIBLE_TOKEN_TOOL = "airdrop_fungible_token_tool";
var tool = (context) => ({
  method: AIRDROP_FUNGIBLE_TOKEN_TOOL,
  name: "Airdrop Fungible Token",
  description: airdropFungibleTokenPrompt(context),
  parameters: airdropFungibleTokenParameters(context),
  execute: airdropFungibleToken
});
var airdrop_fungible_token_default = tool;

// src/plugins/core-token-plugin/tools/fungible-token/create-fungible-token.ts
import { Status as Status2 } from "@hashgraph/sdk";
var createFungibleTokenPrompt = (context = {}) => {
  const contextSnippet = PromptGenerator.getContextSnippet(context);
  const treasuryAccountDesc = PromptGenerator.getAccountParameterDescription(
    "treasuryAccountId",
    context
  );
  const usageInstructions = PromptGenerator.getParameterUsageInstructions();
  return `
${contextSnippet}

This tool creates a fungible token on Hedera.

Parameters:
- tokenName (str, required): The name of the token
- tokenSymbol (str, optional): The symbol of the token
- initialSupply (int, optional): The initial supply of the token, defaults to 0
- supplyType (str, optional): The supply type of the token. Can be "finite" or "infinite". Defaults to "finite"
- maxSupply (int, optional): The maximum supply of the token. Only applicable if supplyType is "finite". Defaults to 1,000,000 if not specified
- decimals (int, optional): The number of decimals the token supports. Defaults to 0
- ${treasuryAccountDesc}
- isSupplyKey (boolean, optional): If user wants to set supply key set to true, otherwise false
${usageInstructions}
`;
};
var postProcess2 = (response) => {
  return `Token created successfully at address ${response.tokenId?.toString()} with transaction id ${response.transactionId}`;
};
var createFungibleToken = async (client, context, params) => {
  try {
    const mirrornodeService = getMirrornodeService(context.mirrornodeService, client.ledgerId);
    const normalisedParams = await HederaParameterNormaliser.normaliseCreateFungibleTokenParams(
      params,
      context,
      client,
      mirrornodeService
    );
    const tx = HederaBuilder.createFungibleToken(normalisedParams);
    const result = await handleTransaction(tx, client, context, postProcess2);
    return result;
  } catch (error) {
    const desc = "Failed to create fungible token";
    const message = desc + (error instanceof Error ? `: ${error.message}` : "");
    console.error("[create_fungible_token_tool]", message);
    return { raw: { status: Status2.InvalidTransaction, error: message }, humanMessage: message };
  }
};
var CREATE_FUNGIBLE_TOKEN_TOOL = "create_fungible_token_tool";
var tool2 = (context) => ({
  method: CREATE_FUNGIBLE_TOKEN_TOOL,
  name: "Create Fungible Token",
  description: createFungibleTokenPrompt(context),
  parameters: createFungibleTokenParameters(context),
  execute: createFungibleToken
});
var create_fungible_token_default = tool2;

// src/plugins/core-token-plugin/tools/fungible-token/mint-fungible-token.ts
import { Status as Status3 } from "@hashgraph/sdk";
var mintFungibleTokenPrompt = (context = {}) => {
  const contextSnippet = PromptGenerator.getContextSnippet(context);
  const usageInstructions = PromptGenerator.getParameterUsageInstructions();
  return `
${contextSnippet}

This tool will mint a given amount (supply) of an existing fungible token on Hedera.

Parameters:
- tokenId (str, required): The id of the token
- amount (number, required): The amount to be minted
${usageInstructions}

Example: "Mint 1 of 0.0.6458037" means minting the amount of 1 of the token with id 0.0.6458037.
`;
};
var postProcess3 = (response) => {
  return `Tokens successfully minted with transaction id ${response.transactionId.toString()}`;
};
var mintFungibleToken = async (client, context, params) => {
  try {
    const mirrornodeService = getMirrornodeService(context.mirrornodeService, client.ledgerId);
    const normalisedParams = await HederaParameterNormaliser.normaliseMintFungibleTokenParams(
      params,
      context,
      mirrornodeService
    );
    const tx = HederaBuilder.mintFungibleToken(normalisedParams);
    const result = await handleTransaction(tx, client, context, postProcess3);
    return result;
  } catch (error) {
    const desc = "Failed to mint fungible token";
    const message = desc + (error instanceof Error ? `: ${error.message}` : "");
    console.error("[mint_fungible_token_tool]", message);
    return { raw: { status: Status3.InvalidTransaction, error: message }, humanMessage: message };
  }
};
var MINT_FUNGIBLE_TOKEN_TOOL = "mint_fungible_token_tool";
var tool3 = (context) => ({
  method: MINT_FUNGIBLE_TOKEN_TOOL,
  name: "Mint Fungible Token",
  description: mintFungibleTokenPrompt(context),
  parameters: mintFungibleTokenParameters(context),
  execute: mintFungibleToken
});
var mint_fungible_token_default = tool3;

// src/plugins/core-token-plugin/tools/non-fungible-token/create-non-fungible-token.ts
import { Status as Status4 } from "@hashgraph/sdk";
var createNonFungibleTokenPrompt = (context = {}) => {
  const contextSnippet = PromptGenerator.getContextSnippet(context);
  const treasuryAccountDesc = PromptGenerator.getAccountParameterDescription(
    "treasuryAccountId",
    context
  );
  const usageInstructions = PromptGenerator.getParameterUsageInstructions();
  return `
${contextSnippet}

This tool creates a non-fungible token (NFT) on Hedera.

Parameters:
- tokenName (str, required): Name of the token
- tokenSymbol (str, required): Symbol of the token
- maxSupply (int, optional): Maximum NFT supply. Defaults to 100 if not provided
- ${treasuryAccountDesc}
${usageInstructions}
`;
};
var postProcess4 = (response) => {
  return `Token created successfully at address ${response.tokenId?.toString()} with transaction id ${response.transactionId.toString()}`;
};
var createNonFungibleToken = async (client, context, params) => {
  try {
    const mirrornodeService = getMirrornodeService(context.mirrornodeService, client.ledgerId);
    const normalisedParams = await HederaParameterNormaliser.normaliseCreateNonFungibleTokenParams(
      params,
      context,
      client,
      mirrornodeService
    );
    const tx = HederaBuilder.createNonFungibleToken(normalisedParams);
    const result = await handleTransaction(tx, client, context, postProcess4);
    return result;
  } catch (error) {
    const desc = "Failed to create non-fungible token";
    const message = desc + (error instanceof Error ? `: ${error.message}` : "");
    console.error("[create_non_fungible_token_tool]", message);
    return { raw: { status: Status4.InvalidTransaction, error: message }, humanMessage: message };
  }
};
var CREATE_NON_FUNGIBLE_TOKEN_TOOL = "create_non_fungible_token_tool";
var tool4 = (context) => ({
  method: CREATE_NON_FUNGIBLE_TOKEN_TOOL,
  name: "Create Non-Fungible Token",
  description: createNonFungibleTokenPrompt(context),
  parameters: createNonFungibleTokenParameters(context),
  execute: createNonFungibleToken
});
var create_non_fungible_token_default = tool4;

// src/plugins/core-token-plugin/tools/non-fungible-token/mint-non-fungible-token.ts
import { Status as Status5 } from "@hashgraph/sdk";
var mintNonFungibleTokenPrompt = (_context = {}) => {
  const usageInstructions = PromptGenerator.getParameterUsageInstructions();
  return `

This tool will mint NFTs with its unique metadata for the class of NFTs (non-fungible tokens) defined by the tokenId on Hedera.

Parameters:
- tokenId (str, required): The id of the token
- uris (array, required): An array of strings (URIs) of maximum size 10 hosting the NFT metadata
${usageInstructions}

Example: "Mint 0.0.6465503 with metadata: ipfs://bafyreiao6ajgsfji6qsgbqwdtjdu5gmul7tv2v3pd6kjgcw5o65b2ogst4/metadata.json" means minting an NFT with the given metadata URI for the class of NFTs defined by the token with id 0.0.6465503.
`;
};
var postProcess5 = (response) => {
  return `Token ${response.tokenId?.toString()} successfully minted with transaction id ${response.transactionId.toString()}`;
};
var mintNonFungibleToken = async (client, context, params) => {
  try {
    const normalisedParams = HederaParameterNormaliser.normaliseMintNonFungibleTokenParams(
      params,
      context
    );
    const tx = HederaBuilder.mintNonFungibleToken(normalisedParams);
    const result = await handleTransaction(tx, client, context, postProcess5);
    return result;
  } catch (error) {
    const desc = "Failed to mint non-fungible token";
    const message = desc + (error instanceof Error ? `: ${error.message}` : "");
    console.error("[mint_non_fungible_token_tool]", message);
    return { raw: { status: Status5.InvalidTransaction, error: message }, humanMessage: message };
  }
};
var MINT_NON_FUNGIBLE_TOKEN_TOOL = "mint_non_fungible_token_tool";
var tool5 = (context) => ({
  method: MINT_NON_FUNGIBLE_TOKEN_TOOL,
  name: "Mint Non-Fungible Token",
  description: mintNonFungibleTokenPrompt(context),
  parameters: mintNonFungibleTokenParameters(context),
  execute: mintNonFungibleToken
});
var mint_non_fungible_token_default = tool5;

// src/plugins/core-token-plugin/tools/update-token.ts
import { PublicKey as PublicKey5, Status as Status6 } from "@hashgraph/sdk";
var checkValidityOfUpdates = async (params, mirrornode, userPublicKey) => {
  const tokenDetails = await mirrornode.getTokenInfo(params.tokenId.toString());
  if (!tokenDetails) {
    throw new Error("Token not found");
  }
  if (tokenDetails.admin_key?.key !== userPublicKey.toStringRaw()) {
    console.error(
      `tokenDetails.admin_key.key: ${tokenDetails.admin_key?.key} vs userPublicKey: ${userPublicKey.toStringRaw()}`
    );
    throw new Error(
      "You do not have permission to update this token. The adminKey does not match your public key."
    );
  }
  const keyChecks = {
    adminKey: "admin_key",
    kycKey: "kyc_key",
    freezeKey: "freeze_key",
    wipeKey: "wipe_key",
    supplyKey: "supply_key",
    feeScheduleKey: "fee_schedule_key",
    pauseKey: "pause_key",
    metadataKey: "metadata_key"
  };
  for (const [paramKey, tokenField] of Object.entries(keyChecks)) {
    const userValue = params[paramKey];
    const tokenKey = tokenDetails[tokenField];
    if (userValue instanceof PublicKey5 && !tokenKey) {
      throw new Error(`Cannot update ${paramKey}: token was created without a ${paramKey}`);
    }
  }
};
var updateTokenPrompt = (context = {}) => {
  const contextSnippet = PromptGenerator.getContextSnippet(context);
  const tokenDesc = PromptGenerator.getAnyAddressParameterDescription("tokenId", context);
  const usageInstructions = PromptGenerator.getParameterUsageInstructions();
  return `
${contextSnippet}

This tool will update an existing Hedera HTS token. Only the fields provided will be updated.

Key fields (adminKey, kycKey, freezeKey, wipeKey, supplyKey, feeScheduleKey, pauseKey, metadataKey) must contain **Hedera-compatible public keys (as strings) or boolean (true/false)**. You can provide these in one of three ways:

1. **Boolean true** \u2013 Set this field to use user/operator key. Injecting of the key will be handled automatically.
2. **Not provided** \u2013 The field will not be updated.
3. **String** \u2013 Provide a Hedera-compatible public key string to set a field explicitly.

Parameters:
- ${tokenDesc}
- tokenName (string, optional): New name for the token. Up to 100 characters.
- tokenSymbol (string, optional): New symbol for the token. Up to 100 characters.
- treasuryAccountId (string, optional): New treasury account for the token (Hedera account ID).
- adminKey (boolean|string, optional): New admin key. Pass true to use your operator key, or provide a public key string.
- kycKey (boolean|string, optional): New KYC key. Pass true to use your operator key, or provide a public key string.
- freezeKey (boolean|string, optional): New freeze key. Pass true to use your operator key, or provide a public key string.
- wipeKey (boolean|string, optional): New wipe key. Pass true to use your operator key, or provide a public key string.
- supplyKey (boolean|string, optional): New supply key. Pass true to use your operator key, or provide a public key string.
- feeScheduleKey (boolean|string, optional): New fee schedule key. Pass true to use your operator key, or provide a public key string.
- pauseKey (boolean|string, optional): New pause key. Pass true to use your operator key, or provide a public key string.
- metadataKey (boolean|string, optional): New metadata key. Pass true to use your operator key, or provide a public key string.
- metadata (string, optional): New metadata for the token, in bytes (hex or base64).
- tokenMemo (string, optional): Short public memo for the token, up to 100 characters.
- autoRenewAccountId (string, optional): Account to automatically pay for renewal.

Examples:
- If the user asks for "my key" \u2192 set the field to \`true\`.
- If the user does not mention the key \u2192 do not set the field.
- If the user provides a key \u2192 set the field to the provided public key string.

If the user provides multiple fields in a single request, 
combine them into **one tool call** with all parameters together.

${usageInstructions}
`;
};
var postProcess6 = (response) => {
  return `Token successfully updated. Transaction ID: ${response.transactionId}`;
};
var updateToken = async (client, context, params) => {
  try {
    const normalisedParams = await HederaParameterNormaliser.normaliseUpdateToken(
      params,
      context,
      client
    );
    const mirrornodeService = getMirrornodeService(context.mirrornodeService, client.ledgerId);
    const userPublicKey = await AccountResolver.getDefaultPublicKey(context, client);
    await checkValidityOfUpdates(normalisedParams, mirrornodeService, userPublicKey);
    const tx = HederaBuilder.updateToken(normalisedParams);
    return await handleTransaction(tx, client, context, postProcess6);
  } catch (error) {
    const desc = "Failed to update token";
    const message = desc + (error instanceof Error ? `: ${error.message}` : "");
    console.error("[update_token_tool]", message);
    return {
      raw: { status: Status6.InvalidTransaction, error: message },
      humanMessage: message
    };
  }
};
var UPDATE_TOKEN_TOOL = "update_token_tool";
var tool6 = (context) => ({
  method: UPDATE_TOKEN_TOOL,
  name: "Update Token",
  description: updateTokenPrompt(context),
  parameters: updateTokenParameters(context),
  execute: updateToken
});
var update_token_default = tool6;

// src/plugins/core-token-plugin/tools/dissociate-token.ts
import { Status as Status7 } from "@hashgraph/sdk";
var dissociateTokenPrompt = (context = {}) => {
  const contextSnippet = PromptGenerator.getContextSnippet(context);
  const sourceAccountDesc = PromptGenerator.getAccountParameterDescription("accountId", context);
  const usageInstructions = PromptGenerator.getParameterUsageInstructions();
  return `
${contextSnippet}

This tool will airdrop a fungible token on Hedera.

Parameters:
- tokenIds (array of strings, required): A list of Hedera token IDs to dissociate from the account. Example: ["0.0.1234", "0.0.5678"]
- ${sourceAccountDesc}, account from which to dissociate the token(s)
- transactionMemo (str, optional): Optional memo for the transaction

Examples:
- Dissociate a single token: { "tokenIds": ["0.0.1234"] }
- Dissociate multiple tokens from a specific account: { "tokenIds": ["0.0.1234", "0.0.5678"], "accountId": "0.0.4321" }

${usageInstructions}
`;
};
var postProcess7 = (response) => {
  return `Token(s) successfully dissociated with transaction id ${response.transactionId.toString()}`;
};
var dissociateToken = async (client, context, params) => {
  try {
    const normalisedParams = await HederaParameterNormaliser.normaliseDissociateTokenParams(
      params,
      context,
      client
    );
    const tx = HederaBuilder.dissociateToken(normalisedParams);
    return await handleTransaction(tx, client, context, postProcess7);
  } catch (error) {
    const desc = "Failed to dissociate token";
    const message = desc + (error instanceof Error ? `: ${error.message}` : "");
    console.error("[dissociate_token_tool]", message);
    return { raw: { status: Status7.InvalidTransaction, error: message }, humanMessage: message };
  }
};
var DISSOCIATE_TOKEN_TOOL = "dissociate_token_tool";
var tool7 = (context) => ({
  method: DISSOCIATE_TOKEN_TOOL,
  name: "Dissociate Token",
  description: dissociateTokenPrompt(context),
  parameters: dissociateTokenParameters(context),
  execute: dissociateToken
});
var dissociate_token_default = tool7;

// src/plugins/core-token-plugin/tools/associate-token.ts
import { Status as Status8 } from "@hashgraph/sdk";
var associateTokenPrompt = (context = {}) => {
  const contextSnippet = PromptGenerator.getContextSnippet(context);
  const usageInstructions = PromptGenerator.getParameterUsageInstructions();
  const accountToAssociate = PromptGenerator.getAnyAddressParameterDescription("accountId", context);
  return `
${contextSnippet}

This tool will associate one or more tokens with a Hedera account.

Parameters:
${accountToAssociate}
- tokenIds (string[], required): Array of token IDs to associate
${usageInstructions}

Example: "Associate tokens 0.0.123 and 0.0.456 to account 0.0.789".
`;
};
var postProcess8 = (response) => {
  return `Tokens successfully associated with transaction id ${response.transactionId.toString()}`;
};
var associateToken = async (client, context, params) => {
  try {
    const normalisedParams = HederaParameterNormaliser.normaliseAssociateTokenParams(
      params,
      context,
      client
    );
    const tx = HederaBuilder.associateToken(normalisedParams);
    const result = await handleTransaction(tx, client, context, postProcess8);
    return result;
  } catch (error) {
    const desc = "Failed to associate token(s)";
    const message = desc + (error instanceof Error ? `: ${error.message}` : "");
    console.error("[associate_token_tool]", message);
    return { raw: { status: Status8.InvalidTransaction, error: message }, humanMessage: message };
  }
};
var ASSOCIATE_TOKEN_TOOL = "associate_token_tool";
var tool8 = (context) => ({
  method: ASSOCIATE_TOKEN_TOOL,
  name: "Associate Token(s)",
  description: associateTokenPrompt(context),
  parameters: associateTokenParameters(context),
  execute: associateToken
});
var associate_token_default = tool8;

// src/plugins/core-token-plugin/index.ts
var coreTokenPlugin = {
  name: "core-token-plugin",
  version: "1.0.0",
  description: "A plugin for the Hedera Token Service",
  tools: (context) => {
    return [
      create_fungible_token_default(context),
      mint_fungible_token_default(context),
      create_non_fungible_token_default(context),
      airdrop_fungible_token_default(context),
      mint_non_fungible_token_default(context),
      update_token_default(context),
      dissociate_token_default(context),
      associate_token_default(context)
    ];
  }
};
var coreTokenPluginToolNames = {
  AIRDROP_FUNGIBLE_TOKEN_TOOL,
  CREATE_FUNGIBLE_TOKEN_TOOL,
  MINT_FUNGIBLE_TOKEN_TOOL,
  CREATE_NON_FUNGIBLE_TOKEN_TOOL,
  MINT_NON_FUNGIBLE_TOKEN_TOOL,
  DISSOCIATE_TOKEN_TOOL,
  ASSOCIATE_TOKEN_TOOL,
  UPDATE_TOKEN_TOOL
};

// src/plugins/core-account-plugin/tools/account/transfer-hbar.ts
import { Status as Status9 } from "@hashgraph/sdk";
var transferHbarPrompt = (context = {}) => {
  const contextSnippet = PromptGenerator.getContextSnippet(context);
  const sourceAccountDesc = PromptGenerator.getAccountParameterDescription(
    "sourceAccountId",
    context
  );
  const usageInstructions = PromptGenerator.getParameterUsageInstructions();
  return `
${contextSnippet}

This tool will transfer HBAR to an account.

Parameters:
- transfers (array of objects, required): List of HBAR transfers. Each object should contain:
  - accountId (string): Recipient account ID
  - amount (number): Amount of HBAR to transfer
- ${sourceAccountDesc}
- transactionMemo (string, optional): Optional memo for the transaction
${usageInstructions}
`;
};
var postProcess9 = (response) => {
  return `HBAR successfully transferred. Transaction ID: ${response.transactionId}`;
};
var transferHbar = async (client, context, params) => {
  try {
    const normalisedParams = HederaParameterNormaliser.normaliseTransferHbar(
      params,
      context,
      client
    );
    const tx = HederaBuilder.transferHbar(normalisedParams);
    const result = await handleTransaction(tx, client, context, postProcess9);
    return result;
  } catch (error) {
    const desc = "Failed to transfer HBAR";
    const message = desc + (error instanceof Error ? `: ${error.message}` : "");
    console.error("[transfer_hbar_tool]", message);
    return { raw: { status: Status9.InvalidTransaction, error: message }, humanMessage: message };
  }
};
var TRANSFER_HBAR_TOOL = "transfer_hbar_tool";
var tool9 = (context) => ({
  method: TRANSFER_HBAR_TOOL,
  name: "Transfer HBAR",
  description: transferHbarPrompt(context),
  parameters: transferHbarParameters(context),
  execute: transferHbar
});
var transfer_hbar_default = tool9;

// src/plugins/core-account-plugin/tools/account/approve-hbar-allowance.ts
var approveHbarAllowancePrompt = (context = {}) => {
  const contextSnippet = PromptGenerator.getContextSnippet(context);
  const ownerAccountDesc = PromptGenerator.getAccountParameterDescription(
    "ownerAccountId",
    context
  );
  const usageInstructions = PromptGenerator.getParameterUsageInstructions();
  return `
${contextSnippet}

This tool approves an HBAR allowance from the owner to the spender.

Parameters:
- ${ownerAccountDesc}
- spenderAccountId (string, required): Spender account ID
- amount (number, required): Amount of HBAR to approve (can be decimal, cannot be negative)
- transactionMemo (string, optional): Optional memo for the transaction
${usageInstructions}
`;
};
var postProcess10 = (response) => {
  return `HBAR allowance approved successfully. Transaction ID: ${response.transactionId}`;
};
var approveHbarAllowance = async (client, context, params) => {
  const normalisedParams = HederaParameterNormaliser.normaliseApproveHbarAllowance(
    params,
    context,
    client
  );
  const tx = HederaBuilder.approveHbarAllowance(normalisedParams);
  const result = await handleTransaction(tx, client, context, postProcess10);
  return result;
};
var APPROVE_HBAR_ALLOWANCE_TOOL = "approve_hbar_allowance_tool";
var tool10 = (context) => ({
  method: APPROVE_HBAR_ALLOWANCE_TOOL,
  name: "Approve HBAR Allowance",
  description: approveHbarAllowancePrompt(context),
  parameters: approveHbarAllowanceParameters(context),
  execute: approveHbarAllowance
});
var approve_hbar_allowance_default = tool10;

// src/plugins/core-account-plugin/tools/account/create-account.ts
import { Status as Status10 } from "@hashgraph/sdk";
var createAccountPrompt = (context = {}) => {
  const contextSnippet = PromptGenerator.getContextSnippet(context);
  const usageInstructions = PromptGenerator.getParameterUsageInstructions();
  return `
${contextSnippet}

This tool will create a new Hedera account with a passed public key. If not passed, the tool will use operators public key.

Parameters:
- publicKey (string, optional): Public key to use for the account. If not provided, the tool will use the operators public key.
- accountMemo (string, optional): Optional memo for the account
- initialBalance (number, optional, default 0): Initial HBAR to fund the account
- maxAutomaticTokenAssociations (number, optional, default -1): -1 means unlimited
${usageInstructions}
`;
};
var postProcess11 = (response) => {
  const accountIdStr = response.accountId ? response.accountId.toString() : "unknown";
  return `Account created successfully.
Transaction ID: ${response.transactionId}
New Account ID: ${accountIdStr}
}`;
};
var createAccount = async (client, context, params) => {
  try {
    const mirrornodeService = getMirrornodeService(context.mirrornodeService, client.ledgerId);
    const normalisedParams = await HederaParameterNormaliser.normaliseCreateAccount(
      params,
      context,
      client,
      mirrornodeService
    );
    const tx = HederaBuilder.createAccount(normalisedParams);
    const result = await handleTransaction(tx, client, context, postProcess11);
    return result;
  } catch (error) {
    const desc = "Failed to create account";
    const message = desc + (error instanceof Error ? `: ${error.message}` : "");
    console.error("[create_account_tool]", message);
    return { raw: { status: Status10.InvalidTransaction, error: message }, humanMessage: message };
  }
};
var CREATE_ACCOUNT_TOOL = "create_account_tool";
var tool11 = (context) => ({
  method: CREATE_ACCOUNT_TOOL,
  name: "Create Account",
  description: createAccountPrompt(context),
  parameters: createAccountParameters(context),
  execute: createAccount
});
var create_account_default = tool11;

// src/plugins/core-account-plugin/tools/account/delete-account.ts
import { Status as Status11 } from "@hashgraph/sdk";
var deleteAccountPrompt = (context = {}) => {
  const contextSnippet = PromptGenerator.getContextSnippet(context);
  const accountDesc = PromptGenerator.getAccountParameterDescription("accountId", context);
  const usageInstructions = PromptGenerator.getParameterUsageInstructions();
  return `
${contextSnippet}

This tool will delete an existing Hedera account. The remaining balance of the account will be transferred to the transferAccountId if provided, otherwise the operator account will be used.

Parameters:
- ${accountDesc}
- accountId (str, required): The account ID to delete
- transferAccountId (str, optional): The account ID to transfer the remaining balance to. If not provided, the operator account will be used.
${usageInstructions}
`;
};
var postProcess12 = (response) => {
  return `Account successfully deleted. Transaction ID: ${response.transactionId}`;
};
var deleteAccount = async (client, context, params) => {
  try {
    const normalisedParams = HederaParameterNormaliser.normaliseDeleteAccount(
      params,
      context,
      client
    );
    let tx = HederaBuilder.deleteAccount(normalisedParams);
    const result = await handleTransaction(tx, client, context, postProcess12);
    return result;
  } catch (error) {
    const desc = "Failed to delete account";
    const message = desc + (error instanceof Error ? `: ${error.message}` : "");
    console.error("[delete_account_tool]", message);
    return { raw: { status: Status11.InvalidTransaction, error: message }, humanMessage: message };
  }
};
var DELETE_ACCOUNT_TOOL = "delete_account_tool";
var tool12 = (context) => ({
  method: DELETE_ACCOUNT_TOOL,
  name: "Delete Account",
  description: deleteAccountPrompt(context),
  parameters: deleteAccountParameters(context),
  execute: deleteAccount
});
var delete_account_default = tool12;

// src/plugins/core-account-plugin/tools/account/update-account.ts
import { Status as Status12 } from "@hashgraph/sdk";
var updateAccountPrompt = (context = {}) => {
  const contextSnippet = PromptGenerator.getContextSnippet(context);
  const accountDesc = PromptGenerator.getAccountParameterDescription("accountId", context);
  const usageInstructions = PromptGenerator.getParameterUsageInstructions();
  return `
${contextSnippet}

This tool will update an existing Hedera account. Only provided fields will be updated.

Parameters:
- ${accountDesc}
- accountId (string, optional) Account ID to update (e.g., 0.0.xxxxx). If not provided, operator account ID will be used
- maxAutomaticTokenAssociations (number, optional)
- stakedAccountId (string, optional)
- accountMemo (string, optional)
- declineStakingReward (boolean, optional)
${usageInstructions}
`;
};
var postProcess13 = (response) => {
  return `Account successfully updated. Transaction ID: ${response.transactionId}`;
};
var updateAccount = async (client, context, params) => {
  try {
    const normalisedParams = HederaParameterNormaliser.normaliseUpdateAccount(
      params,
      context,
      client
    );
    let tx = HederaBuilder.updateAccount(normalisedParams);
    const result = await handleTransaction(tx, client, context, postProcess13);
    return result;
  } catch (error) {
    const desc = "Failed to update account";
    const message = desc + (error instanceof Error ? `: ${error.message}` : "");
    console.error("[update_account_tool]", message);
    return { raw: { status: Status12.InvalidTransaction, error: message }, humanMessage: message };
  }
};
var UPDATE_ACCOUNT_TOOL = "update_account_tool";
var tool13 = (context) => ({
  method: UPDATE_ACCOUNT_TOOL,
  name: "Update Account",
  description: updateAccountPrompt(context),
  parameters: updateAccountParameters(context),
  execute: updateAccount
});
var update_account_default = tool13;

// src/plugins/core-account-plugin/tools/account/sign-schedule-transaction.ts
import { Status as Status13 } from "@hashgraph/sdk";
var signScheduleTransactionPrompt = (context = {}) => {
  const contextSnippet = PromptGenerator.getContextSnippet(context);
  const usageInstructions = PromptGenerator.getParameterUsageInstructions();
  return `
${contextSnippet}

This tool will sign a scheduled transaction and return the transaction ID.

Parameters:
- scheduleId (string, required): The ID of the scheduled transaction to sign
${usageInstructions}
`;
};
var postProcess14 = (response) => {
  return `Transaction successfully signed. Transaction ID: ${response.transactionId}`;
};
var signScheduleTransaction = async (client, context, params) => {
  try {
    const tx = HederaBuilder.signScheduleTransaction(params);
    const result = await handleTransaction(tx, client, context, postProcess14);
    return result;
  } catch (error) {
    const desc = "Failed to sign scheduled transaction";
    const message = desc + (error instanceof Error ? `: ${error.message}` : "");
    console.error("[sign_schedule_transaction_tool]", message);
    return { raw: { status: Status13.InvalidTransaction, error: message }, humanMessage: message };
  }
};
var SIGN_SCHEDULE_TRANSACTION_TOOL = "sign_schedule_transaction_tool";
var tool14 = (context) => ({
  method: SIGN_SCHEDULE_TRANSACTION_TOOL,
  name: "Sign Scheduled Transaction",
  description: signScheduleTransactionPrompt(context),
  parameters: signScheduleTransactionParameters(context),
  execute: signScheduleTransaction
});
var sign_schedule_transaction_default = tool14;

// src/plugins/core-account-plugin/tools/account/schedule-delete.ts
import { Status as Status14 } from "@hashgraph/sdk";
var scheduleDeletePrompt = (context = {}) => {
  const contextSnippet = PromptGenerator.getContextSnippet(context);
  const usageInstructions = PromptGenerator.getParameterUsageInstructions();
  return `
${contextSnippet}

This tool will delete a scheduled transaction (by admin) so it will not execute.

Parameters:
- scheduleId (string, required): The ID of the scheduled transaction to delete
${usageInstructions}
`;
};
var postProcess15 = (response) => {
  return `Scheduled transaction successfully deleted. Transaction ID: ${response.transactionId}`;
};
var scheduleDelete = async (client, context, params) => {
  try {
    const tx = HederaBuilder.deleteScheduleTransaction(params);
    const result = await handleTransaction(tx, client, context, postProcess15);
    return result;
  } catch (error) {
    const desc = "Failed to delete scheduled transaction";
    const message = desc + (error instanceof Error ? `: ${error.message}` : "");
    console.error("[schedule_delete_tool]", message);
    return { raw: { status: Status14.InvalidTransaction, error: message }, humanMessage: message };
  }
};
var SCHEDULE_DELETE_TOOL = "schedule_delete_tool";
var tool15 = (context) => ({
  method: SCHEDULE_DELETE_TOOL,
  name: "Delete Scheduled Transaction",
  description: scheduleDeletePrompt(context),
  parameters: scheduleDeleteTransactionParameters(context),
  execute: scheduleDelete
});
var schedule_delete_default = tool15;

// src/plugins/core-account-plugin/index.ts
var coreAccountPlugin = {
  name: "core-account-plugin",
  version: "1.0.0",
  description: "A plugin for the Hedera Account Service",
  tools: (context) => {
    return [
      transfer_hbar_default(context),
      approve_hbar_allowance_default(context),
      delete_account_default(context),
      update_account_default(context),
      create_account_default(context),
      sign_schedule_transaction_default(context),
      schedule_delete_default(context)
    ];
  }
};
var coreAccountPluginToolNames = {
  TRANSFER_HBAR_TOOL,
  APPROVE_HBAR_ALLOWANCE_TOOL,
  CREATE_ACCOUNT_TOOL,
  DELETE_ACCOUNT_TOOL,
  UPDATE_ACCOUNT_TOOL,
  SIGN_SCHEDULE_TRANSACTION_TOOL,
  SCHEDULE_DELETE_TOOL
};

// src/plugins/core-consensus-plugin/tools/consensus/create-topic.ts
import { Status as Status15 } from "@hashgraph/sdk";
var createTopicPrompt = (_context = {}) => {
  const usageInstructions = PromptGenerator.getParameterUsageInstructions();
  return `
This tool will create a new topic on the Hedera network.

Parameters:
- topicMemo (str, optional): A memo for the topic
- transactionMemo (str, optional): An optional memo to include on the submitted transaction
- isSubmitKey (bool, optional): Whether to set a submit key for the topic. Set to true if user wants to set a submit key, otherwise false
${usageInstructions}
`;
};
var postProcess16 = (response) => {
  return `Topic created successfully with topic id ${response.topicId?.toString()} and transaction id ${response.transactionId.toString()}`;
};
var createTopic = async (client, context, params) => {
  try {
    const mirrornodeService = getMirrornodeService(
      context.mirrornodeService,
      client.ledgerId
    );
    const normalisedParams = await HederaParameterNormaliser.normaliseCreateTopicParams(
      params,
      context,
      client,
      mirrornodeService
    );
    const tx = HederaBuilder.createTopic(normalisedParams);
    const result = await handleTransaction(tx, client, context, postProcess16);
    return result;
  } catch (error) {
    const desc = "Failed to create topic";
    const message = desc + (error instanceof Error ? `: ${error.message}` : "");
    console.error("[create_topic_tool]", message);
    return { raw: { status: Status15.InvalidTransaction, error: message }, humanMessage: message };
  }
};
var CREATE_TOPIC_TOOL = "create_topic_tool";
var tool16 = (context) => ({
  method: CREATE_TOPIC_TOOL,
  name: "Create Topic",
  description: createTopicPrompt(context),
  parameters: createTopicParameters(context),
  execute: createTopic
});
var create_topic_default = tool16;

// src/plugins/core-consensus-plugin/tools/consensus/delete-topic.ts
import { Status as Status16 } from "@hashgraph/sdk";
var deleteTopicPrompt = (_context = {}) => {
  const usageInstructions = PromptGenerator.getParameterUsageInstructions();
  return `
This tool will delete a given Hedera network topic.

Parameters:
- topicId (str, required): id of topic to delete
${usageInstructions}
`;
};
var postProcess17 = (response) => {
  return `Topic with id ${response.topicId?.toString()} deleted successfully. Transaction id ${response.transactionId.toString()}`;
};
var deleteTopic = async (client, context, params) => {
  try {
    const mirrornodeService = getMirrornodeService(
      context.mirrornodeService,
      client.ledgerId
    );
    const normalisedParams = HederaParameterNormaliser.normaliseDeleteTopic(
      params,
      context,
      client,
      mirrornodeService
    );
    const tx = HederaBuilder.deleteTopic(normalisedParams);
    return await handleTransaction(tx, client, context, postProcess17);
  } catch (error) {
    const desc = "Failed to delete the topic";
    const message = desc + (error instanceof Error ? `: ${error.message}` : "");
    console.error("[delete_topic_tool]", message);
    return { raw: { status: Status16.InvalidTransaction, error: message }, humanMessage: message };
  }
};
var DELETE_TOPIC_TOOL = "delete_topic_tool";
var tool17 = (context) => ({
  method: DELETE_TOPIC_TOOL,
  name: "Delete Topic",
  description: deleteTopicPrompt(context),
  parameters: deleteTopicParameters(context),
  execute: deleteTopic
});
var delete_topic_default = tool17;

// src/plugins/core-consensus-plugin/tools/consensus/submit-topic-message.ts
import { Status as Status17 } from "@hashgraph/sdk";
var submitTopicMessagePrompt = (_context = {}) => {
  const usageInstructions = PromptGenerator.getParameterUsageInstructions();
  return `
This tool will submit a message to a topic on the Hedera network.

Parameters:
- topicId (str, required): The ID of the topic to submit the message to
- message (str, required): The message to submit to the topic
- transactionMemo (str, optional): An optional memo to include on the transaction
${usageInstructions}
`;
};
var postProcess18 = (response) => {
  return `Message submitted successfully with transaction id ${response.transactionId.toString()}`;
};
var submitTopicMessage = async (client, context, params) => {
  try {
    const tx = HederaBuilder.submitTopicMessage(params);
    const result = await handleTransaction(tx, client, context, postProcess18);
    return { ...result, topicId: params.topicId };
  } catch (error) {
    const desc = "Failed to submit message to topic";
    const message = desc + (error instanceof Error ? `: ${error.message}` : "");
    console.error("[submit_topic_message_tool]", message);
    return { raw: { status: Status17.InvalidTransaction, error: message }, humanMessage: message };
  }
};
var SUBMIT_TOPIC_MESSAGE_TOOL = "submit_topic_message_tool";
var tool18 = (context) => ({
  method: SUBMIT_TOPIC_MESSAGE_TOOL,
  name: "Submit Topic Message",
  description: submitTopicMessagePrompt(context),
  parameters: submitTopicMessageParameters(context),
  execute: submitTopicMessage
});
var submit_topic_message_default = tool18;

// src/plugins/core-consensus-plugin/tools/consensus/update-topic.ts
import { PublicKey as PublicKey6, Status as Status18 } from "@hashgraph/sdk";
var checkValidityOfUpdates2 = async (params, mirrornode, userPublicKey) => {
  const topicDetails = await mirrornode.getTopicInfo(params.topicId.toString());
  if (!topicDetails) {
    throw new Error("Topic not found");
  }
  if (topicDetails.admin_key === void 0) {
    throw new Error("Topic does not have an admin key. It cannot be updated.");
  }
  if (topicDetails.admin_key.key !== userPublicKey.toStringRaw()) {
    console.error(
      `topicDetails.admin_key.key: ${topicDetails.admin_key?.key} vs userPublicKey: ${userPublicKey.toStringRaw()}`
    );
    throw new Error(
      "You do not have permission to update this topic. The adminKey does not match your public key."
    );
  }
  const keyChecks = {
    adminKey: "admin_key",
    submitKey: "submit_key"
  };
  for (const [paramKey, topicField] of Object.entries(keyChecks)) {
    const userValue = params[paramKey];
    const topicKey = topicDetails[topicField];
    if (userValue instanceof PublicKey6 && !topicKey) {
      throw new Error(`Cannot update ${paramKey}: topic was created without a ${paramKey}`);
    }
  }
};
var updateTopicPrompt = (context = {}) => {
  const contextSnippet = PromptGenerator.getContextSnippet(context);
  const topicDesc = PromptGenerator.getAnyAddressParameterDescription("topicId", context);
  const usageInstructions = PromptGenerator.getParameterUsageInstructions();
  return `
${contextSnippet}
This tool will update an existing Hedera Consensus Topic. Only the fields provided will be updated.
Key fields (adminKey, submitKey) must contain **Hedera-compatible public keys (as strings) or boolean (true/false)**. You can provide these in one of three ways:
1. **Boolean true** \u2013 Set this field to use user/operator key. Injecting of the key will be handled automatically.
2. **Not provided** \u2013 The field will not be updated.
3. **String** \u2013 Provide a Hedera-compatible public key string to set a field explicitly.

Parameters:
- ${topicDesc}
- topicMemo (string, optional): New memo for the topic.
- adminKey (boolean|string, optional): New admin key. Pass true to use your operator key, or provide a public key string.
- submitKey (boolean|string, optional): New submit key. Pass true to use your operator key, or provide a public key string.
- autoRenewAccountId (string, optional): Account to automatically pay for renewal.
- autoRenewPeriod (number, optional): Auto renew period in seconds.
- expirationTime (string|Date, optional): New expiration time for the topic (ISO string or Date).
Examples:
- If the user asks for "my key" \u2192 set the field to \`true\`.
- If the user does not mention the key \u2192 do not set the field.
- If the user provides a key \u2192 set the field to the provided public key string.

If the user provides multiple fields in a single request, 
combine them into **one tool call** with all parameters together.
${usageInstructions}
`;
};
var postProcess19 = (response) => {
  return `Topic successfully updated. Transaction ID: ${response.transactionId}`;
};
var updateTopic = async (client, context, params) => {
  try {
    const normalisedParams = await HederaParameterNormaliser.normaliseUpdateTopic(
      params,
      context,
      client
    );
    const mirrornodeService = getMirrornodeService(context.mirrornodeService, client.ledgerId);
    const userPublicKey = await AccountResolver.getDefaultPublicKey(context, client);
    await checkValidityOfUpdates2(normalisedParams, mirrornodeService, userPublicKey);
    const tx = HederaBuilder.updateTopic(normalisedParams);
    return await handleTransaction(tx, client, context, postProcess19);
  } catch (error) {
    const desc = "Failed to update topic";
    const message = desc + (error instanceof Error ? `: ${error.message}` : "");
    console.error("[update_topic_tool]", message);
    return {
      raw: { status: Status18.InvalidTransaction, error: message },
      humanMessage: message
    };
  }
};
var UPDATE_TOPIC_TOOL = "update_topic_tool";
var tool19 = (context) => ({
  method: UPDATE_TOPIC_TOOL,
  name: "Update Topic",
  description: updateTopicPrompt(context),
  parameters: updateTopicParameters(context),
  execute: updateTopic
});
var update_topic_default = tool19;

// src/plugins/core-consensus-plugin/index.ts
var coreConsensusPlugin = {
  name: "core-consensus-plugin",
  version: "1.0.0",
  description: "A plugin for the Hedera Consensus Service",
  tools: (context) => {
    return [
      create_topic_default(context),
      submit_topic_message_default(context),
      delete_topic_default(context),
      update_topic_default(context)
    ];
  }
};
var coreConsensusPluginToolNames = {
  CREATE_TOPIC_TOOL,
  SUBMIT_TOPIC_MESSAGE_TOOL,
  DELETE_TOPIC_TOOL,
  UPDATE_TOPIC_TOOL
};

// src/shared/hedera-utils/hbar-conversion-utils.ts
function toHBar(tinyBars) {
  return tinyBars.div(1e8);
}

// src/plugins/core-queries-plugin/tools/queries/get-hbar-balance-query.ts
var getHbarBalanceQueryPrompt = (context = {}) => {
  const contextSnippet = PromptGenerator.getContextSnippet(context);
  const accountDesc = PromptGenerator.getAccountParameterDescription("accountId", context);
  const usageInstructions = PromptGenerator.getParameterUsageInstructions();
  return `
${contextSnippet}

This tool will return the HBAR balance for a given Hedera account.

Parameters:
- ${accountDesc}
${usageInstructions}
`;
};
var postProcess20 = (hbarBalance, accountId) => {
  return `Account ${accountId} has a balance of ${hbarBalance} HBAR`;
};
var getHbarBalanceQuery = async (client, context, params) => {
  try {
    const normalisedParams = HederaParameterNormaliser.normaliseHbarBalanceParams(
      params,
      context,
      client
    );
    const mirrornodeService = getMirrornodeService(context.mirrornodeService, client.ledgerId);
    const balance = await mirrornodeService.getAccountHBarBalance(
      normalisedParams.accountId
    );
    return {
      raw: { accountId: normalisedParams.accountId, hbarBalance: toHBar(balance).toString() },
      humanMessage: postProcess20(toHBar(balance).toString(), normalisedParams.accountId)
    };
  } catch (error) {
    const desc = "Failed to get HBAR balance";
    const message = desc + (error instanceof Error ? `: ${error.message}` : "");
    console.error("[get_hbar_balance_query_tool]", message);
    return { raw: { error: message }, humanMessage: message };
  }
};
var GET_HBAR_BALANCE_QUERY_TOOL = "get_hbar_balance_query_tool";
var tool20 = (context) => ({
  method: GET_HBAR_BALANCE_QUERY_TOOL,
  name: "Get HBAR Balance",
  description: getHbarBalanceQueryPrompt(context),
  parameters: accountBalanceQueryParameters(context),
  execute: getHbarBalanceQuery
});
var get_hbar_balance_query_default = tool20;

// src/plugins/core-queries-plugin/tools/queries/get-account-query.ts
import { Status as Status19 } from "@hashgraph/sdk";
var getAccountQueryPrompt = (context = {}) => {
  const contextSnippet = PromptGenerator.getContextSnippet(context);
  const usageInstructions = PromptGenerator.getParameterUsageInstructions();
  return `
${contextSnippet}

This tool will return the account information for a given Hedera account.

Parameters:
- accountId (str, required): The account ID to query
${usageInstructions}
`;
};
var postProcess21 = (account) => {
  return `Details for ${account.accountId}
Balance: ${account.balance.balance.toString()}
Public Key: ${account.accountPublicKey},
EVM address: ${account.evmAddress},
`;
};
var getAccountQuery = async (client, context, params) => {
  try {
    const mirrornodeService = getMirrornodeService(context.mirrornodeService, client.ledgerId);
    const account = await mirrornodeService.getAccount(params.accountId);
    return {
      raw: { accountId: params.accountId, account },
      humanMessage: postProcess21(account)
    };
  } catch (error) {
    const desc = "Failed to get account query";
    const message = desc + (error instanceof Error ? `: ${error.message}` : "");
    console.error("[get_account_query_tool]", message);
    return { raw: { status: Status19.InvalidTransaction, error: message }, humanMessage: message };
  }
};
var GET_ACCOUNT_QUERY_TOOL = "get_account_query_tool";
var tool21 = (context) => ({
  method: GET_ACCOUNT_QUERY_TOOL,
  name: "Get Account Query",
  description: getAccountQueryPrompt(context),
  parameters: accountQueryParameters(context),
  execute: getAccountQuery
});
var get_account_query_default = tool21;

// src/plugins/core-queries-plugin/tools/queries/get-account-token-balances-query.ts
var getAccountTokenBalancesQueryPrompt = (context = {}) => {
  const contextSnippet = PromptGenerator.getContextSnippet(context);
  const accountDesc = PromptGenerator.getAccountParameterDescription("accountId", context);
  const usageInstructions = PromptGenerator.getParameterUsageInstructions();
  return `
${contextSnippet}

This tool will return the token balances for a given Hedera account.

Parameters:
- ${accountDesc}
- tokenId (str, optional): The token ID to query for. If not provided, all token balances will be returned
${usageInstructions}
`;
};
var postProcess22 = (tokenBalances, accountId) => {
  const balancesText = tokenBalances.tokens.map(
    (token) => `  Token: ${token.token_id}, Balance: ${token.balance}, Decimals: ${token.decimals}`
  ).join("\n");
  return `Details for ${accountId}
--- Token Balances ---
${balancesText}`;
};
var getAccountTokenBalancesQuery = async (client, context, params) => {
  try {
    const normalisedParams = HederaParameterNormaliser.normaliseAccountTokenBalancesParams(
      params,
      context,
      client
    );
    const mirrornodeService = getMirrornodeService(context.mirrornodeService, client.ledgerId);
    const tokenBalances = await mirrornodeService.getAccountTokenBalances(
      normalisedParams.accountId,
      normalisedParams.tokenId
    );
    return {
      raw: { accountId: normalisedParams.accountId, tokenBalances },
      humanMessage: postProcess22(tokenBalances, normalisedParams.accountId)
    };
  } catch (error) {
    const desc = "Failed to get account token balances";
    const message = desc + (error instanceof Error ? `: ${error.message}` : "");
    console.error("[get_account_token_balances_query_tool]", message);
    return { raw: { error: message }, humanMessage: message };
  }
};
var GET_ACCOUNT_TOKEN_BALANCES_QUERY_TOOL = "get_account_token_balances_query_tool";
var tool22 = (context) => ({
  method: GET_ACCOUNT_TOKEN_BALANCES_QUERY_TOOL,
  name: "Get Account Token Balances",
  description: getAccountTokenBalancesQueryPrompt(context),
  parameters: accountTokenBalancesQueryParameters(context),
  execute: getAccountTokenBalancesQuery
});
var get_account_token_balances_query_default = tool22;

// src/plugins/core-queries-plugin/tools/queries/get-topic-messages-query.ts
var getTopicMessagesQueryPrompt = (context = {}) => {
  const contextSnippet = PromptGenerator.getContextSnippet(context);
  const usageInstructions = PromptGenerator.getParameterUsageInstructions();
  return `
${contextSnippet}

This tool will return the messages for a given Hedera topic.

Parameters:
- topicId (str, required): The topic ID to query
- startTime (datetime, optional): The start datetime to query. If set, the messages will be returned after this datetime
- endTime (datetime, optional): The end datetime to query. If set, the messages will be returned before this datetime
- limit (int, optional): The limit of messages to query. If set, the number of messages to return
${usageInstructions}
`;
};
var postProcess23 = (messages, topicId) => {
  const messagesText = messages.map(
    (message) => `${Buffer.from(message.message, "base64").toString("utf-8")} - posted at: ${message.consensus_timestamp}
`
  );
  return `Messages for topic ${topicId}:
  --- Messages ---
  ${messagesText}
  `;
};
var getTopicMessagesQueryParams = (params) => {
  return {
    topicId: params.topicId,
    lowerTimestamp: params.startTime ? `${Math.floor(new Date(params.startTime).getTime() / 1e3)}.000000000` : "",
    upperTimestamp: params.endTime ? `${Math.floor(new Date(params.endTime).getTime() / 1e3)}.000000000` : "",
    limit: params.limit || 100
  };
};
var convertMessagesFromBase64ToString = (messages) => {
  return messages.map((message) => {
    return {
      ...message,
      message: Buffer.from(message.message, "base64").toString("utf-8")
    };
  });
};
var getTopicMessagesQuery = async (client, context, params) => {
  try {
    const mirrornodeService = getMirrornodeService(context.mirrornodeService, client.ledgerId);
    const messages = await mirrornodeService.getTopicMessages(getTopicMessagesQueryParams(params));
    return {
      raw: {
        topicId: messages.topicId,
        messages: convertMessagesFromBase64ToString(messages.messages)
      },
      humanMessage: postProcess23(messages.messages, params.topicId)
    };
  } catch (error) {
    const desc = "Failed to get topic messages";
    const message = desc + (error instanceof Error ? `: ${error.message}` : "");
    console.error("[get_topic_messages_query_tool]", message);
    return { raw: { error: message }, humanMessage: message };
  }
};
var GET_TOPIC_MESSAGES_QUERY_TOOL = "get_topic_messages_query_tool";
var tool23 = (context) => ({
  method: GET_TOPIC_MESSAGES_QUERY_TOOL,
  name: "Get Topic Messages",
  description: getTopicMessagesQueryPrompt(context),
  parameters: topicMessagesQueryParameters(context),
  execute: getTopicMessagesQuery
});
var get_topic_messages_query_default = tool23;

// src/plugins/core-queries-plugin/tools/queries/get-token-info-query.ts
var getTokenInfoQueryPrompt = (context = {}) => {
  const contextSnippet = PromptGenerator.getContextSnippet(context);
  const usageInstructions = PromptGenerator.getParameterUsageInstructions();
  return `
${contextSnippet}

This tool will return the information for a given Hedera token.

Parameters:
- tokenId (str): The token ID to query for.
${usageInstructions}
`;
};
var postProcess24 = (tokenInfo) => {
  const formatSupply = (supply) => {
    if (!supply) return "N/A";
    const decimals = Number(tokenInfo.decimals || "0");
    const amount = Number(supply);
    if (isNaN(amount)) return supply;
    return (amount / 10 ** decimals).toLocaleString();
  };
  const formatKey = (key) => {
    if (!key) return "Not Set";
    return key._type ? `${key.key}` : "Present";
  };
  const supplyType = tokenInfo.supply_type === "INFINITE" ? "Infinite" : tokenInfo.max_supply || "Finite";
  const freezeStatus = tokenInfo.freeze_default ? "Frozen" : "Active";
  return `Here are the details for token **${tokenInfo.token_id}**:

- **Token Name**: ${tokenInfo.name}
- **Token Symbol**: ${tokenInfo.symbol}
- **Token Type**: ${tokenInfo.type || "N/A"}
- **Decimals**: ${tokenInfo.decimals}
- **Max Supply**: ${formatSupply(tokenInfo.max_supply)}
- **Current Supply**: ${formatSupply(tokenInfo.total_supply)}
- **Supply Type**: ${supplyType}
- **Treasury Account ID**: ${tokenInfo.treasury_account_id || "N/A"}
- **Status (Deleted/Active)**: ${tokenInfo.deleted ? "Deleted" : "Active"}
- **Status (Frozen/Active)**: ${freezeStatus}

**Keys**:
- Admin Key: ${formatKey(tokenInfo.admin_key)}
- Supply Key: ${formatKey(tokenInfo.supply_key)}
- Wipe Key: ${formatKey(tokenInfo.wipe_key)}
- KYC Key: ${formatKey(tokenInfo.kyc_key)}
- Freeze Key: ${formatKey(tokenInfo.freeze_key)}
- Fee Schedule Key: ${formatKey(tokenInfo.fee_schedule_key)}
- Pause Key: ${formatKey(tokenInfo.pause_key)}
- Metadata Key: ${formatKey(tokenInfo.metadata_key)}

${tokenInfo.memo ? `**Memo**: ${tokenInfo.memo}` : ""}
`;
};
var getTokenInfoQuery = async (client, context, params) => {
  try {
    const mirrornodeService = getMirrornodeService(context.mirrornodeService, client.ledgerId);
    const tokenInfo = {
      ...await mirrornodeService.getTokenInfo(params.tokenId),
      token_id: params.tokenId
    };
    return {
      raw: { tokenId: params.tokenId, tokenInfo },
      humanMessage: postProcess24(tokenInfo)
    };
  } catch (error) {
    const desc = "Failed to get token info";
    const message = desc + (error instanceof Error ? `: ${error.message}` : "");
    console.error("[get_token_info_query_tool]", message);
    return { raw: { error: message }, humanMessage: message };
  }
};
var GET_TOKEN_INFO_QUERY_TOOL = "get_token_info_query_tool";
var tool24 = (context) => ({
  method: GET_TOKEN_INFO_QUERY_TOOL,
  name: "Get Token Info",
  description: getTokenInfoQueryPrompt(context),
  parameters: tokenInfoQueryParameters(context),
  execute: getTokenInfoQuery
});
var get_token_info_query_default = tool24;

// src/plugins/core-queries-plugin/index.ts
var coreQueriesPlugin = {
  name: "core-queries-plugin",
  version: "1.0.0",
  description: "A plugin for the Hedera Queries Service (DEPRECATED)",
  tools: (context) => {
    return [
      get_hbar_balance_query_default(context),
      get_account_query_default(context),
      get_account_token_balances_query_default(context),
      get_topic_messages_query_default(context),
      get_token_info_query_default(context)
    ];
  }
};
var coreQueriesPluginToolNames = {
  GET_HBAR_BALANCE_QUERY_TOOL,
  GET_ACCOUNT_QUERY_TOOL,
  GET_ACCOUNT_TOKEN_BALANCES_QUERY_TOOL,
  GET_TOPIC_MESSAGES_QUERY_TOOL,
  GET_TOKEN_INFO_QUERY_TOOL
};

// src/shared/parameter-schemas/core-misc.zod.ts
import { z as z7 } from "zod";
var exchangeRateQueryParameters = (_context) => z7.object({
  timestamp: z7.string().describe("Historical timestamp to query (seconds or nanos since epoch)").optional()
});

// src/plugins/core-misc-query-plugin/tools/queries/get-exchange-rate-query.ts
var getExchangeRatePrompt = (context = {}) => {
  const contextSnippet = PromptGenerator.getContextSnippet(context);
  const usageInstructions = PromptGenerator.getParameterUsageInstructions();
  return `
${contextSnippet}

This tool returns the Hedera network HBAR exchange rate from the Mirror Node.

Parameters:
- timestamp (str, optional): Historical timestamp to query. Pass seconds or nanos since epoch (e.g., 1726000000.123456789). If omitted, returns the latest rate.
${usageInstructions}
`;
};
var calculateUsdPerHBAR = (cent_equivalent, hbar_equivalent) => {
  return cent_equivalent / 100 / hbar_equivalent;
};
var postProcess25 = (rates) => {
  const { current_rate, next_rate, timestamp } = rates;
  const usdPerHBAR = calculateUsdPerHBAR(
    current_rate.cent_equivalent,
    current_rate.hbar_equivalent
  );
  const nextUsdPerHBAR = calculateUsdPerHBAR(next_rate.cent_equivalent, next_rate.hbar_equivalent);
  return `
  Details for timestamp: ${timestamp}
  
  Current exchange rate: ${usdPerHBAR}
  Expires at ${new Date(current_rate.expiration_time * 1e3).toISOString()})
  
  Next exchange rate: ${nextUsdPerHBAR}
  Expires at ${new Date(next_rate.expiration_time * 1e3).toISOString()})`;
};
var getExchangeRateQuery = async (client, context, params) => {
  try {
    const mirrornodeService = getMirrornodeService(context.mirrornodeService, client.ledgerId);
    const rates = await mirrornodeService.getExchangeRate(params.timestamp);
    return {
      raw: rates,
      humanMessage: postProcess25(rates)
    };
  } catch (error) {
    console.error("[GetExchangeRate] Error getting exchange rate", error);
    const message = error instanceof Error ? error.message : "Failed to get exchange rate";
    return {
      raw: { error: message },
      humanMessage: message
    };
  }
};
var GET_EXCHANGE_RATE_TOOL = "get_exchange_rate_tool";
var tool25 = (context) => ({
  method: GET_EXCHANGE_RATE_TOOL,
  name: "Get Exchange Rate",
  description: getExchangeRatePrompt(context),
  parameters: exchangeRateQueryParameters(context),
  execute: getExchangeRateQuery
});
var get_exchange_rate_query_default = tool25;

// src/plugins/core-misc-query-plugin/index.ts
var coreMiscQueriesPlugin = {
  name: "core-misc-queries-plugin",
  version: "1.0.0",
  description: "A plugin for Hedera Misc Queries",
  tools: (context) => {
    return [get_exchange_rate_query_default(context)];
  }
};
var coreMiscQueriesPluginsToolNames = {
  GET_EXCHANGE_RATE_TOOL
};

// src/plugins/core-evm-plugin/tools/erc20/create-erc20.ts
import { Status as Status20, TransactionRecordQuery } from "@hashgraph/sdk";

// src/shared/constants/contracts.ts
import { LedgerId as LedgerId2 } from "@hashgraph/sdk";
var TESTNET_ERC20_FACTORY_ADDRESS = "0.0.6471814";
var TESTNET_ERC721_FACTORY_ADDRESS = "0.0.6510666";
var ERC20_FACTORY_ADDRESSES = /* @__PURE__ */ new Map([
  [LedgerId2.TESTNET.toString(), TESTNET_ERC20_FACTORY_ADDRESS]
  // Current testnet address
]);
var ERC721_FACTORY_ADDRESSES = /* @__PURE__ */ new Map([
  [LedgerId2.TESTNET.toString(), TESTNET_ERC721_FACTORY_ADDRESS]
  // Current testnet address
]);
var ERC20_FACTORY_ABI = [
  "function deployToken(string memory name_, string memory symbol_, uint8 decimals_, uint256 initialSupply_) external returns (address)"
];
var ERC721_FACTORY_ABI = [
  "function deployToken(string memory name_, string memory symbol_, string memory baseURI_) external returns (address)"
];
var ERC20_TRANSFER_FUNCTION_NAME = "transfer";
var ERC20_TRANSFER_FUNCTION_ABI = [
  "function transfer(address to, uint256 amount) external returns (bool)"
];
var ERC721_TRANSFER_FUNCTION_NAME = "transferFrom";
var ERC721_TRANSFER_FUNCTION_ABI = [
  "function transferFrom(address from, address to, uint256 tokenId) external returns (bool)"
];
var ERC721_MINT_FUNCTION_NAME = "safeMint";
var ERC721_MINT_FUNCTION_ABI = ["function safeMint(address to) external returns (bool)"];
function getERC20FactoryAddress(ledgerId) {
  const address = ERC20_FACTORY_ADDRESSES.get(ledgerId.toString());
  if (!address) {
    throw new Error(`Network type ${ledgerId} not supported for ERC20 factory`);
  }
  return address;
}
function getERC721FactoryAddress(ledgerId) {
  const address = ERC721_FACTORY_ADDRESSES.get(ledgerId.toString());
  if (!address) {
    throw new Error(`Network type ${ledgerId} not supported for ERC721 factory`);
  }
  return address;
}

// src/plugins/core-evm-plugin/tools/erc20/create-erc20.ts
var createERC20Prompt = (context = {}) => {
  const contextSnippet = PromptGenerator.getContextSnippet(context);
  const usageInstructions = PromptGenerator.getParameterUsageInstructions();
  return `
${contextSnippet}

This tool creates an ERC20 token on Hedera by calling the BaseERC20Factory contract.

Parameters:
- tokenName (str, required): The name of the token
- tokenSymbol (str, required): The symbol of the token
- decimals (int, optional): The number of decimals the token supports. Defaults to 18
- initialSupply (int, optional): The initial supply of the token. Defaults to 0
${usageInstructions}
`;
};
var getERC20Address = async (client, executeStrategyResult) => {
  const record = await new TransactionRecordQuery().setTransactionId(executeStrategyResult.raw.transactionId).execute(client);
  return "0x" + record.contractFunctionResult?.getAddress(0);
};
var createERC20 = async (client, context, params) => {
  try {
    const factoryContractAddress = getERC20FactoryAddress(client.ledgerId);
    const normalisedParams = HederaParameterNormaliser.normaliseCreateERC20Params(
      params,
      factoryContractAddress,
      ERC20_FACTORY_ABI,
      "deployToken",
      context
    );
    const tx = HederaBuilder.executeTransaction(normalisedParams);
    const result = await handleTransaction(tx, client, context);
    if (context.mode == "autonomous" /* AUTONOMOUS */) {
      const erc20Address = await getERC20Address(client, result);
      return {
        ...result,
        erc20Address: erc20Address?.toString(),
        humanMessage: `ERC20 token created successfully at address ${erc20Address?.toString()}`
      };
    }
    return result;
  } catch (error) {
    const desc = "Failed to create ERC20 token";
    const message = desc + (error instanceof Error ? `: ${error.message}` : "");
    console.error("[create_erc20_tool]", message);
    return { raw: { status: Status20.InvalidTransaction, error: message }, humanMessage: message };
  }
};
var CREATE_ERC20_TOOL = "create_erc20_tool";
var tool26 = (context) => ({
  method: CREATE_ERC20_TOOL,
  name: "Create ERC20 Token",
  description: createERC20Prompt(context),
  parameters: createERC20Parameters(context),
  execute: createERC20
});
var create_erc20_default = tool26;

// src/plugins/core-evm-plugin/tools/erc20/transfer-erc20.ts
import { Status as Status21 } from "@hashgraph/sdk";
var transferERC20Prompt = (context = {}) => {
  const contextSnippet = PromptGenerator.getContextSnippet(context);
  const usageInstructions = PromptGenerator.getParameterUsageInstructions();
  return `
${contextSnippet}

This tool will transfer a given amount of an existing ERC20 token on Hedera.

Parameters:
- contractId (str, required): The id of the ERC20 contract. This can be the EVM address or the Hedera account id.
- recipientAddress (str, required): The EVM or Hedera address to which the tokens will be transferred. This can be the EVM address or the Hedera account id.
- amount (number, required): The amount to be transferred
${usageInstructions}

Example: "Transfer 1 ERC20 token 0.0.6473135 to 0xd94dc7f82f103757f715514e4a37186be6e4580b" means transferring the amount of 1 of the ERC20 token with contract id 0.0.6473135 to the 0xd94dc7f82f103757f715514e4a37186be6e4580b EVM address.
Example: "Transfer 1 ERC20 token 0xd94dc7f82f103757f715514e4a37186be6e4580b to 0.0.6473135" means transferring the amount of 1 of the ERC20 token with contract id 0xd94dc7f82f103757f715514e4a37186be6e4580b to the 0.0.6473135 Hedera account id.
`;
};
var transferERC20 = async (client, context, params) => {
  const mirrorNode = getMirrornodeService(context.mirrornodeService, client.ledgerId);
  try {
    const normalisedParams = await HederaParameterNormaliser.normaliseTransferERC20Params(
      params,
      ERC20_TRANSFER_FUNCTION_ABI,
      ERC20_TRANSFER_FUNCTION_NAME,
      context,
      mirrorNode
    );
    const tx = HederaBuilder.executeTransaction(normalisedParams);
    const result = await handleTransaction(tx, client, context);
    return result;
  } catch (error) {
    const desc = "Failed to transfer ERC20";
    const message = desc + (error instanceof Error ? `: ${error.message}` : "");
    console.error("[transfer_erc20_tool]", message);
    return { raw: { status: Status21.InvalidTransaction, error: message }, humanMessage: message };
  }
};
var TRANSFER_ERC20_TOOL = "transfer_erc20_tool";
var tool27 = (context) => ({
  method: TRANSFER_ERC20_TOOL,
  name: "Transfer ERC20",
  description: transferERC20Prompt(context),
  parameters: transferERC20Parameters(context),
  execute: transferERC20
});
var transfer_erc20_default = tool27;

// src/plugins/core-evm-plugin/tools/erc721/transfer-erc721.ts
import { Status as Status22 } from "@hashgraph/sdk";
var transferERC721Prompt = (context = {}) => {
  const contextSnippet = PromptGenerator.getContextSnippet(context);
  const fromAddressDesc = PromptGenerator.getAnyAddressParameterDescription("fromAddress", context);
  const usageInstructions = PromptGenerator.getParameterUsageInstructions();
  return `
${contextSnippet}

This tool will transfer an existing ERC721 token on Hedera.

Parameters:
- contractId (str, required): The id of the ERC721 contract
- ${fromAddressDesc}
- toAddress (str, required): The address to which the token will be transferred. This can be the EVM address or the Hedera account id.
- tokenId (number, required): The ID of the transfered token
${usageInstructions}

Example: "Transfer ERC721 token 0.0.6486793 with id 0 from 0xd94dc7f82f103757f715514e4a37186be6e4580b to 0xd94dc7f82f103757f715514e4a37186be6e4580b" means transfering the ERC721 token (identified by 0) with contract id 0.0.6486793 from the 0xd94dc7f82f103757f715514e4a37186be6e4580b EVM address to the 0xd94dc7f82f103757f715514e4a37186be6e4580b EVM address.
Example: "Transfer ERC721 token 0.0.6486793 with id 0 from 0.0.6486793 to 0xd94dc7f82f103757f715514e4a37186be6e4580b" means transfering the ERC721 token (identified by 0) with contract id 0.0.6486793 from the 0.0.6486793 Hedera account id to the 0xd94dc7f82f103757f715514e4a37186be6e4580b EVM address.
`;
};
var transferERC721 = async (client, context, params) => {
  try {
    const mirrorNode = getMirrornodeService(context.mirrornodeService, client.ledgerId);
    const normalisedParams = await HederaParameterNormaliser.normaliseTransferERC721Params(
      params,
      ERC721_TRANSFER_FUNCTION_ABI,
      ERC721_TRANSFER_FUNCTION_NAME,
      context,
      mirrorNode,
      client
    );
    const tx = HederaBuilder.executeTransaction(normalisedParams);
    const result = await handleTransaction(tx, client, context);
    return result;
  } catch (error) {
    const desc = "Failed to transfer ERC721";
    const message = desc + (error instanceof Error ? `: ${error.message}` : "");
    console.error("[transfer_erc721_tool]", message);
    return { raw: { status: Status22.InvalidTransaction, error: message }, humanMessage: message };
  }
};
var TRANSFER_ERC721_TOOL = "transfer_erc721_tool";
var tool28 = (context) => ({
  method: TRANSFER_ERC721_TOOL,
  name: "Transfer ERC721",
  description: transferERC721Prompt(context),
  parameters: transferERC721Parameters(context),
  execute: transferERC721
});
var transfer_erc721_default = tool28;

// src/plugins/core-evm-plugin/tools/erc721/mint-erc721.ts
import { Status as Status23 } from "@hashgraph/sdk";
var mintERC721Prompt = (context = {}) => {
  const contextSnippet = PromptGenerator.getContextSnippet(context);
  const usageInstructions = PromptGenerator.getParameterUsageInstructions();
  const toAddressDesc = PromptGenerator.getAnyAddressParameterDescription("toAddress", context);
  return `
${contextSnippet}

This tool will mint a new ERC721 token on Hedera.

Parameters:
- contractId (str, required): The id of the ERC721 contract
- ${toAddressDesc}
${usageInstructions}

Example: "Mint ERC721 token 0.0.6486793 to 0xd94dc7f82f103757f715514e4a37186be6e4580b" means minting the ERC721 token with contract id 0.0.6486793 to the 0xd94dc7f82f103757f715514e4a37186be6e4580b EVM address.
Example: "Mint ERC721 token 0.0.6486793 to 0.0.6486793" means minting the ERC721 token with contract id 0.0.6486793 to the 0.0.6486793 Hedera account id.
`;
};
var mintERC721 = async (client, context, params) => {
  try {
    const mirrorNode = getMirrornodeService(context.mirrornodeService, client.ledgerId);
    const normalisedParams = await HederaParameterNormaliser.normaliseMintERC721Params(
      params,
      ERC721_MINT_FUNCTION_ABI,
      ERC721_MINT_FUNCTION_NAME,
      context,
      mirrorNode,
      client
    );
    const tx = HederaBuilder.executeTransaction(normalisedParams);
    const result = await handleTransaction(tx, client, context);
    return result;
  } catch (error) {
    const desc = "Failed to mint ERC721";
    const message = desc + (error instanceof Error ? `: ${error.message}` : "");
    console.error("[mint_erc721_tool]", message);
    return { raw: { status: Status23.InvalidTransaction, error: message }, humanMessage: message };
  }
};
var MINT_ERC721_TOOL = "mint_erc721_tool";
var tool29 = (context) => ({
  method: MINT_ERC721_TOOL,
  name: "Mint ERC721",
  description: mintERC721Prompt(context),
  parameters: mintERC721Parameters(context),
  execute: mintERC721
});
var mint_erc721_default = tool29;

// src/plugins/core-evm-plugin/tools/erc721/create-erc721.ts
import { Status as Status24, TransactionRecordQuery as TransactionRecordQuery2 } from "@hashgraph/sdk";
var createERC721Prompt = (context = {}) => {
  const contextSnippet = PromptGenerator.getContextSnippet(context);
  const usageInstructions = PromptGenerator.getParameterUsageInstructions();
  return `
${contextSnippet}

This tool creates an ERC721 token on Hedera by calling the BaseERC721Factory contract.

Parameters:
- tokenName (str, required): The name of the token
- tokenSymbol (str, required): The symbol of the token
- baseURI (str, required): The base URI for token metadata.
${usageInstructions}

The contractId returned by the tool is the address of the ERC721 Factory contract, the address of the ERC721 token is the erc721Address returned by the tool.
`;
};
var getERC721Address = async (client, executeStrategyResult) => {
  const record = await new TransactionRecordQuery2().setTransactionId(executeStrategyResult.raw.transactionId).execute(client);
  return "0x" + record.contractFunctionResult?.getAddress(0);
};
var createERC721 = async (client, context, params) => {
  try {
    const factoryContractAddress = getERC721FactoryAddress(client.ledgerId);
    const normalisedParams = HederaParameterNormaliser.normaliseCreateERC721Params(
      params,
      factoryContractAddress,
      ERC721_FACTORY_ABI,
      "deployToken",
      context
    );
    const tx = HederaBuilder.executeTransaction(normalisedParams);
    const result = await handleTransaction(tx, client, context);
    if (context.mode == "autonomous" /* AUTONOMOUS */) {
      const erc721Address = await getERC721Address(client, result);
      return {
        ...result,
        erc721Address: erc721Address?.toString(),
        message: `ERC721 token created successfully at address ${erc721Address?.toString()}`
      };
    }
    return result;
  } catch (error) {
    const desc = "Failed to create ERC721 token";
    const message = desc + (error instanceof Error ? `: ${error.message}` : "");
    console.error("[create_erc721_tool]", message);
    return { raw: { status: Status24.InvalidTransaction, error: message }, humanMessage: message };
  }
};
var CREATE_ERC721_TOOL = "create_erc721_tool";
var tool30 = (context) => ({
  method: CREATE_ERC721_TOOL,
  name: "Create ERC721 Token",
  description: createERC721Prompt(context),
  parameters: createERC721Parameters(context),
  execute: createERC721
});
var create_erc721_default = tool30;

// src/plugins/core-evm-plugin/index.ts
var coreEVMPlugin = {
  name: "core-evm-plugin",
  version: "1.0.0",
  description: "A plugin for the Hedera EVM",
  tools: (context) => {
    return [
      create_erc20_default(context),
      transfer_erc20_default(context),
      transfer_erc721_default(context),
      mint_erc721_default(context),
      create_erc721_default(context)
    ];
  }
};
var coreEVMPluginToolNames = {
  TRANSFER_ERC721_TOOL,
  MINT_ERC721_TOOL,
  CREATE_ERC20_TOOL,
  TRANSFER_ERC20_TOOL,
  CREATE_ERC721_TOOL
};

// src/plugins/core-account-query-plugin/tools/queries/get-hbar-balance-query.ts
var getHbarBalanceQueryPrompt2 = (context = {}) => {
  const contextSnippet = PromptGenerator.getContextSnippet(context);
  const accountDesc = PromptGenerator.getAccountParameterDescription("accountId", context);
  const usageInstructions = PromptGenerator.getParameterUsageInstructions();
  return `
${contextSnippet}

This tool will return the HBAR balance for a given Hedera account.

Parameters:
- ${accountDesc}
${usageInstructions}
`;
};
var postProcess26 = (hbarBalance, accountId) => {
  return `Account ${accountId} has a balance of ${hbarBalance} HBAR`;
};
var getHbarBalanceQuery2 = async (client, context, params) => {
  try {
    const normalisedParams = HederaParameterNormaliser.normaliseHbarBalanceParams(
      params,
      context,
      client
    );
    const mirrornodeService = getMirrornodeService(context.mirrornodeService, client.ledgerId);
    const balance = await mirrornodeService.getAccountHBarBalance(
      normalisedParams.accountId
    );
    return {
      raw: { accountId: normalisedParams.accountId, hbarBalance: toHBar(balance).toString() },
      humanMessage: postProcess26(toHBar(balance).toString(), normalisedParams.accountId)
    };
  } catch (error) {
    const desc = "Failed to get HBAR balance";
    const message = desc + (error instanceof Error ? `: ${error.message}` : "");
    console.error("[get_hbar_balance_query_tool]", message);
    return { raw: { error: message }, humanMessage: message };
  }
};
var GET_HBAR_BALANCE_QUERY_TOOL2 = "get_hbar_balance_query_tool";
var tool31 = (context) => ({
  method: GET_HBAR_BALANCE_QUERY_TOOL2,
  name: "Get HBAR Balance",
  description: getHbarBalanceQueryPrompt2(context),
  parameters: accountBalanceQueryParameters(context),
  execute: getHbarBalanceQuery2
});
var get_hbar_balance_query_default2 = tool31;

// src/plugins/core-account-query-plugin/tools/queries/get-account-query.ts
import { Status as Status25 } from "@hashgraph/sdk";
var getAccountQueryPrompt2 = (context = {}) => {
  const contextSnippet = PromptGenerator.getContextSnippet(context);
  const usageInstructions = PromptGenerator.getParameterUsageInstructions();
  return `
${contextSnippet}

This tool will return the account information for a given Hedera account.

Parameters:
- accountId (str, required): The account ID to query
${usageInstructions}
`;
};
var postProcess27 = (account) => {
  return `Details for ${account.accountId}
Balance: ${account.balance.balance.toString()}
Public Key: ${account.accountPublicKey},
EVM address: ${account.evmAddress},
`;
};
var getAccountQuery2 = async (client, context, params) => {
  try {
    const mirrornodeService = getMirrornodeService(context.mirrornodeService, client.ledgerId);
    const account = await mirrornodeService.getAccount(params.accountId);
    return {
      raw: { accountId: params.accountId, account },
      humanMessage: postProcess27(account)
    };
  } catch (error) {
    const desc = "Failed to get account query";
    const message = desc + (error instanceof Error ? `: ${error.message}` : "");
    console.error("[get_account_query_tool]", message);
    return { raw: { status: Status25.InvalidTransaction, error: message }, humanMessage: message };
  }
};
var GET_ACCOUNT_QUERY_TOOL2 = "get_account_query_tool";
var tool32 = (context) => ({
  method: GET_ACCOUNT_QUERY_TOOL2,
  name: "Get Account Query",
  description: getAccountQueryPrompt2(context),
  parameters: accountQueryParameters(context),
  execute: getAccountQuery2
});
var get_account_query_default2 = tool32;

// src/plugins/core-account-query-plugin/tools/queries/get-account-token-balances-query.ts
var getAccountTokenBalancesQueryPrompt2 = (context = {}) => {
  const contextSnippet = PromptGenerator.getContextSnippet(context);
  const accountDesc = PromptGenerator.getAccountParameterDescription("accountId", context);
  const usageInstructions = PromptGenerator.getParameterUsageInstructions();
  return `
${contextSnippet}

This tool will return the token balances for a given Hedera account.

Parameters:
- ${accountDesc}
- tokenId (str, optional): The token ID to query for. If not provided, all token balances will be returned
${usageInstructions}
`;
};
var postProcess28 = (tokenBalances, accountId) => {
  if (tokenBalances.tokens.length === 0) {
    return `No token balances found for account ${accountId}`;
  }
  const balancesText = tokenBalances.tokens.map(
    (token) => `  Token: ${token.token_id}, Balance: ${token.balance}, Decimals: ${token.decimals}`
  ).join("\n");
  return `Details for ${accountId}
--- Token Balances ---
${balancesText}`;
};
var getAccountTokenBalancesQuery2 = async (client, context, params) => {
  try {
    const normalisedParams = HederaParameterNormaliser.normaliseAccountTokenBalancesParams(
      params,
      context,
      client
    );
    const mirrornodeService = getMirrornodeService(context.mirrornodeService, client.ledgerId);
    const tokenBalances = await mirrornodeService.getAccountTokenBalances(
      normalisedParams.accountId,
      normalisedParams.tokenId
    );
    return {
      raw: { accountId: normalisedParams.accountId, tokenBalances },
      humanMessage: postProcess28(tokenBalances, normalisedParams.accountId)
    };
  } catch (error) {
    const desc = "Failed to get account token balances";
    const message = desc + (error instanceof Error ? `: ${error.message}` : "");
    console.error("[get_account_token_balances_query_tool]", message);
    return { raw: { error: message }, humanMessage: message };
  }
};
var GET_ACCOUNT_TOKEN_BALANCES_QUERY_TOOL2 = "get_account_token_balances_query_tool";
var tool33 = (context) => ({
  method: GET_ACCOUNT_TOKEN_BALANCES_QUERY_TOOL2,
  name: "Get Account Token Balances",
  description: getAccountTokenBalancesQueryPrompt2(context),
  parameters: accountTokenBalancesQueryParameters(context),
  execute: getAccountTokenBalancesQuery2
});
var get_account_token_balances_query_default2 = tool33;

// src/plugins/core-account-query-plugin/index.ts
var coreAccountQueryPlugin = {
  name: "core-account-query-plugin",
  version: "1.0.0",
  description: "A plugin for Hedera Account Service queries",
  tools: (context) => {
    return [
      get_hbar_balance_query_default2(context),
      get_account_query_default2(context),
      get_account_token_balances_query_default2(context)
    ];
  }
};
var coreAccountQueryPluginToolNames = {
  GET_HBAR_BALANCE_QUERY_TOOL: GET_HBAR_BALANCE_QUERY_TOOL2,
  GET_ACCOUNT_QUERY_TOOL: GET_ACCOUNT_QUERY_TOOL2,
  GET_ACCOUNT_TOKEN_BALANCES_QUERY_TOOL: GET_ACCOUNT_TOKEN_BALANCES_QUERY_TOOL2
};

// src/plugins/core-token-query-plugin/tools/queries/get-token-info-query.ts
var getTokenInfoQueryPrompt2 = (context = {}) => {
  const contextSnippet = PromptGenerator.getContextSnippet(context);
  const usageInstructions = PromptGenerator.getParameterUsageInstructions();
  return `
${contextSnippet}

This tool will return the information for a given Hedera token.

Parameters:
- tokenId (str): The token ID to query for.
${usageInstructions}
`;
};
var postProcess29 = (tokenInfo) => {
  const formatSupply = (supply) => {
    if (!supply) return "N/A";
    const decimals = Number(tokenInfo.decimals || "0");
    const amount = Number(supply);
    if (isNaN(amount)) return supply;
    return (amount / 10 ** decimals).toLocaleString();
  };
  const formatKey = (key) => {
    if (!key) return "Not Set";
    return key._type ? `${key.key}` : "Present";
  };
  const supplyType = tokenInfo.supply_type === "INFINITE" ? "Infinite" : "Finite";
  const freezeStatus = tokenInfo.freeze_default ? "Frozen" : "Active";
  return `Here are the details for token **${tokenInfo.token_id}**:

- **Token Name**: ${tokenInfo.name}
- **Token Symbol**: ${tokenInfo.symbol}
- **Token Type**: ${tokenInfo.type || "N/A"}
- **Decimals**: ${tokenInfo.decimals}
- **Max Supply**: ${formatSupply(tokenInfo.max_supply)}
- **Current Supply**: ${formatSupply(tokenInfo.total_supply)}
- **Supply Type**: ${supplyType}
- **Treasury Account ID**: ${tokenInfo.treasury_account_id || "N/A"}
- **Status (Deleted/Active)**: ${tokenInfo.deleted ? "Deleted" : "Active"}
- **Status (Frozen/Active)**: ${freezeStatus}

**Keys**:
- Admin Key: ${formatKey(tokenInfo.admin_key)}
- Supply Key: ${formatKey(tokenInfo.supply_key)}
- Wipe Key: ${formatKey(tokenInfo.wipe_key)}
- KYC Key: ${formatKey(tokenInfo.kyc_key)}
- Freeze Key: ${formatKey(tokenInfo.freeze_key)}
- Fee Schedule Key: ${formatKey(tokenInfo.fee_schedule_key)}
- Pause Key: ${formatKey(tokenInfo.pause_key)}
- Metadata Key: ${formatKey(tokenInfo.metadata_key)}

${tokenInfo.memo ? `**Memo**: ${tokenInfo.memo}` : ""}
`;
};
var getTokenInfoQuery2 = async (client, context, params) => {
  try {
    const mirrornodeService = getMirrornodeService(context.mirrornodeService, client.ledgerId);
    const tokenInfo = {
      ...await mirrornodeService.getTokenInfo(params.tokenId),
      token_id: params.tokenId
    };
    return {
      raw: { tokenId: params.tokenId, tokenInfo },
      humanMessage: postProcess29(tokenInfo)
    };
  } catch (error) {
    const desc = "Failed to get token info";
    const message = desc + (error instanceof Error ? `: ${error.message}` : "");
    console.error("[get_token_info_query_tool]", message);
    return { raw: { error: message }, humanMessage: message };
  }
};
var GET_TOKEN_INFO_QUERY_TOOL2 = "get_token_info_query_tool";
var tool34 = (context) => ({
  method: GET_TOKEN_INFO_QUERY_TOOL2,
  name: "Get Token Info",
  description: getTokenInfoQueryPrompt2(context),
  parameters: tokenInfoQueryParameters(context),
  execute: getTokenInfoQuery2
});
var get_token_info_query_default2 = tool34;

// src/plugins/core-token-query-plugin/tools/queries/get-pending-airdrop-query.ts
var getPendingAirdropQueryPrompt = (context = {}) => {
  const contextSnippet = PromptGenerator.getContextSnippet(context);
  const accountDesc = PromptGenerator.getAccountParameterDescription("accountId", context);
  const usageInstructions = PromptGenerator.getParameterUsageInstructions();
  return `
${contextSnippet}

This tool will return pending airdrops for a given Hedera account.

Parameters:
- ${accountDesc}
${usageInstructions}
`;
};
var formatAirdrop = (airdrop, index) => {
  const token = airdrop.token_id ?? "N/A";
  const amount = airdrop.amount ?? 0;
  const serial = airdrop.serial_number ?? "N/A";
  const sender = airdrop.sender_id ?? "N/A";
  const receiver = airdrop.receiver_id ?? "N/A";
  const fromTs = airdrop.timestamp?.from ?? "N/A";
  const toTs = airdrop.timestamp?.to ?? "N/A";
  return `#${index + 1} Token: ${token}, Amount: ${amount}, Serial: ${serial}, Sender: ${sender}, Receiver: ${receiver}, Timestamp: ${fromTs}${toTs ? ` \u2192 ${toTs}` : ""}`;
};
var postProcess30 = (accountId, response) => {
  const count = response.airdrops?.length ?? 0;
  if (count === 0) {
    return `No pending airdrops found for account ${accountId}`;
  }
  const details = response.airdrops.map(formatAirdrop).join("\n");
  return `Here are the pending airdrops for account **${accountId}** (total: ${count}):

${details}`;
};
var getPendingAirdropQuery = async (client, context, params) => {
  try {
    const accountId = params.accountId ?? AccountResolver.getDefaultAccount(context, client);
    if (!accountId) throw new Error("Account ID is required and was not provided");
    const mirrornodeService = getMirrornodeService(context.mirrornodeService, client.ledgerId);
    const response = await mirrornodeService.getPendingAirdrops(accountId);
    return {
      raw: { accountId, pendingAirdrops: response },
      humanMessage: postProcess30(accountId, response)
    };
  } catch (error) {
    const desc = "Failed to get pending airdrops";
    const message = desc + (error instanceof Error ? `: ${error.message}` : "");
    console.error("[get_pending_airdrop_query_tool]", message);
    return { raw: { error: message }, humanMessage: message };
  }
};
var GET_PENDING_AIRDROP_TOOL = "get_pending_airdrop_tool";
var tool35 = (context) => ({
  method: GET_PENDING_AIRDROP_TOOL,
  name: "Get Pending Airdrops",
  description: getPendingAirdropQueryPrompt(context),
  parameters: pendingAirdropQueryParameters(context),
  execute: getPendingAirdropQuery
});
var get_pending_airdrop_query_default = tool35;

// src/plugins/core-token-query-plugin/index.ts
var coreTokenQueryPlugin = {
  name: "core-token-query-plugin",
  version: "1.0.0",
  description: "A plugin for Hedera Token Service queries",
  tools: (context) => {
    return [get_token_info_query_default2(context), get_pending_airdrop_query_default(context)];
  }
};
var coreTokenQueryPluginToolNames = {
  GET_TOKEN_INFO_QUERY_TOOL: GET_TOKEN_INFO_QUERY_TOOL2,
  GET_PENDING_AIRDROP_TOOL
};

// src/plugins/core-consensus-query-plugin/tools/queries/get-topic-messages-query.ts
var getTopicMessagesQueryPrompt2 = (context = {}) => {
  const contextSnippet = PromptGenerator.getContextSnippet(context);
  const usageInstructions = PromptGenerator.getParameterUsageInstructions();
  return `
${contextSnippet}

This tool will return the messages for a given Hedera topic.

Parameters:
- topicId (str, required): The topic ID to query
- startTime (datetime, optional): The start datetime to query. If set, the messages will be returned after this datetime
- endTime (datetime, optional): The end datetime to query. If set, the messages will be returned before this datetime
- limit (int, optional): The limit of messages to query. If set, the number of messages to return
${usageInstructions}
`;
};
var postProcess31 = (messages, topicId) => {
  if (messages.length === 0) {
    return `No messages found for topic ${topicId}.`;
  }
  const messagesText = messages.map(
    (message) => `${Buffer.from(message.message, "base64").toString("utf-8")} - posted at: ${message.consensus_timestamp}
`
  );
  return `Messages for topic ${topicId}:
  --- Messages ---
  ${messagesText}
  `;
};
var getTopicMessagesQueryParams2 = (params) => {
  return {
    topicId: params.topicId,
    lowerTimestamp: params.startTime ? `${Math.floor(new Date(params.startTime).getTime() / 1e3)}.000000000` : "",
    upperTimestamp: params.endTime ? `${Math.floor(new Date(params.endTime).getTime() / 1e3)}.000000000` : "",
    limit: params.limit || 100
  };
};
var convertMessagesFromBase64ToString2 = (messages) => {
  return messages.map((message) => {
    return {
      ...message,
      message: Buffer.from(message.message, "base64").toString("utf-8")
    };
  });
};
var getTopicMessagesQuery2 = async (client, context, params) => {
  try {
    const mirrornodeService = getMirrornodeService(context.mirrornodeService, client.ledgerId);
    const messages = await mirrornodeService.getTopicMessages(getTopicMessagesQueryParams2(params));
    return {
      raw: {
        topicId: messages.topicId,
        messages: convertMessagesFromBase64ToString2(messages.messages)
      },
      humanMessage: postProcess31(messages.messages, params.topicId)
    };
  } catch (error) {
    const desc = "Failed to get topic messages";
    const message = desc + (error instanceof Error ? `: ${error.message}` : "");
    console.error("[get_topic_messages_query_tool]", message);
    return { raw: { error: message }, humanMessage: message };
  }
};
var GET_TOPIC_MESSAGES_QUERY_TOOL2 = "get_topic_messages_query_tool";
var tool36 = (context) => ({
  method: GET_TOPIC_MESSAGES_QUERY_TOOL2,
  name: "Get Topic Messages",
  description: getTopicMessagesQueryPrompt2(context),
  parameters: topicMessagesQueryParameters(context),
  execute: getTopicMessagesQuery2
});
var get_topic_messages_query_default2 = tool36;

// src/plugins/core-consensus-query-plugin/tools/queries/get-topic-info-query.ts
var getTopicInfoQueryPrompt = (context = {}) => {
  const contextSnippet = PromptGenerator.getContextSnippet(context);
  const usageInstructions = PromptGenerator.getParameterUsageInstructions();
  return `
${contextSnippet}

This tool will return the information for a given Hedera topic (HCS).

Parameters:
- topicId (str): The topic ID to query for.
${usageInstructions}
`;
};
var postProcess32 = (topic) => {
  const formatKey = (key) => {
    if (!key) return "Not Set";
    return key._type ? key.key || "Present" : "Present";
  };
  const formatTimestamp = (ts) => {
    if (!ts) return "N/A";
    const [seconds] = ts.split(".");
    const date = new Date(Number(seconds) * 1e3);
    return date.toISOString();
  };
  return `Here are the details for topic **${topic.topic_id || "N/A"}**:

- **Memo**: ${topic.memo || "N/A"}
- **Deleted**: ${topic.deleted ? "Yes" : "No"}
- **Sequence Number**: ${topic.sequence_number ?? "N/A"}

**Timestamps**:
- Created: ${formatTimestamp(topic.created_timestamp)}

**Entity IDs**:
- Auto Renew Account: ${topic.auto_renew_account || "N/A"}
- Auto Renew Period: ${topic.auto_renew_period ?? "N/A"}

**Keys**:
- Admin Key: ${formatKey(topic.admin_key)}
- Submit Key: ${formatKey(topic.submit_key)}
`;
};
var getTopicInfoQuery = async (client, context, params) => {
  try {
    const mirrornodeService = getMirrornodeService(context.mirrornodeService, client.ledgerId);
    const topicInfo = {
      ...await mirrornodeService.getTopicInfo(params.topicId),
      topic_id: params.topicId
    };
    return {
      raw: { topicId: params.topicId, topicInfo },
      humanMessage: postProcess32(topicInfo)
    };
  } catch (error) {
    const desc = "Failed to get topic info";
    const message = desc + (error instanceof Error ? `: ${error.message}` : "");
    console.error("[get_topic_info_query_tool]", message);
    return { raw: { error: message }, humanMessage: message };
  }
};
var GET_TOPIC_INFO_QUERY_TOOL = "get_topic_info_query_tool";
var tool37 = (context) => ({
  method: GET_TOPIC_INFO_QUERY_TOOL,
  name: "Get Topic Info",
  description: getTopicInfoQueryPrompt(context),
  parameters: getTopicInfoParameters(context),
  execute: getTopicInfoQuery
});
var get_topic_info_query_default = tool37;

// src/plugins/core-consensus-query-plugin/index.ts
var coreConsensusQueryPlugin = {
  name: "core-consensus-query-plugin",
  version: "1.0.0",
  description: "A plugin for Hedera Consensus Service queries",
  tools: (context) => {
    return [get_topic_messages_query_default2(context), get_topic_info_query_default(context)];
  }
};
var coreConsensusQueryPluginToolNames = {
  GET_TOPIC_MESSAGES_QUERY_TOOL: GET_TOPIC_MESSAGES_QUERY_TOOL2,
  GET_TOPIC_INFO_QUERY_TOOL
};

// src/plugins/core-evm-query-plugin/tools/queries/get-contract-info-query.ts
var getContractInfoQueryPrompt = (context = {}) => {
  const contextSnippet = PromptGenerator.getContextSnippet(context);
  const usageInstructions = PromptGenerator.getParameterUsageInstructions();
  return `
${contextSnippet}

This tool will return the information for a given Hedera contract.

Parameters:
- contractId (str): The contract ID to query for.
${usageInstructions}
`;
};
var postProcess33 = (contract) => {
  const formatKey = (key) => {
    if (!key) return "Not Set";
    return key._type ? key.key || "Present" : "Present";
  };
  const formatTimestamp = (ts) => {
    if (!ts) return "N/A";
    const [seconds, nanos] = ts.split(".");
    const date = new Date(Number(seconds) * 1e3);
    return date.toISOString() + (nanos ? `.${nanos}` : "");
  };
  return `Here are the details for contract **${contract.contract_id || "N/A"}**:

- **Memo**: ${contract.memo || "N/A"}
- **Deleted**: ${contract.deleted ? "Yes" : "No"}
- **Permanent Removal**: ${contract.permanent_removal ? "Yes" : "No"}
- **Nonce**: ${contract.nonce ?? "N/A"}

**Timestamps**:
- Created: ${formatTimestamp(contract.created_timestamp)}
- Expiration: ${formatTimestamp(contract.expiration_timestamp)}
- Valid From: ${contract.timestamp?.from || "N/A"}
- Valid To: ${contract.timestamp?.to || "N/A"}

**Entity IDs**:
- Auto Renew Account: ${contract.auto_renew_account || "N/A"}
- File ID: ${contract.file_id || "N/A"}
- Obtainer ID: ${contract.obtainer_id || "N/A"}
- Proxy Account ID: ${contract.proxy_account_id || "N/A"}

**Keys**:
- Admin Key: ${formatKey(contract.admin_key)}

**EVM**:
- Address: ${contract.evm_address || "N/A"}
`;
};
var getContractInfoQuery = async (client, context, params) => {
  try {
    const mirrornodeService = getMirrornodeService(context.mirrornodeService, client.ledgerId);
    const contractInfo = await mirrornodeService.getContractInfo(params.contractId);
    return {
      raw: { contractId: params.contractId, contractInfo },
      humanMessage: postProcess33(contractInfo)
    };
  } catch (error) {
    const desc = "Failed to get contract info";
    const message = desc + (error instanceof Error ? `: ${error.message}` : "");
    console.error("[get_contract_info_query_tool]", message);
    return { raw: { error: message }, humanMessage: message };
  }
};
var GET_CONTRACT_INFO_QUERY_TOOL = "get_contract_info_query_tool";
var tool38 = (context) => ({
  method: GET_CONTRACT_INFO_QUERY_TOOL,
  name: "Get Contract Info",
  description: getContractInfoQueryPrompt(context),
  parameters: contractInfoQueryParameters(context),
  execute: getContractInfoQuery
});
var get_contract_info_query_default = tool38;

// src/plugins/core-evm-query-plugin/index.ts
var coreEVMQueryPlugin = {
  name: "core-evm-query-plugin",
  version: "1.0.0",
  description: "A plugin for Hedera EVM Service queries",
  tools: (context) => {
    return [get_contract_info_query_default(context)];
  }
};
var coreEVMQueryPluginToolNames = {
  GET_CONTRACT_INFO_QUERY_TOOL
};

// src/plugins/core-transactions-query-plugin/tools/queries/get-transaction-record-query.ts
var getTransactionRecordQueryPrompt = (context = {}) => {
  const contextSnippet = PromptGenerator.getContextSnippet(context);
  const usageInstructions = PromptGenerator.getParameterUsageInstructions();
  return `
${contextSnippet}

This tool will return the transaction record for a given Hedera transaction ID.

Parameters:
- transactionId (str, required): The transaction ID to fetch record for. Should be in format \\"shard.realm.num-sss-nnn\\" format where sss are seconds and nnn are nanoseconds
- nonce (number, optional): Optional nonce value for the transaction
${usageInstructions}

Additional information:
If user provides transaction ID in format 0.0.4177806@1755169980.051721264, parse it to 0.0.4177806-1755169980-051721264 and use it as transaction ID. Do not remove the staring zeros.
`;
};
var postProcess34 = (transactionRecord, transactionId) => {
  if (!transactionRecord.transactions || transactionRecord.transactions.length === 0) {
    return `No transaction details found for transaction ID: ${transactionId}`;
  }
  const results = transactionRecord.transactions.map((tx, index) => {
    let transfersInfo = "";
    if (tx.transfers && tx.transfers.length > 0) {
      transfersInfo = "\nTransfers:\n" + tx.transfers.map(
        (transfer) => `  Account: ${transfer.account}, Amount: ${toDisplayUnit(transfer.amount, 8)}\u210F`
      ).join("\n");
    }
    const transactionHeader = transactionRecord.transactions.length > 1 ? `Transaction ${index + 1} Details for ${transactionId}` : `Transaction Details for ${transactionId}`;
    return `${transactionHeader}
Status: ${tx.result}
Consensus Timestamp: ${tx.consensus_timestamp}
Transaction Hash: ${tx.transaction_hash}
Transaction Fee: ${tx.charged_tx_fee}
Type: ${tx.name}
Entity ID: ${tx.entity_id}${transfersInfo}`;
  });
  return results.join("\n\n" + "=".repeat(50) + "\n\n");
};
var getTransactionRecordQuery = async (client, context, params) => {
  try {
    const mirrornodeService = getMirrornodeService(context.mirrornodeService, client.ledgerId);
    const normalisedParams = HederaParameterNormaliser.normaliseGetTransactionRecordParams(
      params,
      context
    );
    const transactionRecord = await mirrornodeService.getTransactionRecord(
      normalisedParams.transactionId,
      normalisedParams.nonce
    );
    return {
      raw: { transactionId: params.transactionId, transactionRecord },
      humanMessage: postProcess34(transactionRecord, params.transactionId)
    };
  } catch (error) {
    const desc = "Failed to get transaction record";
    const message = desc + (error instanceof Error ? `: ${error.message}` : "");
    console.error("[get_transaction_record_query_tool]", message);
    return { raw: { error: message }, humanMessage: message };
  }
};
var GET_TRANSACTION_RECORD_QUERY_TOOL = "get_transaction_record_query_tool";
var tool39 = (context) => ({
  method: GET_TRANSACTION_RECORD_QUERY_TOOL,
  name: "Get Transaction Record Query",
  description: getTransactionRecordQueryPrompt(context),
  parameters: transactionRecordQueryParameters(context),
  execute: getTransactionRecordQuery
});
var get_transaction_record_query_default = tool39;

// src/plugins/core-transactions-query-plugin/index.ts
var coreTransactionQueryPlugin = {
  name: "core-transaction-query-plugin",
  version: "1.0.0",
  description: "A plugin for Hedera Transactions queries",
  tools: (context) => {
    return [get_transaction_record_query_default(context)];
  }
};
var coreTransactionQueryPluginToolNames = {
  GET_TRANSACTION_RECORD_QUERY_TOOL
};

// src/plugins/index.ts
var coreHTSPlugin = coreTokenPlugin;
var coreHTSPluginToolNames = coreTokenPluginToolNames;
var coreSCSPlugin = coreEVMPlugin;
var coreSCSPluginToolNames = coreEVMPluginToolNames;

// src/shared/plugin.ts
var CORE_PLUGINS = [
  coreAccountPlugin,
  coreTokenPlugin,
  coreConsensusPlugin,
  coreEVMPlugin,
  coreAccountQueryPlugin,
  coreTokenQueryPlugin,
  coreConsensusQueryPlugin
];
var PluginRegistry = class {
  plugins = /* @__PURE__ */ new Map();
  register(plugin) {
    if (this.plugins.has(plugin.name)) {
      console.warn(`Plugin "${plugin.name}" is already registered. Overwriting.`);
    }
    this.plugins.set(plugin.name, plugin);
  }
  getPlugins() {
    return Array.from(this.plugins.values());
  }
  loadCorePlugins(context) {
    const pluginTools = [];
    for (const plugin of CORE_PLUGINS) {
      try {
        const tools = plugin.tools(context);
        pluginTools.push(...tools);
      } catch (error) {
        console.error(`Error loading tools from plugin "${plugin.name}":`, error);
      }
    }
    return pluginTools;
  }
  loadPlugins(context) {
    const pluginTools = [];
    for (const plugin of this.plugins.values()) {
      try {
        const tools = plugin.tools(context);
        pluginTools.push(...tools);
      } catch (error) {
        console.error(`Error loading tools from plugin "${plugin.name}":`, error);
      }
    }
    return pluginTools;
  }
  getTools(context) {
    if (this.plugins.size === 0) {
      return this.loadCorePlugins(context);
    } else {
      return this.loadPlugins(context);
    }
  }
  clear() {
    this.plugins.clear();
  }
};

// src/langchain/tool.ts
import { StructuredTool } from "@langchain/core/tools";
var HederaAgentKitTool = class extends StructuredTool {
  hederaAPI;
  method;
  name;
  description;
  schema;
  constructor(HederaAgentKitAPI, method, description, schema) {
    super();
    this.hederaAPI = HederaAgentKitAPI;
    this.method = method;
    this.name = method;
    this.description = description;
    this.schema = schema;
  }
  _call(arg, _runManager, _parentConfig) {
    return this.hederaAPI.run(this.method, arg);
  }
};
var tool_default = HederaAgentKitTool;

// src/shared/tool-discovery.ts
var ToolDiscovery = class _ToolDiscovery {
  pluginRegistry = new PluginRegistry();
  constructor(plugins = []) {
    plugins.forEach((plugin) => this.pluginRegistry.register(plugin));
  }
  getAllTools(context, configuration) {
    const pluginTools = this.pluginRegistry.getTools(context);
    const allTools = [];
    const allToolNames = /* @__PURE__ */ new Set();
    pluginTools.forEach((pluginTool) => {
      if (!allToolNames.has(pluginTool.method)) {
        allTools.push(pluginTool);
        allToolNames.add(pluginTool.method);
      } else {
        console.warn(
          `Plugin tool "${pluginTool.method}" conflicts with core tool. Using core tool.`
        );
      }
    });
    if (configuration?.tools && configuration.tools.length > 0) {
      return allTools.filter((tool41) => configuration.tools.includes(tool41.method));
    }
    return allTools;
  }
  static createFromConfiguration(configuration) {
    return new _ToolDiscovery(configuration.plugins || []);
  }
};

// src/langchain/toolkit.ts
var HederaLangchainToolkit = class {
  _hederaAgentKit;
  tools;
  constructor({ client, configuration }) {
    const context = configuration.context || {};
    const toolDiscovery = ToolDiscovery.createFromConfiguration(configuration);
    const allTools = toolDiscovery.getAllTools(context, configuration);
    this._hederaAgentKit = new api_default(client, configuration.context, allTools);
    this.tools = allTools.map(
      (tool41) => new tool_default(
        this._hederaAgentKit,
        tool41.method,
        tool41.description,
        tool41.parameters
      )
    );
  }
  getTools() {
    return this.tools;
  }
  getHederaAgentKitAPI() {
    return this._hederaAgentKit;
  }
};
var toolkit_default = HederaLangchainToolkit;

// src/modelcontextprotocol/toolkit.ts
import { McpServer } from "@modelcontextprotocol/sdk/server/mcp.js";
var HederaMCPToolkit = class extends McpServer {
  _hederaAgentKit;
  constructor({ client, configuration }) {
    super({
      name: "Hedera Agent Kit",
      version: "0.1.0",
      configuration: {
        ...configuration,
        context: {
          ...configuration.context,
          mode: "modelcontextprotocol"
        }
      }
    });
    const context = configuration.context || {};
    const toolDiscovery = ToolDiscovery.createFromConfiguration(configuration);
    const allTools = toolDiscovery.getAllTools(context, configuration);
    this._hederaAgentKit = new api_default(client, configuration.context, allTools);
    allTools.map((tool41) => {
      this.tool(
        tool41.method,
        tool41.description,
        tool41.parameters.shape,
        async (arg, _extra) => {
          const result = await this._hederaAgentKit.run(tool41.method, arg);
          return {
            content: [
              {
                type: "text",
                text: String(result)
              }
            ]
          };
        }
      );
    });
  }
};
var toolkit_default2 = HederaMCPToolkit;

// src/ai-sdk/tool.ts
import { tool as tool40 } from "ai";
function HederaAgentKitTool2(hederaAPI, method, description, schema) {
  return tool40({
    description,
    parameters: schema,
    execute: (arg) => {
      return hederaAPI.run(method, arg);
    }
  });
}

// src/ai-sdk/toolkit.ts
var HederaAIToolkit = class {
  _hedera;
  tools;
  constructor({ client, configuration }) {
    const context = configuration.context || {};
    const toolDiscovery = ToolDiscovery.createFromConfiguration(configuration);
    const allTools = toolDiscovery.getAllTools(context, configuration);
    this._hedera = new api_default(client, configuration.context, allTools);
    this.tools = {};
    allTools.forEach((tool41) => {
      this.tools[tool41.method] = HederaAgentKitTool2(
        this._hedera,
        tool41.method,
        tool41.description,
        tool41.parameters
      );
    });
  }
  middleware() {
    return {
      wrapGenerate: async ({ doGenerate }) => {
        return doGenerate();
      },
      wrapStream: async ({ doStream }) => {
        return doStream();
      }
    };
  }
  getTools() {
    return this.tools;
  }
};
var toolkit_default3 = HederaAIToolkit;

// src/elizaos/tool.ts
import {
  composePromptFromState,
  logger,
  ModelType
} from "@elizaos/core";

// src/elizaos/utils/extraction.ts
import { zodToJsonSchema } from "zod-to-json-schema";
function generateExtractionTemplate(tool41) {
  const zodSchema = tool41.parameters;
  const description = tool41.description;
  const actionName = tool41.name;
  const toolParamsJSONSchema = zodToJsonSchema(zodSchema, actionName);
  return `Given the recent messages and Hedera wallet information below:
{{recentMessages}}
{{hederaAccountDetails}}

Extract the following parameters based on the tool/action description and json schema below:

### Tool/action description:
${description}

\u26A0\uFE0F Do **not** assume values or apply defaults. Do **not** set a field unless it is clearly specified in the latest user input.
\u26A0\uFE0F **IMPORTANT**: Always ensure numeric values are provided as NUMBERS WITHOUT QUOTES in the JSON response.
\u26A0\uFE0F **IMPORTANT**: Always ensure string values are provided as QUOTED STRINGS in the JSON response.
\u26A0\uFE0F **CRITICAL**: Enum values must be provided as QUOTED STRINGS (e.g., "finite", not finite).
\u26A0\uFE0F **CRITICAL**: The returned JSON must be a valid JSON object in markdown format. Don not include comments inside it. If no params is passed return an empty JSON object.

---

### Response format:
Respond with a JSON markdown block including the fields that were explicitly mentioned in the most recent user message.

Response JSON schema:
${JSON.stringify(toolParamsJSONSchema, null, 2)}

---

Numeric values should be numbers without quotes. Enum values must be quoted strings.`;
}

// src/elizaos/utils/parser.ts
var jsonBlockPattern = /```(?:json)?\s*([\s\S]*?)```/;
function customParseJSONObjectFromText(text) {
  if (!text) return null;
  let jsonData = null;
  const jsonBlockMatch = text.match(jsonBlockPattern);
  try {
    if (jsonBlockMatch) {
      const jsonContent = jsonBlockMatch[1].trim().replace(/[\u0000-\u001F\u007F-\u009F]/g, "");
      jsonData = JSON.parse(jsonContent);
    } else {
      try {
        jsonData = JSON.parse(text.trim());
      } catch {
        jsonData = JSON.parse(customNormalizeJsonString(text.trim()));
      }
    }
  } catch (error) {
    console.warn("Could not parse text as JSON:", error);
    return null;
  }
  if (jsonData && typeof jsonData === "object") {
    return jsonData;
  }
  console.warn("Parsed result is not a valid object or array");
  return null;
}
function customNormalizeJsonString(str) {
  if (!str) return str;
  str = str.replace(/\{\s+/, "{").replace(/\s+\}/, "}").trim();
  str = str.replace(/(\s*)(\w+)(\s*):(\s*)/g, '$1"$2"$3:$4');
  str = str.replace(/"([^"]+)"\s*:\s*'([^']*)'/g, (_, key, value) => `"${key}": "${value}"`);
  str = str.replace(/"([^"]+)"\s*:\s*([^",\{\[\]\}0-9][^",\{\[\]\}\s]*)/g, (match, key, value) => {
    if (value === "true" || value === "false" || value === "null") {
      return `"${key}": ${value}`;
    }
    if (!isNaN(Number(value))) {
      return `"${key}": ${value}`;
    }
    return `"${key}": "${value}"`;
  });
  return str;
}

// src/elizaos/tool.ts
var HederaAgentKitTool3 = class {
  description;
  handler;
  similes;
  examples;
  name;
  validate;
  constructor(client, context, tool41) {
    const parameterSchema = tool41.parameters;
    this.description = tool41.description;
    this.name = tool41.method.toUpperCase();
    this.similes = [tool41.method.toUpperCase()];
    this.validate = async (_runtime, _message) => true;
    this.handler = async (runtime, _message, state, _options, callback) => {
      logger.log(`Running ${tool41.method} handler...`);
      if (!state) {
        throw new Error("State is undefined");
      }
      const prompt = composePromptFromState({
        state,
        template: generateExtractionTemplate(tool41)
      });
      logger.debug(`prompt: ${prompt}`);
      const modelOutput = await runtime.useModel(ModelType.TEXT_LARGE, { prompt });
      logger.debug(`Model extraction output: ${modelOutput}`);
      const parsedParams = customParseJSONObjectFromText(modelOutput);
      logger.debug("Parsed params object", parsedParams);
      const validation = parameterSchema.safeParse(parsedParams);
      logger.debug("Validated params:" + JSON.stringify(validation, null, 2));
      if (!validation.success) {
        const promptText = `given the recent messages {{recent_messages}}, 
        tool description: ${tool41.description}
        and the error message: ${validation.error.format()}
        generate a comprehensive message to the user about missing params
        `;
        const modelOutput2 = await runtime.useModel(ModelType.TEXT_LARGE, { promptText });
        if (callback) {
          await callback({
            text: modelOutput2,
            content: { error: validation.error.format() }
          });
        }
        return {
          success: false,
          text: modelOutput2,
          error: validation.error.toString()
        };
      }
      try {
        const result = await tool41.execute(client, context, validation.data);
        const responseText = result.humanMessage;
        if (callback) {
          await callback({
            text: responseText,
            content: result
          });
        }
        return { success: true, text: responseText };
      } catch (err) {
        const message = err instanceof Error ? err.message : "Unknown error";
        logger.error(`Error running tool ${tool41.method}:`, err);
        if (callback) {
          await callback({
            text: `Execution failed: ${message}`,
            content: { error: message }
          });
        }
        return { success: false, text: `Execution failed: ${message}`, error: message };
      }
    };
  }
};
var tool_default2 = HederaAgentKitTool3;

// src/elizaos/toolkit.ts
var HederaElizaOSToolkit = class {
  tools;
  client;
  context;
  constructor({ client, configuration }) {
    this.client = client;
    this.context = configuration.context || {};
    const toolDiscovery = ToolDiscovery.createFromConfiguration(configuration);
    const allTools = toolDiscovery.getAllTools(this.context, configuration);
    this.tools = allTools.map((tool41) => new tool_default2(this.client, this.context, tool41));
  }
  /**
   * Maps hedera-agent-kit tools and returns ElizaOS compatible actions
   */
  getTools() {
    return this.tools;
  }
};
export {
  AccountResolver,
  AgentMode,
  ERC20_FACTORY_ABI,
  ERC20_FACTORY_ADDRESSES,
  ERC20_TRANSFER_FUNCTION_ABI,
  ERC20_TRANSFER_FUNCTION_NAME,
  ERC721_FACTORY_ABI,
  ERC721_FACTORY_ADDRESSES,
  ERC721_MINT_FUNCTION_ABI,
  ERC721_MINT_FUNCTION_NAME,
  ERC721_TRANSFER_FUNCTION_ABI,
  ERC721_TRANSFER_FUNCTION_NAME,
  ExecuteStrategy,
  toolkit_default3 as HederaAIToolkit,
  HederaElizaOSToolkit,
  toolkit_default as HederaLangchainToolkit,
  toolkit_default2 as HederaMCPToolkit,
  PluginRegistry,
  PromptGenerator,
  coreAccountPlugin,
  coreAccountPluginToolNames,
  coreAccountQueryPlugin,
  coreAccountQueryPluginToolNames,
  coreConsensusPlugin,
  coreConsensusPluginToolNames,
  coreConsensusQueryPlugin,
  coreConsensusQueryPluginToolNames,
  coreEVMPlugin,
  coreEVMPluginToolNames,
  coreEVMQueryPlugin,
  coreEVMQueryPluginToolNames,
  coreHTSPlugin,
  coreHTSPluginToolNames,
  coreMiscQueriesPlugin,
  coreMiscQueriesPluginsToolNames,
  coreQueriesPlugin,
  coreQueriesPluginToolNames,
  coreSCSPlugin,
  coreSCSPluginToolNames,
  coreTokenPlugin,
  coreTokenPluginToolNames,
  coreTokenQueryPlugin,
  coreTokenQueryPluginToolNames,
  coreTransactionQueryPlugin,
  coreTransactionQueryPluginToolNames,
  getERC20FactoryAddress,
  getERC721FactoryAddress,
  handleTransaction
};
//# sourceMappingURL=index.mjs.map