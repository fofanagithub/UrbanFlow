{"version":3,"sources":["../../src/shared/api.ts","../../src/shared/configuration.ts","../../src/shared/parameter-schemas/token.zod.ts","../../src/shared/parameter-schemas/account.zod.ts","../../src/shared/parameter-schemas/consensus.zod.ts","../../src/shared/hedera-utils/hedera-parameter-normaliser.ts","../../src/shared/hedera-utils/decimals-utils.ts","../../src/shared/utils/account-resolver.ts","../../src/shared/parameter-schemas/evm.zod.ts","../../src/shared/parameter-schemas/transaction.zod.ts","../../src/plugins/core-token-plugin/tools/fungible-token/airdrop-fungible-token.ts","../../src/shared/strategies/tx-mode-strategy.ts","../../src/shared/hedera-utils/hedera-builder.ts","../../src/shared/hedera-utils/mirrornode/types.ts","../../src/shared/hedera-utils/mirrornode/hedera-mirrornode-service-default-impl.ts","../../src/shared/hedera-utils/mirrornode/hedera-mirrornode-utils.ts","../../src/shared/utils/prompt-generator.ts","../../src/plugins/core-token-plugin/tools/fungible-token/create-fungible-token.ts","../../src/plugins/core-token-plugin/tools/fungible-token/mint-fungible-token.ts","../../src/plugins/core-token-plugin/tools/non-fungible-token/create-non-fungible-token.ts","../../src/plugins/core-token-plugin/tools/non-fungible-token/mint-non-fungible-token.ts","../../src/plugins/core-token-plugin/tools/update-token.ts","../../src/plugins/core-token-plugin/tools/dissociate-token.ts","../../src/plugins/core-token-plugin/tools/associate-token.ts","../../src/plugins/core-token-plugin/index.ts","../../src/plugins/core-account-plugin/tools/account/transfer-hbar.ts","../../src/plugins/core-account-plugin/tools/account/approve-hbar-allowance.ts","../../src/plugins/core-account-plugin/tools/account/create-account.ts","../../src/plugins/core-account-plugin/tools/account/delete-account.ts","../../src/plugins/core-account-plugin/tools/account/update-account.ts","../../src/plugins/core-account-plugin/tools/account/sign-schedule-transaction.ts","../../src/plugins/core-account-plugin/tools/account/schedule-delete.ts","../../src/plugins/core-account-plugin/index.ts","../../src/plugins/core-consensus-plugin/tools/consensus/create-topic.ts","../../src/plugins/core-consensus-plugin/tools/consensus/delete-topic.ts","../../src/plugins/core-consensus-plugin/tools/consensus/submit-topic-message.ts","../../src/plugins/core-consensus-plugin/tools/consensus/update-topic.ts","../../src/plugins/core-consensus-plugin/index.ts","../../src/shared/hedera-utils/hbar-conversion-utils.ts","../../src/plugins/core-queries-plugin/tools/queries/get-hbar-balance-query.ts","../../src/plugins/core-queries-plugin/tools/queries/get-account-query.ts","../../src/plugins/core-queries-plugin/tools/queries/get-account-token-balances-query.ts","../../src/plugins/core-queries-plugin/tools/queries/get-topic-messages-query.ts","../../src/plugins/core-queries-plugin/tools/queries/get-token-info-query.ts","../../src/plugins/core-queries-plugin/index.ts","../../src/shared/parameter-schemas/core-misc.zod.ts","../../src/plugins/core-misc-query-plugin/tools/queries/get-exchange-rate-query.ts","../../src/plugins/core-misc-query-plugin/index.ts","../../src/plugins/core-evm-plugin/tools/erc20/create-erc20.ts","../../src/shared/constants/contracts.ts","../../src/plugins/core-evm-plugin/tools/erc20/transfer-erc20.ts","../../src/plugins/core-evm-plugin/tools/erc721/transfer-erc721.ts","../../src/plugins/core-evm-plugin/tools/erc721/mint-erc721.ts","../../src/plugins/core-evm-plugin/tools/erc721/create-erc721.ts","../../src/plugins/core-evm-plugin/index.ts","../../src/plugins/core-account-query-plugin/tools/queries/get-hbar-balance-query.ts","../../src/plugins/core-account-query-plugin/tools/queries/get-account-query.ts","../../src/plugins/core-account-query-plugin/tools/queries/get-account-token-balances-query.ts","../../src/plugins/core-account-query-plugin/index.ts","../../src/plugins/core-token-query-plugin/tools/queries/get-token-info-query.ts","../../src/plugins/core-token-query-plugin/tools/queries/get-pending-airdrop-query.ts","../../src/plugins/core-token-query-plugin/index.ts","../../src/plugins/core-consensus-query-plugin/tools/queries/get-topic-messages-query.ts","../../src/plugins/core-consensus-query-plugin/tools/queries/get-topic-info-query.ts","../../src/plugins/core-consensus-query-plugin/index.ts","../../src/plugins/core-evm-query-plugin/tools/queries/get-contract-info-query.ts","../../src/plugins/core-evm-query-plugin/index.ts","../../src/plugins/core-transactions-query-plugin/tools/queries/get-transaction-record-query.ts","../../src/plugins/core-transactions-query-plugin/index.ts","../../src/plugins/index.ts","../../src/shared/plugin.ts","../../src/langchain/tool.ts","../../src/shared/tool-discovery.ts","../../src/langchain/toolkit.ts","../../src/modelcontextprotocol/toolkit.ts","../../src/ai-sdk/tool.ts","../../src/ai-sdk/toolkit.ts","../../src/elizaos/tool.ts","../../src/elizaos/utils/extraction.ts","../../src/elizaos/utils/parser.ts","../../src/elizaos/toolkit.ts"],"sourcesContent":["import { Client } from '@hashgraph/sdk';\n\nimport type { Context } from './configuration';\nimport { Tool } from './tools';\n\nclass HederaAgentAPI {\n  client: Client;\n\n  context: Context;\n\n  tools: Tool[];\n\n  constructor(client: Client, context?: Context, tools?: Tool[]) {\n    this.client = client;\n    if (!this.client.ledgerId) {\n      throw new Error('Client must be connected to a network');\n    }\n    this.context = context || {};\n    this.tools = tools || [];\n  }\n\n  async run(method: string, arg: unknown) {\n    const tool = this.tools.find(t => t.method === method);\n    if (tool) {\n      const output = JSON.stringify(await tool.execute(this.client, this.context, arg));\n      return output;\n    } else {\n      throw new Error('Invalid method ' + method);\n    }\n  }\n}\n\nexport default HederaAgentAPI;\n","import { IHederaMirrornodeService } from './hedera-utils/mirrornode/hedera-mirrornode-service.interface';\nimport { Plugin } from './plugin';\n\nexport enum AgentMode {\n  AUTONOMOUS = 'autonomous',\n  RETURN_BYTES = 'returnBytes',\n}\n\n// Context are settings that are applied to all requests made by the integration.\nexport type Context = {\n  // Account is a Connected Account ID. If set, the integration will\n  // make requests for this Account.\n  accountId?: string;\n  // Account Public Key is either passed in configuration or fetched based on the passed accountId\n  accountPublicKey?: string;\n\n  // defines if the agent executes the transactions or returns the raw transaction bytes\n  mode?: AgentMode;\n\n  // Mirrornode config\n  mirrornodeService?: IHederaMirrornodeService;\n};\n\nexport type Configuration = {\n  //if empty, all tools will be used.\n  tools?: string[];\n  //external plugins to load\n  plugins?: Plugin[];\n  context?: Context;\n};\n","import { Context } from '@/shared/configuration';\nimport { z } from 'zod';\nimport { AccountId, PublicKey, TokenId, TokenSupplyType, TokenType } from '@hashgraph/sdk';\nimport { TokenTransferMinimalParams } from '@/shared/hedera-utils/types';\n\nexport const createFungibleTokenParameters = (_context: Context = {}) =>\n  z.object({\n    tokenName: z.string().describe('The name of the token.'),\n    tokenSymbol: z.string().describe('The symbol of the token.'),\n    initialSupply: z\n      .number()\n      .int()\n      .optional()\n      .default(0)\n      .describe('The initial supply of the token.'),\n    supplyType: z\n      .enum(['finite', 'infinite'])\n      .optional()\n      .default('finite')\n      .describe('Supply type of the token.'),\n    maxSupply: z.number().int().optional().describe('The maximum supply of the token.'),\n    decimals: z.number().int().optional().default(0).describe('The number of decimals.'),\n    treasuryAccountId: z.string().optional().describe('The treasury account of the token.'),\n    isSupplyKey: z\n      .boolean()\n      .optional()\n      .describe('Determines if the token supply key should be set.'),\n  });\n\nexport const createFungibleTokenParametersNormalised = (_context: Context = {}) =>\n  createFungibleTokenParameters(_context).extend({\n    treasuryAccountId: z.string().describe('The treasury account of the token.'),\n    autoRenewAccountId: z\n      .string()\n      .optional()\n      .describe(\n        'The auto renew account for the token. If not provided, defaults to the operator account.',\n      ),\n    supplyKey: z\n      .custom<PublicKey>()\n      .optional()\n      .describe('The supply key. If not provided, defaults to the operator’s public key.'),\n    supplyType: z.custom<TokenSupplyType>().describe('Supply type of the token.'),\n    adminKey: z.custom<PublicKey>().optional().describe('The admin key for the token.'),\n    kycKey: z.custom<PublicKey>().optional().describe('The KYC key for the token.'),\n    freezeKey: z.custom<PublicKey>().optional().describe('The freeze key for the token.'),\n    wipeKey: z.custom<PublicKey>().optional().describe('The wipe key for the token.'),\n    pauseKey: z.custom<PublicKey>().optional().describe('The pause key for the token.'),\n    metadataKey: z.custom<PublicKey>().optional().describe('The metadata key for the token.'),\n    tokenMemo: z.string().optional().describe('The memo for the token.'),\n    tokenType: z.custom<TokenType>().optional().describe('The type of the token.'),\n  });\n\nexport const createNonFungibleTokenParameters = (_context: Context = {}) =>\n  z.object({\n    tokenName: z.string().describe('The name of the token.'),\n    tokenSymbol: z.string().describe('The symbol of the token.'),\n    maxSupply: z\n      .number()\n      .int()\n      .optional()\n      .default(100)\n      .describe('The maximum supply of the token.'),\n    treasuryAccountId: z.string().optional().describe('The treasury account of the token.'),\n  });\n\nexport const createNonFungibleTokenParametersNormalised = (_context: Context = {}) =>\n  createNonFungibleTokenParameters(_context).extend({\n    autoRenewAccountId: z\n      .string()\n      .describe(\n        'The auto renew account for the token. If not provided, defaults to the operator account.',\n      ),\n    supplyKey: z\n      .custom<PublicKey>()\n      .describe('The supply key. If not provided, defaults to the operator’s public key.'),\n    supplyType: z\n      .custom<TokenSupplyType>()\n      .default(TokenSupplyType.Finite)\n      .describe('Supply type of the token - must be finite for NFT.'),\n    tokenType: z\n      .custom<TokenType>()\n      .default(TokenType.NonFungibleUnique)\n      .describe('Token type of the token - must be non-fungible unique for NFT.'),\n    adminKey: z.custom<PublicKey>().optional().describe('The admin key for the token.'),\n    kycKey: z.custom<PublicKey>().optional().describe('The KYC key for the token.'),\n    freezeKey: z.custom<PublicKey>().optional().describe('The freeze key for the token.'),\n    wipeKey: z.custom<PublicKey>().optional().describe('The wipe key for the token.'),\n    pauseKey: z.custom<PublicKey>().optional().describe('The pause key for the token.'),\n    tokenMemo: z.string().optional().describe('The memo for the token.'),\n  });\n\nconst AirdropRecipientSchema = z.object({\n  accountId: z.string().describe('Recipient account ID (e.g., \"0.0.xxxx\").'),\n  amount: z.union([z.number(), z.string()]).describe('Amount in base unit.'),\n});\n\nexport const airdropFungibleTokenParameters = (_context: Context = {}) =>\n  z.object({\n    tokenId: z.string().describe('The id of the token.'),\n    sourceAccountId: z.string().optional().describe('The account to airdrop the token from.'),\n    recipients: z\n      .array(AirdropRecipientSchema)\n      .min(1)\n      .describe('Array of recipient objects, each with accountId and amount.'),\n  });\n\nexport const airdropFungibleTokenParametersNormalised = () =>\n  z.object({\n    tokenTransfers: z\n      .custom<TokenTransferMinimalParams[]>()\n      .describe('Array of TokenTransfer objects constructed from the original recipients.'),\n  });\n\nexport const mintFungibleTokenParameters = (_context: Context = {}) =>\n  z.object({\n    tokenId: z.string().describe('The id of the token.'),\n    amount: z.number().describe('The amount of tokens to mint.'),\n  });\n\nexport const mintFungibleTokenParametersNormalised = (_context: Context = {}) =>\n  mintFungibleTokenParameters(_context).extend({});\n\nexport const mintNonFungibleTokenParameters = (_context: Context = {}) =>\n  z.object({\n    tokenId: z.string().describe('The id of the NFT class.'),\n    uris: z.array(z.string().max(100)).max(10).describe('An array of URIs hosting NFT metadata.'),\n  });\n\nexport const mintNonFungibleTokenParametersNormalised = (_context: Context = {}) =>\n  mintNonFungibleTokenParameters(_context).extend({});\n\nexport const deleteTokenParameters = (_context: Context = {}) =>\n  z.object({\n    tokenId: z.string().describe('The ID of the token to delete.'),\n  });\n\nexport const deleteTokenParametersNormalised = (_context: Context = {}) =>\n  deleteTokenParameters(_context).extend({});\n\nexport const tokenInfoQueryParameters = (_context: Context = {}) =>\n  z.object({\n    tokenId: z.string().optional().describe('The token ID to query.'),\n  });\n\nexport const updateTokenParameters = (_context: Context = {}) =>\n  z.object({\n    tokenId: z.string().describe('The ID of the token to update (e.g., 0.0.12345).'),\n    tokenDesc: z\n      .string()\n      .optional()\n      .describe('Optional description of the token update operation.'),\n    tokenName: z\n      .string()\n      .max(100)\n      .optional()\n      .describe('New name for the token. Up to 100 characters.'),\n    tokenSymbol: z\n      .string()\n      .max(100)\n      .optional()\n      .describe('New symbol for the token. Up to 100 characters.'),\n    treasuryAccountId: z\n      .string()\n      .optional()\n      .describe('New treasury account for the token (Hedera account ID).'),\n    adminKey: z\n      .union([z.boolean(), z.string()])\n      .optional()\n      .describe(\n        'New admin key. Pass boolean `true` to use the operator/user key, or provide a Hedera-compatible public key string. Required for most property updates.',\n      ),\n    kycKey: z\n      .union([z.boolean(), z.string()])\n      .optional()\n      .describe(\n        'New KYC key. Pass boolean `true` to use the operator/user key, or provide a public key string.',\n      ),\n    freezeKey: z\n      .union([z.boolean(), z.string()])\n      .optional()\n      .describe(\n        'New freeze key. Pass boolean `true` to use the operator/user key, or provide a public key string.',\n      ),\n    wipeKey: z\n      .union([z.boolean(), z.string()])\n      .optional()\n      .describe(\n        'New wipe key. Pass boolean `true` to use the operator/user key, or provide a public key string.',\n      ),\n    supplyKey: z\n      .union([z.boolean(), z.string()])\n      .optional()\n      .describe(\n        'New supply key. Pass boolean `true` to use the operator/user key, or provide a public key string.',\n      ),\n    feeScheduleKey: z\n      .union([z.boolean(), z.string()])\n      .optional()\n      .describe(\n        'New fee schedule key. Pass boolean `true` to use the operator/user key, or provide a public key string.',\n      ),\n    pauseKey: z\n      .union([z.boolean(), z.string()])\n      .optional()\n      .describe(\n        'New pause key. Pass boolean `true` to use the operator/user key, or provide a public key string.',\n      ),\n    metadataKey: z\n      .union([z.boolean(), z.string()])\n      .optional()\n      .describe(\n        'New metadata key. Pass boolean `true` to use the operator/user key, or provide a public key string.',\n      ),\n    metadata: z\n      .string()\n      .optional()\n      .describe('New metadata for the token, in bytes (as base64 or hex).'),\n    tokenMemo: z\n      .string()\n      .max(100)\n      .optional()\n      .describe('Short public memo for the token, up to 100 characters.'),\n    autoRenewAccountId: z\n      .string()\n      .optional()\n      .describe('Account to automatically pay for token renewal (Hedera account ID).'),\n  });\n\nexport const updateTokenParametersNormalised = (_context: Context = {}) =>\n  z.object({\n    tokenId: z.instanceof(TokenId),\n\n    // Strings\n    tokenName: z.string().optional(),\n    tokenSymbol: z.string().optional(),\n    tokenMemo: z.string().optional(),\n    metadata: z.instanceof(Uint8Array<ArrayBufferLike>).optional(),\n\n    // IDs\n    treasuryAccountId: z.union([z.string(), z.instanceof(AccountId)]).optional(),\n    autoRenewAccountId: z.union([z.string(), z.instanceof(AccountId)]).optional(),\n\n    // Keys\n    adminKey: z.instanceof(PublicKey).optional(),\n    supplyKey: z.instanceof(PublicKey).optional(),\n    wipeKey: z.instanceof(PublicKey).optional(),\n    freezeKey: z.instanceof(PublicKey).optional(),\n    kycKey: z.instanceof(PublicKey).optional(),\n    feeScheduleKey: z.instanceof(PublicKey).optional(),\n    pauseKey: z.instanceof(PublicKey).optional(),\n    metadataKey: z.instanceof(PublicKey).optional(),\n  });\n\n    // Associate Token\nexport const associateTokenParameters = (_context: Context = {}) =>\n  z.object({\n    // If not passed, will be injected from context in normalisation\n    accountId: z\n      .string()\n      .optional()\n      .describe(\n        'Account ID to associate tokens with (e.g., 0.0.xxxxx). If not provided, operator account ID will be used',\n      ),\n    // One or more token IDs to associate\n    tokenIds: z.array(z.string()).min(1).describe('Array of token IDs to associate'),\n  });\n\nexport const associateTokenParametersNormalised = (_context: Context = {}) =>\n  z.object({\n    accountId: z.string().describe('Resolved account ID to associate tokens with'),\n    tokenIds: z.array(z.string()).min(1).describe('Array of token IDs to associate'),\n  });\n\n\nexport const pendingAirdropQueryParameters = (_context: Context = {}) =>\n  z.object({\n    accountId: z.string().optional().describe('The account ID to query.'),\n  });\n\nexport const dissociateTokenParameters = (_context: Context = {}) =>\n  z.object({\n    tokenIds: z\n      .array(z.string())\n      .min(1)\n      .describe('The list of Hedera token IDs (strings) to dissociate. Must provide at least one.'),\n    accountId: z\n      .string()\n      .optional()\n      .describe(\n        'The account ID from which to dissociate the tokens. Defaults to operator account.',\n      ),\n    transactionMemo: z.string().optional().describe('Optional memo for the transaction.'),\n  });\n\nexport const dissociateTokenParametersNormalised = (_context: Context = {}) =>\n  dissociateTokenParameters(_context).extend({\n    tokenIds: z.array(z.instanceof(TokenId)),\n    accountId: z.instanceof(AccountId),\n  });\n","import { Context } from '@/shared/configuration';\nimport { z } from 'zod';\nimport { AccountId, Hbar, Key, Transaction, HbarAllowance } from '@hashgraph/sdk';\nimport BigNumber from 'bignumber.js';\nimport Long from 'long';\n\nexport const transferHbarParameters = (_context: Context = {}) =>\n  z.object({\n    transfers: z\n      .array(\n        z.object({\n          accountId: z.string().describe('Recipient account ID'),\n          amount: z.number().describe('Amount of HBAR to transfer'),\n        }),\n      )\n      .describe('Array of HBAR transfers'),\n    sourceAccountId: z.string().optional().describe('Sender account ID'),\n    transactionMemo: z.string().optional().describe('Memo to include with the transaction'),\n  });\n\nexport const transferHbarParametersNormalised = (_context: Context = {}) =>\n  z.object({\n    hbarTransfers: z.array(\n      z.object({\n        accountId: z.union([z.string(), z.instanceof(AccountId)]),\n        amount: z.union([\n          z.number(),\n          z.string(),\n          z.instanceof(Hbar),\n          z.instanceof(Long),\n          z.instanceof(BigNumber),\n        ]),\n      }),\n    ),\n    transactionMemo: z.string().optional(),\n  });\n\nexport const createAccountParameters = (_context: Context = {}) =>\n  z.object({\n    publicKey: z\n      .string()\n      .optional()\n      .describe('Account public key. If not provided, a public key of the operator will be used'),\n    accountMemo: z.string().optional().describe('Optional memo for the account'),\n    initialBalance: z\n      .number()\n      .optional()\n      .default(0)\n      .describe('Initial HBAR balance to fund the account (defaults to 0)'),\n    maxAutomaticTokenAssociations: z\n      .number()\n      .optional()\n      .default(-1)\n      .describe('Max automatic token associations (-1 for unlimited)'),\n  });\n\nexport const createAccountParametersNormalised = (_context: Context = {}) =>\n  z.object({\n    accountMemo: z.string().optional(),\n    initialBalance: z.union([z.string(), z.number()]).optional(),\n    key: z.instanceof(Key).optional(),\n    maxAutomaticTokenAssociations: z.union([z.number(), z.instanceof(Long)]).optional(),\n  });\n\nexport const deleteAccountParameters = (_context: Context = {}) =>\n  z.object({\n    accountId: z.string().describe('The account ID to delete.'),\n    transferAccountId: z\n      .string()\n      .optional()\n      .describe(\n        'The ID of the account to transfer the remaining funds to. If not provided, the operator account ID will be used.',\n      ),\n  });\n\nexport const deleteAccountParametersNormalised = (_context: Context = {}) =>\n  z.object({\n    accountId: z.instanceof(AccountId),\n    transferAccountId: z.instanceof(AccountId),\n  });\n\nexport const updateAccountParameters = (_context: Context = {}) =>\n  z.object({\n    // If not passed, will be injected from context in normalisation\n    accountId: z\n      .string()\n      .optional()\n      .describe(\n        'Account ID to update (e.g., 0.0.xxxxx). If not provided, operator account ID will be used',\n      ),\n\n    maxAutomaticTokenAssociations: z\n      .number()\n      .int()\n      .optional()\n      .describe('Max automatic token associations, positive, zero or -1 if unlimited'),\n    stakedAccountId: z.string().optional().describe('Staked account ID'),\n    accountMemo: z.string().optional().describe('Account memo'),\n    declineStakingReward: z.boolean().optional().describe('Decline staking rewards'),\n  });\n\nexport const updateAccountParametersNormalised = (_context: Context = {}) =>\n  z.object({\n    accountId: z.instanceof(AccountId),\n    maxAutomaticTokenAssociations: z.union([z.number(), z.instanceof(Long)]).optional(),\n    stakedAccountId: z.union([z.string(), z.instanceof(AccountId)]).optional(),\n    accountMemo: z.string().optional(),\n    declineStakingReward: z.boolean().optional(),\n  });\n\nexport const accountQueryParameters = (_context: Context = {}) =>\n  z.object({\n    accountId: z.string().describe('The account ID to query.'),\n  });\n\nexport const accountBalanceQueryParameters = (_context: Context = {}) =>\n  z.object({\n    accountId: z.string().optional().describe('The account ID to query.'),\n  });\n\nexport const accountTokenBalancesQueryParameters = (_context: Context = {}) =>\n  z.object({\n    accountId: z\n      .string()\n      .optional()\n      .describe('The account ID to query. If not provided, this accountId will be used.'),\n    tokenId: z.string().optional().describe('The token ID to query.'),\n  });\n\nexport const signScheduleTransactionParameters = (_context: Context = {}) =>\n  z.object({\n    scheduleId: z.string().describe('The ID of the scheduled transaction to sign'),\n  });\n\nexport const createScheduleTransactionParametersNormalised = (_context: Context = {}) =>\n  z.object({\n    scheduledTransaction: z.instanceof(Transaction),\n    params: z.object({\n      scheduleMemo: z.string().optional(),\n      adminKey: z.instanceof(Key).optional(),\n    }),\n  });\n\nexport const scheduleDeleteTransactionParameters = (_context: Context = {}) =>\n  z.object({\n    scheduleId: z.string().describe('The ID of the scheduled transaction to delete'),\n  });\n\nexport const approveHbarAllowanceParameters = (_context: Context = {}) =>\n  z.object({\n    ownerAccountId: z\n      .string()\n      .optional()\n      .describe('Owner account ID (defaults to operator account ID if omitted)'),\n    spenderAccountId: z.string().describe('Spender account ID'),\n    amount: z.number().describe('Amount of HBAR to approve as allowance (can be decimal, not negative)'),\n    transactionMemo: z.string().optional().describe('Memo to include with the transaction'),\n  });\n\nexport const approveHbarAllowanceParametersNormalised = (_context: Context = {}) =>\n  z.object({\n    hbarApprovals: z.array(z.instanceof(HbarAllowance)).optional(),\n    transactionMemo: z.string().optional(),\n  });\n","import { z } from 'zod';\nimport { Context } from '@/shared/configuration';\nimport { AccountId, PublicKey, TopicId } from '@hashgraph/sdk';\n\nexport const getTopicInfoParameters = (_context: Context = {}) => {\n  return z.object({\n    topicId: z.string().describe('The topic ID to query.'),\n  });\n};\n\nexport const createTopicParameters = (_context: Context = {}) => {\n  return z.object({\n    isSubmitKey: z\n      .boolean()\n      .optional()\n      .default(false)\n      .describe('Whether to set a submit key for the topic (optional)'),\n    topicMemo: z.string().optional().describe('Memo for the topic (optional)'),\n    transactionMemo: z\n      .string()\n      .optional()\n      .describe('An optional memo to include on the submitted transaction (optional).'),\n  });\n};\n\nexport const createTopicParametersNormalised = (_context: Context = {}) =>\n  createTopicParameters(_context).extend({\n    autoRenewAccountId: z\n      .string()\n      .describe(\n        'The auto renew account for the topic. If not provided, defaults to the operator account.',\n      ),\n    submitKey: z.custom<PublicKey>().optional().describe('The submit key of topic'),\n    adminKey: z.custom<PublicKey>().optional().describe('The admin key of topic'),\n  });\n\nexport const submitTopicMessageParameters = (_context: Context = {}) => {\n  return z.object({\n    topicId: z.string().describe('The ID of the topic to submit the message to'),\n    message: z.string().describe('The message to submit to the topic'),\n    transactionMemo: z\n      .string()\n      .optional()\n      .describe('An optional memo to include on the submitted transaction (optional).'),\n  });\n};\n\nexport const submitTopicMessageParametersNormalised = (_context: Context = {}) =>\n  submitTopicMessageParameters(_context).extend({});\n\nexport const deleteTopicParameters = (_context: Context = {}) =>\n  z.object({\n    topicId: z.string().describe('The ID of the topic to delete.'),\n  });\n\nexport const deleteTopicParametersNormalised = (_context: Context = {}) =>\n  deleteTopicParameters(_context).extend({});\n\nexport const topicMessagesQueryParameters = (_context: Context = {}) =>\n  z.object({\n    topicId: z.string().describe('The topic ID to query.'),\n    startTime: z\n      .string()\n      .datetime()\n      .optional()\n      .describe(\n        'The start time to query. If set, the messages will be returned after this timestamp.',\n      ),\n    endTime: z\n      .string()\n      .datetime()\n      .optional()\n      .describe(\n        'The end time to query. If set, the messages will be returned before this timestamp.',\n      ),\n    limit: z\n      .number()\n      .optional()\n      .describe('The limit of messages to query. If set, the number of messages to return.'),\n  });\n\nexport const updateTopicParameters = (_context: Context = {}) =>\n  z.object({\n    topicId: z.string().describe('The ID of the topic to update (e.g., 0.0.12345).'),\n    topicMemo: z.string().optional().describe('Optional new memo for the topic.'),\n    adminKey: z\n      .union([z.boolean(), z.string()])\n      .optional()\n      .describe(\n        'New admin key. Pass boolean `true` to use the operator/user key, or provide a Hedera-compatible public key string.',\n      ),\n    submitKey: z\n      .union([z.boolean(), z.string()])\n      .optional()\n      .describe(\n        'New submit key. Pass boolean `true` to use the operator/user key, or provide a Hedera-compatible public key string.',\n      ),\n    autoRenewAccountId: z\n      .string()\n      .optional()\n      .describe('Account to automatically pay for topic renewal (Hedera account ID).'),\n    autoRenewPeriod: z.number().optional().describe('Auto renew period in seconds.'),\n    expirationTime: z\n      .union([z.string(), z.instanceof(Date)])\n      .optional()\n      .describe('New expiration time for the topic (ISO string or Date).'),\n  });\n\nexport const updateTopicParametersNormalised = (_context: Context = {}) =>\n  z.object({\n    topicId: z.instanceof(TopicId),\n    topicMemo: z.string().optional(),\n    adminKey: z.instanceof(PublicKey).optional(),\n    submitKey: z.instanceof(PublicKey).optional(),\n    autoRenewAccountId: z.union([z.string(), z.instanceof(AccountId)]).optional(),\n    autoRenewPeriod: z.number().optional(),\n    expirationTime: z.instanceof(Date).optional(),\n  });\n","// optional to use methods in here\n\nimport {\n  airdropFungibleTokenParameters,\n  createFungibleTokenParameters,\n  createFungibleTokenParametersNormalised,\n  createNonFungibleTokenParameters,\n  createNonFungibleTokenParametersNormalised,\n  dissociateTokenParameters,\n  dissociateTokenParametersNormalised,\n  associateTokenParameters,\n  associateTokenParametersNormalised,\n  mintFungibleTokenParameters,\n  mintNonFungibleTokenParameters,\n  updateTokenParameters,\n  updateTokenParametersNormalised,\n\n} from '@/shared/parameter-schemas/token.zod';\nimport {\n  accountBalanceQueryParameters,\n  accountTokenBalancesQueryParameters,\n  createAccountParameters,\n  createAccountParametersNormalised,\n  deleteAccountParameters,\n  deleteAccountParametersNormalised,\n  transferHbarParameters,\n  updateAccountParameters,\n  updateAccountParametersNormalised,\n  approveHbarAllowanceParameters,\n  approveHbarAllowanceParametersNormalised,\n} from '@/shared/parameter-schemas/account.zod';\nimport {\n  createTopicParameters,\n  createTopicParametersNormalised,\n  deleteTopicParameters,\n  deleteTopicParametersNormalised,\n  updateTopicParameters,\n  updateTopicParametersNormalised,\n} from '@/shared/parameter-schemas/consensus.zod';\n\nimport {\n  AccountId,\n  Client,\n  Hbar,\n  PublicKey,\n  TokenId,\n  TokenSupplyType,\n  TokenType,\n  TopicId,\n  HbarAllowance,\n} from '@hashgraph/sdk';\nimport { Context } from '@/shared/configuration';\nimport z from 'zod';\nimport { IHederaMirrornodeService } from '@/shared/hedera-utils/mirrornode/hedera-mirrornode-service.interface';\nimport { toBaseUnit } from '@/shared/hedera-utils/decimals-utils';\nimport Long from 'long';\nimport { TokenTransferMinimalParams, TransferHbarInput } from '@/shared/hedera-utils/types';\nimport { AccountResolver } from '@/shared/utils/account-resolver';\nimport { ethers } from 'ethers';\nimport {\n  createERC20Parameters,\n  createERC721Parameters,\n  mintERC721Parameters,\n  transferERC20Parameters,\n  transferERC721Parameters,\n} from '@/shared/parameter-schemas/evm.zod';\nimport {\n  normalisedTransactionRecordQueryParameters,\n  transactionRecordQueryParameters,\n} from '@/shared/parameter-schemas/transaction.zod';\n\nexport default class HederaParameterNormaliser {\n  static parseParamsWithSchema(\n    params: any,\n    schema: any,\n    context: Context = {},\n  ): z.infer<ReturnType<typeof schema>> {\n    let parsedParams: z.infer<ReturnType<typeof schema>>;\n    try {\n      parsedParams = schema(context).parse(params);\n    } catch (e) {\n      if (e instanceof z.ZodError) {\n        const issues = this.formatZodIssues(e);\n        throw new Error(`Invalid parameters: ${issues}`);\n      }\n      throw e;\n    }\n    return parsedParams;\n  }\n\n  private static formatZodIssues(error: z.ZodError): string {\n    return error.errors.map(err => `Field \"${err.path.join('.')}\" - ${err.message}`).join('; ');\n  }\n\n  static async normaliseCreateFungibleTokenParams(\n    params: z.infer<ReturnType<typeof createFungibleTokenParameters>>,\n    context: Context,\n    client: Client,\n    mirrorNode: IHederaMirrornodeService,\n  ): Promise<z.infer<ReturnType<typeof createFungibleTokenParametersNormalised>>> {\n    const parsedParams: z.infer<ReturnType<typeof createFungibleTokenParameters>> =\n      this.parseParamsWithSchema(params, createFungibleTokenParameters, context);\n\n    const defaultAccountId = AccountResolver.getDefaultAccount(context, client);\n    const treasuryAccountId = parsedParams.treasuryAccountId ?? defaultAccountId;\n    if (!treasuryAccountId) throw new Error('Must include treasury account ID');\n\n    const initialSupply = toBaseUnit(\n      parsedParams.initialSupply ?? 0,\n      parsedParams.decimals,\n    ).toNumber();\n\n    const isFinite = (parsedParams.supplyType ?? 'infinite') === 'finite';\n    const supplyType = isFinite ? TokenSupplyType.Finite : TokenSupplyType.Infinite;\n\n    const maxSupply = isFinite\n      ? toBaseUnit(parsedParams.maxSupply ?? 1_000_000, parsedParams.decimals).toNumber() // default finite max supply\n      : undefined;\n\n    if (maxSupply !== undefined && initialSupply > maxSupply) {\n      throw new Error(`Initial supply (${initialSupply}) cannot exceed max supply (${maxSupply})`);\n    }\n\n    const publicKey =\n      (await mirrorNode.getAccount(defaultAccountId).then(r => r.accountPublicKey)) ??\n      client.operatorPublicKey?.toStringDer();\n\n    return {\n      ...parsedParams,\n      supplyType,\n      treasuryAccountId,\n      maxSupply,\n      initialSupply,\n      autoRenewAccountId: defaultAccountId,\n      supplyKey: parsedParams.isSupplyKey === true ? PublicKey.fromString(publicKey) : undefined,\n    };\n  }\n\n  static async normaliseCreateNonFungibleTokenParams(\n    params: z.infer<ReturnType<typeof createNonFungibleTokenParameters>>,\n    context: Context,\n    client: Client,\n    mirrorNode: IHederaMirrornodeService,\n  ): Promise<z.infer<ReturnType<typeof createNonFungibleTokenParametersNormalised>>> {\n    const parsedParams: z.infer<ReturnType<typeof createNonFungibleTokenParameters>> =\n      this.parseParamsWithSchema(params, createNonFungibleTokenParameters, context);\n\n    const defaultAccountId = AccountResolver.getDefaultAccount(context, client);\n    const treasuryAccountId = parsedParams.treasuryAccountId ?? defaultAccountId;\n    if (!treasuryAccountId) throw new Error('Must include treasury account ID');\n\n    const publicKey =\n      (await mirrorNode.getAccount(defaultAccountId).then(r => r.accountPublicKey)) ??\n      client.operatorPublicKey?.toStringDer();\n\n    if (!publicKey) throw new Error('Could not determine public key for supply key');\n\n    const maxSupply = parsedParams.maxSupply ?? 100;\n\n    return {\n      ...parsedParams,\n      treasuryAccountId,\n      maxSupply,\n      supplyKey: PublicKey.fromString(publicKey), // the supply key is mandatory in the case of NFT\n      supplyType: TokenSupplyType.Finite, // NFTs supply must be finite\n      autoRenewAccountId: defaultAccountId,\n      tokenType: TokenType.NonFungibleUnique,\n    };\n  }\n\n  static normaliseTransferHbar(\n    params: z.infer<ReturnType<typeof transferHbarParameters>>,\n    context: Context,\n    client: Client,\n  ) {\n    const parsedParams: z.infer<ReturnType<typeof transferHbarParameters>> =\n      this.parseParamsWithSchema(params, transferHbarParameters, context);\n\n    const sourceAccountId = AccountResolver.resolveAccount(\n      parsedParams.sourceAccountId,\n      context,\n      client,\n    );\n\n    const hbarTransfers: TransferHbarInput[] = [];\n    let totalTinybars = Long.ZERO;\n\n    for (const transfer of parsedParams.transfers) {\n      const amount = new Hbar(transfer.amount);\n\n      if (amount.isNegative() || amount.toTinybars().equals(Long.ZERO)) {\n        throw new Error(`Invalid transfer amount: ${transfer.amount}`);\n      }\n\n      totalTinybars = totalTinybars.add(amount.toTinybars());\n\n      hbarTransfers.push({\n        accountId: transfer.accountId,\n        amount,\n      });\n    }\n\n    hbarTransfers.push({\n      accountId: sourceAccountId,\n      amount: Hbar.fromTinybars(totalTinybars.negate()),\n    });\n\n    return {\n      hbarTransfers,\n      transactionMemo: parsedParams.transactionMemo,\n    };\n  }\n\n  static normaliseApproveHbarAllowance(\n    params: z.infer<ReturnType<typeof approveHbarAllowanceParameters>>,\n    context: Context,\n    client: Client,\n  ) {\n    const parsedParams: z.infer<ReturnType<typeof approveHbarAllowanceParameters>> =\n      this.parseParamsWithSchema(params, approveHbarAllowanceParameters, context);\n\n    const ownerAccountId = AccountResolver.resolveAccount(\n      parsedParams.ownerAccountId,\n      context,\n      client,\n    );\n\n    const spenderAccountId = parsedParams.spenderAccountId;\n\n    const amount = new Hbar(parsedParams.amount);\n    if (amount.isNegative()) {\n      throw new Error(`Invalid allowance amount: ${parsedParams.amount}`);\n    }\n\n    return {\n      hbarApprovals: [\n        new HbarAllowance({\n          ownerAccountId: AccountId.fromString(ownerAccountId),\n          spenderAccountId: AccountId.fromString(spenderAccountId),\n          amount,\n        }),\n      ],\n      transactionMemo: parsedParams.transactionMemo,\n    } as z.infer<ReturnType<typeof approveHbarAllowanceParametersNormalised>>;\n  }\n\n  static async normaliseAirdropFungibleTokenParams(\n    params: z.infer<ReturnType<typeof airdropFungibleTokenParameters>>,\n    context: Context,\n    client: Client,\n    mirrorNode: IHederaMirrornodeService,\n  ) {\n    const parsedParams: z.infer<ReturnType<typeof airdropFungibleTokenParameters>> =\n      this.parseParamsWithSchema(params, airdropFungibleTokenParameters, context);\n\n    const sourceAccountId = AccountResolver.resolveAccount(\n      parsedParams.sourceAccountId,\n      context,\n      client,\n    );\n\n    const tokenInfo = await mirrorNode.getTokenInfo(parsedParams.tokenId);\n    const tokenDecimals = parseInt(tokenInfo.decimals, 10);\n\n    if (isNaN(tokenDecimals)) {\n      throw new Error(`Invalid token decimals for token ${parsedParams.tokenId}`);\n    }\n\n    const tokenTransfers: TokenTransferMinimalParams[] = [];\n    let totalAmount = Long.ZERO;\n\n    for (const recipient of parsedParams.recipients) {\n      const amountRaw = Number(recipient.amount);\n\n      if (amountRaw <= 0) {\n        throw new Error(`Invalid recipient amount: ${recipient.amount}`);\n      }\n\n      const amount = Long.fromString(toBaseUnit(amountRaw, tokenDecimals).toNumber().toString());\n\n      totalAmount = totalAmount.add(amount);\n\n      tokenTransfers.push({\n        tokenId: parsedParams.tokenId,\n        accountId: recipient.accountId,\n        amount,\n      });\n    }\n\n    // Sender negative total\n    tokenTransfers.push({\n      tokenId: parsedParams.tokenId,\n      accountId: sourceAccountId,\n      amount: totalAmount.negate(),\n    });\n\n    return {\n      tokenTransfers,\n    };\n  }\n\n\n  static normaliseAssociateTokenParams(\n    params: z.infer<ReturnType<typeof associateTokenParameters>>,\n    context: Context,\n    client: Client,\n  ): z.infer<ReturnType<typeof associateTokenParametersNormalised>> {\n    const parsedParams: z.infer<ReturnType<typeof associateTokenParameters>> =\n      this.parseParamsWithSchema(params, associateTokenParameters, context);\n\n    const accountId = AccountResolver.resolveAccount(parsedParams.accountId, context, client);\n    return {\n      accountId,\n      tokenIds: parsedParams.tokenIds,\n    };\n  }\n\n  static async normaliseDissociateTokenParams(\n    params: z.infer<ReturnType<typeof dissociateTokenParameters>>,\n    context: Context,\n    client: Client,\n  ): Promise<z.infer<ReturnType<typeof dissociateTokenParametersNormalised>>> {\n    const parsedParams: z.infer<ReturnType<typeof dissociateTokenParameters>> =\n      this.parseParamsWithSchema(params, dissociateTokenParameters, context);\n\n    if (parsedParams.accountId === undefined) {\n      parsedParams.accountId = AccountResolver.getDefaultAccount(context, client);\n\n      if (!parsedParams.accountId) {\n        throw new Error('Could not determine default account ID');\n      }\n    }\n\n    return {\n      ...parsedParams,\n      accountId: AccountId.fromString(parsedParams.accountId),\n      tokenIds: parsedParams.tokenIds.map(id => TokenId.fromString(id)),\n    };\n  }\n\n  static async normaliseCreateTopicParams(\n    params: z.infer<ReturnType<typeof createTopicParameters>>,\n    context: Context,\n    client: Client,\n    mirrorNode: IHederaMirrornodeService,\n  ): Promise<z.infer<ReturnType<typeof createTopicParametersNormalised>>> {\n    const parsedParams: z.infer<ReturnType<typeof createTopicParameters>> =\n      this.parseParamsWithSchema(params, createTopicParameters, context);\n\n    const defaultAccountId = AccountResolver.getDefaultAccount(context, client);\n    if (!defaultAccountId) throw new Error('Could not determine default account ID');\n\n    const normalised: z.infer<ReturnType<typeof createTopicParametersNormalised>> = {\n      ...parsedParams,\n      autoRenewAccountId: defaultAccountId,\n    };\n\n    if (parsedParams.isSubmitKey) {\n      const publicKey =\n        (await mirrorNode.getAccount(defaultAccountId).then(r => r.accountPublicKey)) ??\n        client.operatorPublicKey?.toStringDer();\n      if (!publicKey) {\n        throw new Error('Could not determine public key for submit key');\n      }\n      normalised.submitKey = PublicKey.fromString(publicKey);\n    }\n\n    return normalised;\n  }\n\n  static normaliseDeleteTopic(\n    params: z.infer<ReturnType<typeof deleteTopicParameters>>,\n    context: Context,\n    _client: Client,\n    _mirrorNode: IHederaMirrornodeService,\n  ): z.infer<ReturnType<typeof deleteTopicParametersNormalised>> {\n    // First, validate against the basic schema\n    const parsedParams: z.infer<ReturnType<typeof deleteTopicParameters>> =\n      this.parseParamsWithSchema(params, deleteTopicParameters, context);\n\n    // Then, validate against the normalized schema delete topic schema\n    return this.parseParamsWithSchema(parsedParams, deleteTopicParametersNormalised, context);\n  }\n\n  static normaliseUpdateTopic = async (\n    params: z.infer<ReturnType<typeof updateTopicParameters>>,\n    context: Context,\n    client: Client,\n  ): Promise<z.infer<ReturnType<typeof updateTopicParametersNormalised>>> => {\n    const parsedParams: z.infer<ReturnType<typeof updateTopicParameters>> =\n      this.parseParamsWithSchema(params, updateTopicParameters, context);\n\n    const topicId = TopicId.fromString(parsedParams.topicId);\n    const userPublicKey = await AccountResolver.getDefaultPublicKey(context, client);\n\n    const normalised: z.infer<ReturnType<typeof updateTopicParametersNormalised>> = {\n      topicId,\n    } as any;\n\n    // Keys\n    const maybeKeys: Record<string, string | boolean | undefined> = {\n      adminKey: parsedParams.adminKey,\n      submitKey: parsedParams.submitKey,\n    };\n\n    for (const [field, rawVal] of Object.entries(maybeKeys)) {\n      const resolved = this.resolveKey(rawVal, userPublicKey);\n      if (resolved) {\n        (normalised as any)[field] = resolved;\n      }\n    }\n\n    // Other optional props\n    if (parsedParams.topicMemo) normalised.topicMemo = parsedParams.topicMemo;\n    if (parsedParams.autoRenewAccountId)\n      normalised.autoRenewAccountId = parsedParams.autoRenewAccountId;\n    if (parsedParams.autoRenewPeriod) normalised.autoRenewPeriod = parsedParams.autoRenewPeriod;\n    if (parsedParams.expirationTime) {\n      normalised.expirationTime =\n        parsedParams.expirationTime instanceof Date\n          ? parsedParams.expirationTime\n          : new Date(parsedParams.expirationTime);\n    }\n\n    return normalised;\n  };\n\n  static async normaliseCreateAccount(\n    params: z.infer<ReturnType<typeof createAccountParameters>>,\n    context: Context,\n    client: Client,\n    mirrorNode: IHederaMirrornodeService,\n  ): Promise<z.infer<ReturnType<typeof createAccountParametersNormalised>>> {\n    const parsedParams: z.infer<ReturnType<typeof createAccountParameters>> =\n      this.parseParamsWithSchema(params, createAccountParameters, context);\n\n    // Try resolving the publicKey in priority order\n    let publicKey = parsedParams.publicKey ?? client.operatorPublicKey?.toStringDer();\n\n    if (!publicKey) {\n      const defaultAccountId = AccountResolver.getDefaultAccount(context, client);\n      if (defaultAccountId) {\n        const account = await mirrorNode.getAccount(defaultAccountId);\n        publicKey = account?.accountPublicKey;\n      }\n    }\n\n    if (!publicKey) {\n      throw new Error(\n        'Unable to resolve public key: no param, mirror node, or client operator key available.',\n      );\n    }\n\n    return {\n      ...parsedParams,\n      key: PublicKey.fromString(publicKey),\n    };\n  }\n\n  static normaliseHbarBalanceParams(\n    params: z.infer<ReturnType<typeof accountBalanceQueryParameters>>,\n    context: Context,\n    client: Client,\n  ) {\n    const parsedParams: z.infer<ReturnType<typeof accountBalanceQueryParameters>> =\n      this.parseParamsWithSchema(params, accountBalanceQueryParameters, context);\n\n    const accountId = AccountResolver.resolveAccount(parsedParams.accountId, context, client);\n    return {\n      ...parsedParams,\n      accountId,\n    };\n  }\n\n  static normaliseAccountTokenBalancesParams(\n    params: z.infer<ReturnType<typeof accountTokenBalancesQueryParameters>>,\n    context: Context,\n    client: Client,\n  ) {\n    const parsedParams: z.infer<ReturnType<typeof accountTokenBalancesQueryParameters>> =\n      this.parseParamsWithSchema(params, accountTokenBalancesQueryParameters, context);\n\n    const accountId = AccountResolver.resolveAccount(parsedParams.accountId, context, client);\n    return {\n      ...parsedParams,\n      accountId,\n    };\n  }\n\n  static normaliseCreateERC20Params(\n    params: z.infer<ReturnType<typeof createERC20Parameters>>,\n    factoryContractId: string,\n    factoryContractAbi: string[],\n    factoryContractFunctionName: string,\n    context: Context,\n  ) {\n    const parsedParams: z.infer<ReturnType<typeof createERC20Parameters>> =\n      this.parseParamsWithSchema(params, createERC20Parameters, context);\n\n    // Create an interface for encoding\n    const iface = new ethers.Interface(factoryContractAbi);\n\n    // Encode the function call\n    const encodedData = iface.encodeFunctionData(factoryContractFunctionName, [\n      parsedParams.tokenName,\n      parsedParams.tokenSymbol,\n      parsedParams.decimals,\n      parsedParams.initialSupply,\n    ]);\n\n    const functionParameters = ethers.getBytes(encodedData);\n\n    return {\n      ...parsedParams,\n      contractId: factoryContractId,\n      functionParameters,\n      gas: 3000000, //TODO: make this configurable\n    };\n  }\n\n  static normaliseCreateERC721Params(\n    params: z.infer<ReturnType<typeof createERC721Parameters>>,\n    factoryContractId: string,\n    factoryContractAbi: string[],\n    factoryContractFunctionName: string,\n    context: Context,\n  ) {\n    const parsedParams: z.infer<ReturnType<typeof createERC721Parameters>> =\n      this.parseParamsWithSchema(params, createERC721Parameters, context);\n\n    // Create an interface for encoding\n    const iface = new ethers.Interface(factoryContractAbi);\n\n    // Encode the function call\n    const encodedData = iface.encodeFunctionData(factoryContractFunctionName, [\n      parsedParams.tokenName,\n      parsedParams.tokenSymbol,\n      parsedParams.baseURI,\n    ]);\n\n    const functionParameters = ethers.getBytes(encodedData);\n\n    return {\n      ...parsedParams,\n      contractId: factoryContractId,\n      functionParameters,\n      gas: 3000000, //TODO: make this configurable\n    };\n  }\n\n  static async normaliseMintFungibleTokenParams(\n    params: z.infer<ReturnType<typeof mintFungibleTokenParameters>>,\n    context: Context,\n    mirrorNode: IHederaMirrornodeService,\n  ) {\n    const parsedParams: z.infer<ReturnType<typeof mintFungibleTokenParameters>> =\n      this.parseParamsWithSchema(params, mintFungibleTokenParameters, context);\n\n    const tokenInfo = await mirrorNode.getTokenInfo(parsedParams.tokenId);\n    const decimals = Number(tokenInfo.decimals);\n\n    // Fallback to 0 if decimals are missing or NaN\n    const safeDecimals = Number.isFinite(decimals) ? decimals : 0;\n\n    const baseAmount = toBaseUnit(parsedParams.amount, safeDecimals).toNumber();\n    return {\n      tokenId: parsedParams.tokenId,\n      amount: baseAmount,\n    };\n  }\n\n  static normaliseMintNonFungibleTokenParams(\n    params: z.infer<ReturnType<typeof mintNonFungibleTokenParameters>>,\n    context: Context,\n  ) {\n    const parsedParams: z.infer<ReturnType<typeof mintNonFungibleTokenParameters>> =\n      this.parseParamsWithSchema(params, mintNonFungibleTokenParameters, context);\n\n    const encoder = new TextEncoder();\n    const metadata = parsedParams.uris.map(uri => encoder.encode(uri));\n    return {\n      ...parsedParams,\n      metadata: metadata,\n    };\n  }\n\n  static async normaliseTransferERC20Params(\n    params: z.infer<ReturnType<typeof transferERC20Parameters>>,\n    factoryContractAbi: string[],\n    factoryContractFunctionName: string,\n    context: Context,\n    mirrorNode: IHederaMirrornodeService,\n  ) {\n    const parsedParams: z.infer<ReturnType<typeof transferERC20Parameters>> =\n      this.parseParamsWithSchema(params, transferERC20Parameters, context);\n\n    const recipientAddress = await AccountResolver.getHederaEVMAddress(\n      parsedParams.recipientAddress,\n      mirrorNode,\n    );\n    const contractId = await HederaParameterNormaliser.getHederaAccountId(\n      parsedParams.contractId,\n      mirrorNode,\n    );\n    const iface = new ethers.Interface(factoryContractAbi);\n    const encodedData = iface.encodeFunctionData(factoryContractFunctionName, [\n      recipientAddress,\n      parsedParams.amount,\n    ]);\n\n    const functionParameters = ethers.getBytes(encodedData);\n\n    return {\n      contractId,\n      functionParameters,\n      gas: 100_000,\n    };\n  }\n\n  static async normaliseTransferERC721Params(\n    params: z.infer<ReturnType<typeof transferERC721Parameters>>,\n    factoryContractAbi: string[],\n    factoryContractFunctionName: string,\n    context: Context,\n    mirrorNode: IHederaMirrornodeService,\n    client: Client,\n  ) {\n    const parsedParams: z.infer<ReturnType<typeof transferERC721Parameters>> =\n      this.parseParamsWithSchema(params, transferERC721Parameters, context);\n\n    // Resolve fromAddress using AccountResolver pattern, similar to transfer-hbar\n    const resolvedFromAddress = AccountResolver.resolveAccount(\n      parsedParams.fromAddress,\n      context,\n      client,\n    );\n    const fromAddress = await AccountResolver.getHederaEVMAddress(resolvedFromAddress, mirrorNode);\n    const toAddress = await AccountResolver.getHederaEVMAddress(parsedParams.toAddress, mirrorNode);\n    const contractId = await HederaParameterNormaliser.getHederaAccountId(\n      parsedParams.contractId,\n      mirrorNode,\n    );\n    const iface = new ethers.Interface(factoryContractAbi);\n    const encodedData = iface.encodeFunctionData(factoryContractFunctionName, [\n      fromAddress,\n      toAddress,\n      parsedParams.tokenId,\n    ]);\n\n    const functionParameters = ethers.getBytes(encodedData);\n\n    return {\n      contractId,\n      functionParameters,\n      gas: 100_000,\n    };\n  }\n\n  static async normaliseMintERC721Params(\n    params: z.infer<ReturnType<typeof mintERC721Parameters>>,\n    factoryContractAbi: string[],\n    factoryContractFunctionName: string,\n    context: Context,\n    mirrorNode: IHederaMirrornodeService,\n    client: Client,\n  ) {\n    const parsedParams: z.infer<ReturnType<typeof mintERC721Parameters>> =\n      this.parseParamsWithSchema(params, mintERC721Parameters, context);\n\n    const resolvedToAddress = AccountResolver.resolveAccount(\n      parsedParams.toAddress,\n      context,\n      client,\n    );\n    const toAddress = await AccountResolver.getHederaEVMAddress(resolvedToAddress, mirrorNode);\n    const contractId = await HederaParameterNormaliser.getHederaAccountId(\n      parsedParams.contractId,\n      mirrorNode,\n    );\n    const iface = new ethers.Interface(factoryContractAbi);\n    const encodedData = iface.encodeFunctionData(factoryContractFunctionName, [toAddress]);\n    const functionParameters = ethers.getBytes(encodedData);\n\n    return {\n      contractId,\n      functionParameters,\n      gas: 100_000,\n    };\n  }\n\n  static normaliseDeleteAccount(\n    params: z.infer<ReturnType<typeof deleteAccountParameters>>,\n    context: Context,\n    client: Client,\n  ): z.infer<ReturnType<typeof deleteAccountParametersNormalised>> {\n    const parsedParams: z.infer<ReturnType<typeof deleteAccountParameters>> =\n      this.parseParamsWithSchema(params, deleteAccountParameters, context);\n\n    if (!AccountResolver.isHederaAddress(parsedParams.accountId)) {\n      throw new Error('Account ID must be a Hedera address');\n    }\n\n    // if no transfer account ID is provided, use the operator account ID\n    const transferAccountId =\n      parsedParams.transferAccountId ?? AccountResolver.getDefaultAccount(context, client);\n    if (!transferAccountId) {\n      throw new Error('Could not determine transfer account ID');\n    }\n\n    return {\n      accountId: AccountId.fromString(parsedParams.accountId),\n      transferAccountId: AccountId.fromString(transferAccountId),\n    };\n  }\n\n  static normaliseUpdateAccount(\n    params: z.infer<ReturnType<typeof updateAccountParameters>>,\n    context: Context,\n    client: Client,\n  ): z.infer<ReturnType<typeof updateAccountParametersNormalised>> {\n    const parsedParams: z.infer<ReturnType<typeof updateAccountParameters>> =\n      this.parseParamsWithSchema(params, updateAccountParameters, context);\n\n    const accountId = AccountId.fromString(\n      AccountResolver.resolveAccount(parsedParams.accountId, context, client),\n    );\n\n    const normalised: z.infer<ReturnType<typeof updateAccountParametersNormalised>> = {\n      accountId,\n    } as any;\n\n    if (parsedParams.maxAutomaticTokenAssociations !== undefined) {\n      normalised.maxAutomaticTokenAssociations = parsedParams.maxAutomaticTokenAssociations;\n    }\n    if (parsedParams.stakedAccountId !== undefined) {\n      normalised.stakedAccountId = parsedParams.stakedAccountId;\n    }\n    if (parsedParams.accountMemo !== undefined) {\n      normalised.accountMemo = parsedParams.accountMemo;\n    }\n    if (parsedParams.declineStakingReward !== undefined) {\n      normalised.declineStakingReward = parsedParams.declineStakingReward;\n    }\n\n    return normalised;\n  }\n\n  static normaliseGetTransactionRecordParams(\n    params: z.infer<ReturnType<typeof transactionRecordQueryParameters>>,\n    context: Context,\n  ): z.infer<ReturnType<typeof normalisedTransactionRecordQueryParameters>> {\n    const parsedParams: z.infer<ReturnType<typeof transactionRecordQueryParameters>> =\n      this.parseParamsWithSchema(params, transactionRecordQueryParameters, context);\n\n    const normalised: z.infer<ReturnType<typeof normalisedTransactionRecordQueryParameters>> = {\n      nonce: parsedParams.nonce,\n    } as any;\n\n    if (!parsedParams.transactionId) {\n      throw new Error('transactionId is required');\n    }\n\n    const mirrorNodeStyleRegex = /^\\d+\\.\\d+\\.\\d+-\\d+-\\d+$/;\n    const sdkStyleRegex = /^(\\d+\\.\\d+\\.\\d+)@(\\d+)\\.(\\d+)$/;\n\n    if (mirrorNodeStyleRegex.test(parsedParams.transactionId)) {\n      // Already in mirror-node style, use as-is\n      normalised.transactionId = parsedParams.transactionId;\n    } else {\n      const match = parsedParams.transactionId.match(sdkStyleRegex);\n      if (!match) {\n        throw new Error(`Invalid transactionId format: ${parsedParams.transactionId}`);\n      }\n\n      const [, accountId, seconds, nanos] = match;\n      normalised.transactionId = `${accountId}-${seconds}-${nanos}`;\n    }\n\n    return normalised;\n  }\n\n  static async getHederaAccountId(\n    address: string,\n    mirrorNode: IHederaMirrornodeService,\n  ): Promise<string> {\n    if (AccountResolver.isHederaAddress(address)) {\n      return address;\n    }\n    const account = await mirrorNode.getAccount(address);\n    return account.accountId;\n  }\n\n  static async normaliseUpdateToken(\n    params: z.infer<ReturnType<typeof updateTokenParameters>>,\n    context: Context,\n    client: Client,\n  ): Promise<z.infer<ReturnType<typeof updateTokenParametersNormalised>>> {\n    const parsedParams: z.infer<ReturnType<typeof updateTokenParameters>> =\n      this.parseParamsWithSchema(params, updateTokenParameters, context);\n\n    const tokenId = TokenId.fromString(parsedParams.tokenId);\n    const userPublicKey = await AccountResolver.getDefaultPublicKey(context, client);\n\n    const normalised: z.infer<ReturnType<typeof updateTokenParametersNormalised>> = {\n      tokenId,\n    };\n\n    // Keys\n    const maybeKeys: Record<string, string | boolean | undefined> = {\n      adminKey: parsedParams.adminKey,\n      supplyKey: parsedParams.supplyKey,\n      wipeKey: parsedParams.wipeKey,\n      freezeKey: parsedParams.freezeKey,\n      kycKey: parsedParams.kycKey,\n      feeScheduleKey: parsedParams.feeScheduleKey,\n      pauseKey: parsedParams.pauseKey,\n      metadataKey: parsedParams.metadataKey,\n    };\n\n    for (const [field, rawVal] of Object.entries(maybeKeys)) {\n      const resolved = this.resolveKey(rawVal, userPublicKey);\n      if (resolved) {\n        (normalised as any)[field] = resolved;\n      }\n    }\n\n    // Other optional props\n    if (parsedParams.tokenName) {\n      normalised.tokenName = parsedParams.tokenName;\n    }\n    if (parsedParams.tokenSymbol) {\n      normalised.tokenSymbol = parsedParams.tokenSymbol;\n    }\n    if (parsedParams.treasuryAccountId) {\n      normalised.treasuryAccountId = parsedParams.treasuryAccountId;\n    }\n    if (parsedParams.tokenMemo) {\n      normalised.tokenMemo = parsedParams.tokenMemo;\n    }\n    if (parsedParams.metadata) {\n      normalised.metadata = new TextEncoder().encode(parsedParams.metadata);\n    }\n    if (parsedParams.autoRenewAccountId) {\n      normalised.autoRenewAccountId = parsedParams.autoRenewAccountId;\n    }\n\n    return normalised;\n  }\n  \n  private static resolveKey(\n    rawValue: string | boolean | undefined,\n    userKey: PublicKey,\n  ): PublicKey | undefined {\n    if (rawValue === undefined) return undefined;\n    if (typeof rawValue === 'string') {\n      // we do not get the info what type of key the user is passing, so we try both ED25519 and ECDSA\n      try {\n        return PublicKey.fromStringED25519(rawValue);\n      } catch {\n        return PublicKey.fromStringECDSA(rawValue);\n      }\n    }\n    if (rawValue) {\n      return userKey;\n    }\n    return undefined;\n  };\n\n}\n","import BigNumber from 'bignumber.js';\n\n/**\n * Converts a token amount to base units (the smallest denomination).\n * Example: toBaseUnit(1.5, 8) => BigNumber(150000000)\n *\n * @param amount - The human-readable token amount (number or BigNumber).\n * @param decimals - The number of decimals the token uses.\n * @returns The amount in base units as BigNumber.\n */\nexport function toBaseUnit(amount: number | BigNumber, decimals: number): BigNumber {\n  const amountBN = new BigNumber(amount);\n  const multiplier = new BigNumber(10).pow(decimals);\n  return amountBN.multipliedBy(multiplier).integerValue(BigNumber.ROUND_FLOOR);\n}\n\n/**\n * Converts a base unit amount to a human-readable value.\n * Example: toDisplayUnit(150000000, 8) => BigNumber(1.5)\n *\n * @param baseAmount - The amount in base units (number or BigNumber).\n * @param decimals - The number of decimals the token uses.\n * @returns The human-readable token amount as BigNumber.\n */\nexport function toDisplayUnit(baseAmount: number | BigNumber, decimals: number): BigNumber {\n  const baseAmountBN = new BigNumber(baseAmount);\n  const divisor = new BigNumber(10).pow(decimals);\n  return baseAmountBN.dividedBy(divisor);\n}\n","import { Client, PublicKey } from '@hashgraph/sdk';\nimport { Context, AgentMode } from '@/shared/configuration';\nimport { IHederaMirrornodeService } from '@/shared/hedera-utils/mirrornode/hedera-mirrornode-service.interface';\n\nexport class AccountResolver {\n  /**\n   * Gets the default account based on the agent mode and context.\n   * In RETURN_BYTES mode, prefers context.accountId (user's account).\n   * In AUTONOMOUS mode or when no context account, uses an operator account.\n   */\n  static getDefaultAccount(context: Context, client: Client): string {\n    // Prefer context.accountId (user's account) if it is set\n    if(context.accountId) {\n      return context.accountId;\n    }\n\n    // Use operator account if context.accountId is not set\n    const operatorAccount = client.operatorAccountId?.toString();\n    if (!operatorAccount) {\n      throw new Error('No account available: neither context.accountId nor operator account');\n    }\n\n    return operatorAccount;\n  }\n\n  static async getDefaultPublicKey(context: Context, client: Client): Promise<PublicKey> {\n    if (context.mode === AgentMode.AUTONOMOUS) {\n      return client.operatorPublicKey!;\n    }\n\n    const defaultAccount = this.getDefaultAccount(context, client);\n    const defaultAccountDetails = await context.mirrornodeService?.getAccount(defaultAccount);\n\n    if (!defaultAccountDetails?.accountPublicKey) {\n      throw new Error('No public key available for the default account');\n    }\n\n    return PublicKey.fromString(defaultAccountDetails.accountPublicKey);\n  }\n\n  /**\n   * Resolves an account ID, using the provided account or falling back to the default.\n   */\n  static resolveAccount(\n    providedAccount: string | undefined,\n    context: Context,\n    client: Client,\n  ): string {\n    return providedAccount || this.getDefaultAccount(context, client);\n  }\n\n  /**\n   * Gets a description of which account will be used as default for prompts.\n   */\n  static getDefaultAccountDescription(context: Context): string {\n    if (context.mode === AgentMode.RETURN_BYTES && context.accountId) {\n      return `user account (${context.accountId})`;\n    }\n    return 'operator account';\n  }\n\n  static isHederaAddress(address: string): boolean {\n    return address.startsWith('0.') || address.startsWith('0.0.');\n  }\n\n  static async getHederaEVMAddress(\n    address: string,\n    mirrorNode: IHederaMirrornodeService,\n  ): Promise<string> {\n    if (!AccountResolver.isHederaAddress(address)) {\n      return address;\n    }\n    const account = await mirrorNode.getAccount(address);\n    return account.evmAddress;\n  }\n}\n","import { Context } from '@/shared/configuration';\nimport { z } from 'zod';\n\nexport const contractExecuteTransactionParametersNormalised = (_context: Context = {}) =>\n  z.object({\n    contractId: z.string().describe('The ID of the contract to execute.'),\n    functionParameters: z\n      .instanceof(Uint8Array<ArrayBufferLike>)\n      .describe('The parameters of the function to execute.'),\n    gas: z.number().int().describe('The gas limit for the contract call.'),\n  });\n\nexport const transferERC20Parameters = (_context: Context = {}) =>\n  z.object({\n    contractId: z.string().describe('The id of the ERC20 contract.'),\n    recipientAddress: z.string().describe('Address to which the tokens will be transferred.'),\n    amount: z.number().describe('The amount of tokens to transfer.'),\n  });\n\nexport const createERC721Parameters = (_context: Context = {}) =>\n  z.object({\n    tokenName: z.string().describe('The name of the token.'),\n    tokenSymbol: z.string().describe('The symbol of the token.'),\n    baseURI: z.string().default('').describe('The base URI for token metadata.'),\n  });\n\nexport const createERC20Parameters = (_context: Context = {}) =>\n  z.object({\n    tokenName: z.string().describe('The name of the token.'),\n    tokenSymbol: z.string().describe('The symbol of the token.'),\n    decimals: z\n      .number()\n      .int()\n      .min(0)\n      .optional()\n      .default(18)\n      .describe('The number of decimals the token supports.'),\n    initialSupply: z\n      .number()\n      .int()\n      .min(0)\n      .optional()\n      .default(0)\n      .describe('The initial supply of the token.'),\n  });\n\nexport const transferERC721Parameters = (_context: Context = {}) =>\n  z.object({\n    contractId: z.string().describe('The id of the ERC721 contract.'),\n    fromAddress: z\n      .string()\n      .optional()\n      .describe('Address from which the token will be transferred.'),\n    toAddress: z.string().describe('Address to which the token will be transferred.'),\n    tokenId: z.number().describe('The ID of the token to transfer.'),\n  });\n\nexport const mintERC721Parameters = (_context: Context = {}) =>\n  z.object({\n    contractId: z.string().describe('The id of the ERC721 contract.'),\n    toAddress: z.string().optional().describe('Address to which the token will be minted.'),\n  });\n\nexport const contractInfoQueryParameters = (_context: Context = {}) =>\n  z.object({\n    contractId: z.string().describe('The token ID to query.'),\n  });\n","import { Context } from '@/shared';\nimport { z } from 'zod';\n\nexport const transactionRecordQueryParameters = (_context: Context = {}) => {\n  return z.object({\n    transactionId: z\n      .string()\n      .describe(\n        'The transaction ID to fetch details for. Should be in format \\\\\"shard.realm.num-sss-nnn\\\\\" format where sss are seconds and nnn are nanoseconds',\n      ),\n    nonce: z\n      .number()\n      .nonnegative()\n      .optional()\n      .describe('Optional nonnegative nonce value for the transaction'),\n  });\n};\n\nexport const normalisedTransactionRecordQueryParameters = (_context: Context = {}) =>\n  transactionRecordQueryParameters(_context).extend({});\n","import { z } from 'zod';\nimport type { Context } from '@/shared/configuration';\nimport type { Tool } from '@/shared/tools';\nimport HederaParameterNormaliser from '@/shared/hedera-utils/hedera-parameter-normaliser';\nimport { Client, Status } from '@hashgraph/sdk';\nimport { handleTransaction, RawTransactionResponse } from '@/shared/strategies/tx-mode-strategy';\nimport { airdropFungibleTokenParameters } from '@/shared/parameter-schemas/token.zod';\nimport HederaBuilder from '@/shared/hedera-utils/hedera-builder';\nimport { getMirrornodeService } from '@/shared/hedera-utils/mirrornode/hedera-mirrornode-utils';\nimport { PromptGenerator } from '@/shared/utils/prompt-generator';\n\nconst airdropFungibleTokenPrompt = (context: Context = {}) => {\n  const contextSnippet = PromptGenerator.getContextSnippet(context);\n  const sourceAccountDesc = PromptGenerator.getAccountParameterDescription(\n    'sourceAccountId',\n    context,\n  );\n  const usageInstructions = PromptGenerator.getParameterUsageInstructions();\n\n  return `\n${contextSnippet}\n\nThis tool will airdrop a fungible token on Hedera.\n\nParameters:\n- tokenId (str, required): The id of the token\n- ${sourceAccountDesc}\n- recipients (array, required): A list of recipient objects, each containing:\n  - accountId (string): The recipient's account ID (e.g., \"0.0.1234\")\n  - amount (number or string): The amount of tokens to send to that recipient (in base units)\n- transactionMemo (str, optional): Optional memo for the transaction\n${usageInstructions}\n\nIf the user specifies multiple recipients in a single request, include them all in **one tool call** as a list of recipients.\n`;\n};\n\nconst postProcess = (response: RawTransactionResponse) => {\n  return `Token successfully airdropped with transaction id ${response.transactionId.toString()}`;\n};\n\nconst airdropFungibleToken = async (\n  client: Client,\n  context: Context,\n  params: z.infer<ReturnType<typeof airdropFungibleTokenParameters>>,\n) => {\n  try {\n    const mirrornodeService = getMirrornodeService(context.mirrornodeService!, client.ledgerId!);\n    const normalisedParams = await HederaParameterNormaliser.normaliseAirdropFungibleTokenParams(\n      params,\n      context,\n      client,\n      mirrornodeService,\n    );\n    const tx = HederaBuilder.airdropFungibleToken(normalisedParams);\n    const result = await handleTransaction(tx, client, context, postProcess);\n    return result;\n  } catch (error) {\n    const desc = 'Failed to airdrop fungible token';\n    const message = desc + (error instanceof Error ? `: ${error.message}` : '');\n    console.error('[airdrop_fungible_token_tool]', message);\n    return { raw: { status: Status.InvalidTransaction, error: message }, humanMessage: message };\n  }\n};\n\nexport const AIRDROP_FUNGIBLE_TOKEN_TOOL = 'airdrop_fungible_token_tool';\n\nconst tool = (context: Context): Tool => ({\n  method: AIRDROP_FUNGIBLE_TOKEN_TOOL,\n  name: 'Airdrop Fungible Token',\n  description: airdropFungibleTokenPrompt(context),\n  parameters: airdropFungibleTokenParameters(context),\n  execute: airdropFungibleToken,\n});\n\nexport default tool;\n","import { AccountId, Client, ScheduleId, TokenId, TopicId, Transaction, TransactionId } from '@hashgraph/sdk';\nimport { AgentMode, Context } from '@/shared/configuration';\n\ninterface TxModeStrategy {\n  handle<T extends Transaction>(\n    tx: T,\n    client: Client,\n    context: Context,\n    postProcess?: (response: RawTransactionResponse) => unknown,\n  ): Promise<unknown>;\n}\n\nexport interface RawTransactionResponse {\n  status: string;\n  accountId: AccountId | null;\n  tokenId: TokenId | null;\n  transactionId: string;\n  topicId: TopicId | null;\n  scheduleId: ScheduleId | null;\n}\n\nexport interface ExecuteStrategyResult {\n  raw: RawTransactionResponse;\n  humanMessage: string;\n}\n\nexport class ExecuteStrategy implements TxModeStrategy {\n  defaultPostProcess(response: RawTransactionResponse): string {\n    return JSON.stringify(response, null, 2);\n  }\n\n  async handle(\n    tx: Transaction,\n    client: Client,\n    _context: Context,\n    postProcess: (response: RawTransactionResponse) => string = this.defaultPostProcess,\n  ) {\n    const submit = await tx.execute(client);\n    const receipt = await submit.getReceipt(client);\n    const rawTransactionResponse: RawTransactionResponse = {\n      status: receipt.status.toString(),\n      accountId: receipt.accountId,\n      tokenId: receipt.tokenId,\n      transactionId: tx.transactionId?.toString() ?? '',\n      topicId: receipt.topicId,\n      scheduleId: receipt.scheduleId,\n    };\n    return {\n      raw: rawTransactionResponse,\n      humanMessage: postProcess(rawTransactionResponse),\n    };\n  }\n}\n\nclass ReturnBytesStrategy implements TxModeStrategy {\n  async handle(tx: Transaction, _client: Client, context: Context) {\n    if (!context.accountId) throw new Error('…');\n    const id = TransactionId.generate(context.accountId);\n    tx.setNodeAccountIds([new AccountId(4), new AccountId(5)])\n      .setTransactionId(id)\n      .freeze();\n    return { bytes: tx.toBytes() };\n  }\n}\n\nconst getStrategyFromContext = (context: Context) => {\n  if (context.mode === AgentMode.RETURN_BYTES) {\n    return new ReturnBytesStrategy();\n  }\n  return new ExecuteStrategy();\n};\n\nexport const handleTransaction = async (\n  tx: Transaction,\n  client: Client,\n  context: Context,\n  postProcess?: (response: RawTransactionResponse) => string,\n) => {\n  const strategy = getStrategyFromContext(context);\n  return await strategy.handle(tx, client, context, postProcess);\n};\n","import {\n  TokenAirdropTransaction,\n  TokenCreateTransaction,\n  TokenDeleteTransaction,\n  TopicCreateTransaction,\n  TopicDeleteTransaction,\n  TopicMessageSubmitTransaction,\n  TransferTransaction,\n  ContractExecuteTransaction,\n  TokenMintTransaction,\n  TokenAssociateTransaction,\n  AccountCreateTransaction,\n  AccountDeleteTransaction,\n  AccountUpdateTransaction,\n  ScheduleSignTransaction,\n  ScheduleCreateTransaction,\n  TokenUpdateTransaction,\n  ScheduleDeleteTransaction,\n  TokenDissociateTransaction,\n  TopicUpdateTransaction,\n  AccountId,\n  TokenId,\n  AccountAllowanceApproveTransaction,\n} from '@hashgraph/sdk';\nimport {\n  airdropFungibleTokenParametersNormalised,\n  associateTokenParametersNormalised,\n  createFungibleTokenParametersNormalised,\n  createNonFungibleTokenParametersNormalised,\n  deleteTokenParametersNormalised,\n  dissociateTokenParametersNormalised,\n  mintFungibleTokenParametersNormalised,\n  mintNonFungibleTokenParametersNormalised,\n  updateTokenParametersNormalised,\n} from '@/shared/parameter-schemas/token.zod';\nimport z from 'zod';\nimport {\n  createAccountParametersNormalised,\n  deleteAccountParametersNormalised,\n  transferHbarParametersNormalised,\n  updateAccountParametersNormalised,\n  createScheduleTransactionParametersNormalised,\n  signScheduleTransactionParameters,\n  scheduleDeleteTransactionParameters,\n  approveHbarAllowanceParametersNormalised,\n} from '@/shared/parameter-schemas/account.zod';\nimport {\n  createTopicParametersNormalised,\n  deleteTopicParametersNormalised,\n  submitTopicMessageParametersNormalised,\n  updateTopicParametersNormalised,\n} from '@/shared/parameter-schemas/consensus.zod';\nimport { contractExecuteTransactionParametersNormalised } from '@/shared/parameter-schemas/evm.zod';\n\nexport default class HederaBuilder {\n  static createScheduleTransaction(\n    params: z.infer<ReturnType<typeof createScheduleTransactionParametersNormalised>>,\n  ) {\n    return new ScheduleCreateTransaction(params.params).setScheduledTransaction(\n      params.scheduledTransaction,\n    );\n  }\n\n  static createFungibleToken(\n    params: z.infer<ReturnType<typeof createFungibleTokenParametersNormalised>>,\n  ) {\n    return new TokenCreateTransaction(params);\n  }\n\n  static createNonFungibleToken(\n    params: z.infer<ReturnType<typeof createNonFungibleTokenParametersNormalised>>,\n  ) {\n    return new TokenCreateTransaction(params);\n  }\n\n  static transferHbar(params: z.infer<ReturnType<typeof transferHbarParametersNormalised>>) {\n    return new TransferTransaction(params);\n  }\n\n  static airdropFungibleToken(\n    params: z.infer<ReturnType<typeof airdropFungibleTokenParametersNormalised>>,\n  ) {\n    return new TokenAirdropTransaction(params as any);\n  }\n\n  static updateToken(params: z.infer<ReturnType<typeof updateTokenParametersNormalised>>) {\n    return new TokenUpdateTransaction(params);\n  }\n\n  static createTopic(params: z.infer<ReturnType<typeof createTopicParametersNormalised>>) {\n    const { transactionMemo, ...rest } = params as any;\n    const tx = new TopicCreateTransaction(rest);\n    if (transactionMemo) tx.setTransactionMemo(transactionMemo);\n    return tx;\n  }\n\n  static submitTopicMessage(\n    params: z.infer<ReturnType<typeof submitTopicMessageParametersNormalised>>,\n  ) {\n    const { transactionMemo, ...rest } = params as any;\n    const tx = new TopicMessageSubmitTransaction(rest);\n    if (transactionMemo) tx.setTransactionMemo(transactionMemo);\n    return tx;\n  }\n\n  static updateTopic(params: z.infer<ReturnType<typeof updateTopicParametersNormalised>>) {\n    return new TopicUpdateTransaction(params);\n  }\n\n  static executeTransaction(\n    params: z.infer<ReturnType<typeof contractExecuteTransactionParametersNormalised>>,\n  ) {\n    return new ContractExecuteTransaction(params);\n  }\n\n  static mintFungibleToken(\n    params: z.infer<ReturnType<typeof mintFungibleTokenParametersNormalised>>,\n  ) {\n    return new TokenMintTransaction(params);\n  }\n\n  static mintNonFungibleToken(\n    params: z.infer<ReturnType<typeof mintNonFungibleTokenParametersNormalised>>,\n  ) {\n    return new TokenMintTransaction(params);\n  }\n\n  static dissociateToken(params: z.infer<ReturnType<typeof dissociateTokenParametersNormalised>>) {\n    return new TokenDissociateTransaction(params);\n  }\n\n  static createAccount(params: z.infer<ReturnType<typeof createAccountParametersNormalised>>) {\n    return new AccountCreateTransaction(params);\n  }\n\n  static deleteAccount(params: z.infer<ReturnType<typeof deleteAccountParametersNormalised>>) {\n    return new AccountDeleteTransaction(params);\n  }\n\n  static updateAccount(params: z.infer<ReturnType<typeof updateAccountParametersNormalised>>) {\n    return new AccountUpdateTransaction(params);\n  }\n\n  static deleteToken(params: z.infer<ReturnType<typeof deleteTokenParametersNormalised>>) {\n    return new TokenDeleteTransaction(params);\n  }\n\n  static deleteTopic(params: z.infer<ReturnType<typeof deleteTopicParametersNormalised>>) {\n    return new TopicDeleteTransaction(params);\n  }\n\n  static signScheduleTransaction(\n    params: z.infer<ReturnType<typeof signScheduleTransactionParameters>>,\n  ) {\n    return new ScheduleSignTransaction(params);\n  }\n\n  static deleteScheduleTransaction(\n    params: z.infer<ReturnType<typeof scheduleDeleteTransactionParameters>>,\n  ) {\n    return new ScheduleDeleteTransaction(params as any);\n  }\n\n  static associateToken(params: z.infer<ReturnType<typeof associateTokenParametersNormalised>>) {\n    return new TokenAssociateTransaction({\n      accountId: AccountId.fromString(params.accountId),\n      tokenIds: params.tokenIds.map(t => TokenId.fromString(t)),\n    });\n  }\n\n  static approveHbarAllowance(\n    params: z.infer<ReturnType<typeof approveHbarAllowanceParametersNormalised>>,\n  ) {\n    const tx = new AccountAllowanceApproveTransaction(params as any);\n    if (params.transactionMemo) {\n      tx.setTransactionMemo(params.transactionMemo);\n    }\n    return tx;\n  }\n}\n","import { LedgerId } from '@hashgraph/sdk';\nimport BigNumber from 'bignumber.js';\n\nexport const LedgerIdToBaseUrl: Map<string, string> = new Map([\n  [LedgerId.MAINNET.toString(), 'https://mainnet-public.mirrornode.hedera.com/api/v1'],\n  [LedgerId.TESTNET.toString(), 'https://testnet.mirrornode.hedera.com/api/v1'],\n]);\n\nexport type AccountTokenBalancesQueryParams = {\n  accountId: string;\n  tokenId?: string;\n};\n\nexport type TopicMessagesQueryParams = {\n  topicId: string;\n  lowerTimestamp: string;\n  upperTimestamp: string;\n  limit: number;\n};\n\nexport type TopicMessage = {\n  topicId: string;\n  message: string;\n  consensus_timestamp: string;\n};\n\nexport type TopicMessagesResponse = {\n  topicId: string;\n  messages: TopicMessage[];\n};\n\n// Mirrors Hedera Mirror Node /topics/{topicId} response shape (fields optional to be resilient)\nexport type TopicInfo = {\n  topic_id?: string;\n  memo?: string | null;\n  admin_key?: {\n    _type?: string;\n    key?: string;\n  } | null;\n  submit_key?: {\n    _type?: string;\n    key?: string;\n  } | null;\n  auto_renew_account?: string | null;\n  auto_renew_period?: number | null;\n  created_timestamp?: string | null;\n  deleted?: boolean;\n  sequence_number?: number | null;\n  running_hash?: string | null;\n  running_hash_version?: number | null;\n};\n\nexport type TokenBalance = {\n  automatic_association: boolean;\n  created_timestamp: string;\n  token_id: string;\n  freeze_status: string;\n  kyc_status: string;\n  balance: number;\n  decimals: number;\n};\n\nexport type TokenBalancesResponse = {\n  tokens: TokenBalance[];\n};\n\nexport type AccountResponse = {\n  accountId: string;\n  accountPublicKey: string;\n  balance: AccountBalanceResponse;\n  evmAddress: string;\n};\n\nexport type AccountAPIResponse = {\n  account: string;\n  key: {\n    key: string;\n    _type: KeyEncryptionType;\n  };\n  balance: AccountBalanceResponse;\n  evm_address: string;\n};\n\nexport type AccountBalanceResponse = {\n  balance: BigNumber;\n  timestamp: string;\n  tokens: TokenBalance[];\n};\n\nexport type TopicMessagesAPIResponse = {\n  messages: TopicMessage[];\n  links: {\n    next: string | null;\n  };\n};\n\nexport type KeyEncryptionType = 'ED25519' | 'ECDSA_SECP256K1';\n\n/**\n * This type matches responses from Hedera Mirror Node API\n */\nexport type TokenInfo = {\n  // Basic Token Identity\n  token_id?: string;\n  name: string;\n  symbol: string;\n  type?: string;\n  memo?: string;\n\n  // Supply Information\n  decimals: string;\n  initial_supply?: string;\n  total_supply?: string;\n  max_supply?: string;\n  supply_type?: string;\n\n  // Account & Treasury\n  treasury_account_id?: string;\n  auto_renew_account?: string;\n  auto_renew_period?: number;\n\n  // Status & State\n  deleted: boolean;\n  freeze_default?: boolean;\n  pause_status?: string;\n\n  // Timestamps\n  created_timestamp?: string;\n  modified_timestamp?: string;\n  expiry_timestamp?: number;\n\n  // Keys\n  admin_key?: {\n    _type: string;\n    key: string;\n  } | null;\n  supply_key?: {\n    _type: string;\n    key: string;\n  } | null;\n  kyc_key?: {\n    _type: string;\n    key: string;\n  } | null;\n  freeze_key?: {\n    _type: string;\n    key: string;\n  } | null;\n  wipe_key?: {\n    _type: string;\n    key: string;\n  } | null;\n  pause_key?: {\n    _type: string;\n    key: string;\n  } | null;\n  fee_schedule_key?: {\n    _type: string;\n    key: string;\n  } | null;\n  metadata_key?: {\n    _type: string;\n    key: string;\n  } | null;\n\n  // Metadata & Custom Features\n  metadata?: string;\n  custom_fees?: {\n    created_timestamp: string;\n    fixed_fees: any[];\n    fractional_fees: any[];\n  };\n};\n\nexport type TransferData = {\n  account: string;\n  amount: number;\n  is_approval: boolean;\n};\n\nexport type TransactionData = {\n  batch_key: string | null;\n  bytes: string | null;\n  charged_tx_fee: number;\n  consensus_timestamp: string;\n  entity_id: string;\n  max_fee: string;\n  max_custom_fees: any[];\n  memo_base64: string;\n  name: string;\n  nft_transfers: any[];\n  node: string;\n  nonce: number;\n  parent_consensus_timestamp: string | null;\n  result: string;\n  scheduled: boolean;\n  staking_reward_transfers: any[];\n  token_transfers: any[];\n  transaction_hash: string;\n  transaction_id: string;\n  transfers: TransferData[];\n  valid_duration_seconds: string;\n  valid_start_timestamp: string;\n};\n\nexport type TransactionDetailsResponse = {\n  transactions: TransactionData[];\n};\n\nexport interface ContractInfo {\n  admin_key?: {\n    description?: string;\n    _type?: string;\n    example?: string;\n    key?: string;\n  } | null;\n\n  auto_renew_account?: string | null;\n  auto_renew_period?: number | null;\n  contract_id?: string | null;\n  created_timestamp?: string | null;\n  deleted?: boolean;\n  evm_address?: string;\n  expiration_timestamp?: string | null;\n  file_id?: string | null;\n  max_automatic_token_associations?: number | null;\n  memo?: string;\n  nonce?: number | null;\n  obtainer_id?: string | null;\n  permanent_removal?: boolean | null;\n  proxy_account_id?: string | null;\n\n  timestamp?: {\n    description?: string;\n    from: string;\n    to?: string | null;\n  };\n}\n\nexport type ExchangeRate = {\n  hbar_equivalent: number;\n  cent_equivalent: number;\n  expiration_time: number;\n};\n\nexport type ExchangeRateResponse = {\n  current_rate: ExchangeRate;\n  next_rate: ExchangeRate;\n  timestamp: string;\n};\n\nexport interface TokenAirdropsResponse {\n  airdrops: TokenAirdrop[];\n  links: Links;\n}\n\nexport interface TokenAirdrop {\n  amount: number;\n  receiver_id: string | null;\n  sender_id: string | null;\n  serial_number: number | null;\n  timestamp: TimestampRange;\n  token_id: string | null;\n}\n\nexport interface TimestampRange {\n  from: string;\n  to: string | null;\n}\n\nexport interface Links {\n  next: string | null;\n}\n","import { LedgerId } from '@hashgraph/sdk';\nimport { IHederaMirrornodeService } from './hedera-mirrornode-service.interface';\nimport {\n  AccountAPIResponse,\n  AccountResponse,\n  LedgerIdToBaseUrl,\n  TokenBalancesResponse,\n  TokenInfo,\n  TopicInfo,\n  TopicMessage,\n  TopicMessagesAPIResponse,\n  TopicMessagesQueryParams,\n  TopicMessagesResponse,\n  TransactionDetailsResponse,\n  ContractInfo,\n  TokenAirdropsResponse,\n  ExchangeRateResponse,\n} from './types';\nimport BigNumber from 'bignumber.js';\n\nexport class HederaMirrornodeServiceDefaultImpl implements IHederaMirrornodeService {\n  private readonly baseUrl: string;\n\n  constructor(private readonly ledgerId: LedgerId) {\n    if (!LedgerIdToBaseUrl.has(ledgerId.toString())) {\n      throw new Error(`Network type ${ledgerId} not supported`);\n    }\n    this.baseUrl = LedgerIdToBaseUrl.get(ledgerId.toString())!;\n  }\n\n  async getAccount(accountId: string): Promise<AccountResponse> {\n    const url = `${this.baseUrl}/accounts/${accountId}`;\n    const response = await fetch(url);\n\n    if (!response.ok) {\n      throw new Error(\n        `Failed to fetch account ${accountId}: ${response.status} ${response.statusText}`,\n      );\n    }\n\n    const data: AccountAPIResponse = await response.json();\n\n    // Check if the response is empty (no account found)\n    if (!data.account) {\n      throw new Error(`Account ${accountId} not found`);\n    }\n\n    return {\n      accountId: data.account,\n      accountPublicKey: data?.key?.key,\n      balance: data.balance,\n      evmAddress: data.evm_address,\n    };\n  }\n\n  async getAccountHBarBalance(accountId: string): Promise<BigNumber> {\n    let account;\n    try {\n      account = await this.getAccount(accountId);\n    } catch (error) {\n      throw Error(`Failed to fetch hbar balance for ${accountId}: ${error}`);\n    }\n    return new BigNumber(account.balance.balance);\n  }\n\n  async getAccountTokenBalances(\n    accountId: string,\n    tokenId?: string,\n  ): Promise<TokenBalancesResponse> {\n    const tokenIdParam = tokenId ? `&token.id=${tokenId}` : '';\n    const url = `${this.baseUrl}/accounts/${accountId}/tokens?${tokenIdParam}`;\n    const response = await fetch(url);\n\n    if (!response.ok) {\n      throw new Error(\n        `Failed to fetch balance for an account ${accountId}: ${response.status} ${response.statusText}`,\n      );\n    }\n\n    return await response.json();\n  }\n\n  async getTopicMessages(queryParams: TopicMessagesQueryParams): Promise<TopicMessagesResponse> {\n    const lowerThreshold = queryParams.lowerTimestamp\n      ? `&timestamp=gte:${queryParams.lowerTimestamp}`\n      : '';\n    const upperThreshold = queryParams.upperTimestamp\n      ? `&timestamp=lte:${queryParams.upperTimestamp}`\n      : '';\n    const baseParams = `&order=desc&limit=100`;\n    let url: string | null =\n      `${this.baseUrl}/topics/${queryParams.topicId}/messages?${lowerThreshold}${upperThreshold}${baseParams}`;\n    const arrayOfMessages: TopicMessage[] = [];\n    let fetchedMessages = 0;\n    try {\n      while (url) {\n        // Results are paginated\n\n        fetchedMessages += 1;\n        const response = await fetch(url);\n\n        if (!response.ok) {\n          throw new Error(\n            `Failed to get topic messages for ${queryParams.topicId}: ${response.status} ${response.statusText}`,\n          );\n        }\n\n        const data: TopicMessagesAPIResponse = await response.json();\n\n        arrayOfMessages.push(...data.messages);\n        if (fetchedMessages >= 100) {\n          break;\n        }\n\n        // Update URL for pagination.\n        // This endpoint does not return a full path to the next page, it has to be built first\n        url = data.links.next ? this.baseUrl + data.links.next : null;\n      }\n    } catch (error) {\n      console.error(`Failed to fetch topic messages for ${queryParams.topicId}. Error:`, error);\n      throw error;\n    }\n    return {\n      topicId: queryParams.topicId,\n      messages: arrayOfMessages.slice(0, queryParams.limit),\n    };\n  }\n\n  async getTokenInfo(tokenId: string): Promise<TokenInfo> {\n    const url = `${this.baseUrl}/tokens/${tokenId}`;\n    const response = await fetch(url);\n\n    if (!response.ok) {\n      throw new Error(\n        `Failed to get token info for a token ${tokenId}: ${response.status} ${response.statusText}`,\n      );\n    }\n\n    return await response.json();\n  }\n\n  async getTopicInfo(topicId: string): Promise<TopicInfo> {\n    const url = `${this.baseUrl}/topics/${topicId}`;\n    const response = await fetch(url);\n\n    if (!response.ok) {\n      throw new Error(\n        `Failed to get topic info for ${topicId}: ${response.status} ${response.statusText}`,\n      );\n    }\n\n    return await response.json();\n  }\n\n  async getTransactionRecord(\n    transactionId: string,\n    nonce?: number,\n  ): Promise<TransactionDetailsResponse> {\n    let url = `${this.baseUrl}/transactions/${transactionId}`;\n    if (nonce !== undefined) {\n      url += `?nonce=${nonce}`;\n    }\n\n    const response = await fetch(url);\n\n    if (!response.ok) {\n      throw new Error(\n        `Failed to get transaction record for ${transactionId}: ${response.status} ${response.statusText}`,\n      );\n    }\n\n    return await response.json();\n  }\n\n  async getContractInfo(contractId: string): Promise<ContractInfo> {\n    const url = `${this.baseUrl}/contracts/${contractId}`;\n    const response = await fetch(url);\n\n    if (!response.ok) {\n      throw new Error(\n        `Failed to get contract info for ${contractId}: ${response.status} ${response.statusText}`,\n      );\n    }\n\n    return await response.json();\n  }\n\n  async getPendingAirdrops(accountId: string): Promise<TokenAirdropsResponse> {\n    const url = `${this.baseUrl}/accounts/${accountId}/airdrops/pending`;\n    const response = await fetch(url);\n\n    if (!response.ok) {\n      throw new Error(\n        `Failed to fetch pending airdrops for an account ${accountId}: ${response.status} ${response.statusText}`,\n      );\n    }\n\n    return await response.json();\n  }\n\n  async getOutstandingAirdrops(accountId: string): Promise<TokenAirdropsResponse> {\n    const url = `${this.baseUrl}/accounts/${accountId}/airdrops/outstanding`;\n    const response = await fetch(url);\n\n    if (!response.ok) {\n      throw new Error(\n        `Failed to fetch outstanding airdrops for an account ${accountId}: ${response.status} ${response.statusText}`,\n      );\n    }\n\n    return await response.json();\n  }\n\n  async getExchangeRate(timestamp?: string): Promise<ExchangeRateResponse> {\n    const timestampParam = timestamp ? `?timestamp=${encodeURIComponent(timestamp)}` : '';\n    const url = `${this.baseUrl}/network/exchangerate${timestampParam}`;\n    const response = await fetch(url);\n    if (!response.ok) {\n      throw new Error(`HTTP error! status: ${response.status}. Message: ${response.statusText}`);\n    }\n    return await response.json();\n  }\n}\n","import { LedgerId } from '@hashgraph/sdk';\nimport { HederaMirrornodeServiceDefaultImpl } from './hedera-mirrornode-service-default-impl';\nimport { IHederaMirrornodeService } from './hedera-mirrornode-service.interface';\n\nexport const getMirrornodeService = (\n  mirrornodeService: IHederaMirrornodeService | undefined,\n  ledgerId: LedgerId,\n) => {\n  if (mirrornodeService) {\n    return mirrornodeService;\n  }\n  return new HederaMirrornodeServiceDefaultImpl(ledgerId);\n};\n","import { Context, AgentMode } from '@/shared/configuration';\nimport { AccountResolver } from '@/shared';\n\nexport class PromptGenerator {\n  /**\n   * Generates a consistent context snippet for tool prompts.\n   */\n  static getContextSnippet(context: Context): string {\n    const lines = ['Context:'];\n\n    if (context.mode === AgentMode.RETURN_BYTES) {\n      lines.push(`- Mode: Return Bytes (preparing transactions for user signing)`);\n      if (context.accountId) {\n        lines.push(`- User Account: ${context.accountId} (default for transaction parameters)`);\n        lines.push(`- When no account is specified, ${context.accountId} will be used`);\n      } else {\n        lines.push(`- User Account: Not specified`);\n        lines.push(`- When no account is specified, the operator account will be used`);\n      }\n    } else if (context.mode === AgentMode.AUTONOMOUS) {\n      lines.push(`- Mode: Autonomous (agent executes transactions directly)`);\n      if (context.accountId) {\n        lines.push(`- User Account: ${context.accountId}`);\n      }\n      lines.push(`- When no account is specified, the operator account will be used`);\n    } else {\n      lines.push(`- Mode: ${context.mode || 'Not specified'}`);\n      if (context.accountId) {\n        lines.push(`- User Account: ${context.accountId}`);\n      }\n      lines.push(`- Default account will be determined at execution time`);\n    }\n\n    return lines.join('\\n');\n  }\n\n  static getAnyAddressParameterDescription(\n    paramName: string,\n    context: Context,\n    isRequired: boolean = false,\n  ): string {\n    if (isRequired) {\n      return `${paramName} (str, required): The account address. This can be the EVM address or the Hedera account id`;\n    }\n\n    return `${paramName} (str, optional): The Hedera account ID or EVM address. If not provided, defaults to the ${AccountResolver.getDefaultAccountDescription(context)}`;\n  }\n\n  /**\n   * Generates a consistent description for optional account parameters.\n   */\n  static getAccountParameterDescription(\n    paramName: string,\n    context: Context,\n    isRequired: boolean = false,\n  ): string {\n    if (isRequired) {\n      return `${paramName} (str, required): The Hedera account ID`;\n    }\n\n    const defaultAccountDesc = AccountResolver.getDefaultAccountDescription(context);\n    return `${paramName} (str, optional): The Hedera account ID. If not provided, defaults to the ${defaultAccountDesc}`;\n  }\n\n  /**\n   * Generates consistent parameter usage instructions.\n   */\n  static getParameterUsageInstructions(): string {\n    return `\nImportant:\n- Only include optional parameters if explicitly provided by the user\n- Do not generate placeholder values for optional fields\n- Leave optional parameters undefined if not specified by the user`;\n  }\n}\n","import { z } from 'zod';\nimport type { Context } from '@/shared/configuration';\nimport type { Tool } from '@/shared/tools';\nimport HederaParameterNormaliser from '@/shared/hedera-utils/hedera-parameter-normaliser';\nimport { Client, Status } from '@hashgraph/sdk';\nimport { handleTransaction, RawTransactionResponse } from '@/shared/strategies/tx-mode-strategy';\nimport { createFungibleTokenParameters } from '@/shared/parameter-schemas/token.zod';\nimport HederaBuilder from '@/shared/hedera-utils/hedera-builder';\nimport { getMirrornodeService } from '@/shared/hedera-utils/mirrornode/hedera-mirrornode-utils';\nimport { PromptGenerator } from '@/shared/utils/prompt-generator';\n\nconst createFungibleTokenPrompt = (context: Context = {}) => {\n  const contextSnippet = PromptGenerator.getContextSnippet(context);\n  const treasuryAccountDesc = PromptGenerator.getAccountParameterDescription(\n    'treasuryAccountId',\n    context,\n  );\n  const usageInstructions = PromptGenerator.getParameterUsageInstructions();\n\n  return `\n${contextSnippet}\n\nThis tool creates a fungible token on Hedera.\n\nParameters:\n- tokenName (str, required): The name of the token\n- tokenSymbol (str, optional): The symbol of the token\n- initialSupply (int, optional): The initial supply of the token, defaults to 0\n- supplyType (str, optional): The supply type of the token. Can be \"finite\" or \"infinite\". Defaults to \"finite\"\n- maxSupply (int, optional): The maximum supply of the token. Only applicable if supplyType is \"finite\". Defaults to 1,000,000 if not specified\n- decimals (int, optional): The number of decimals the token supports. Defaults to 0\n- ${treasuryAccountDesc}\n- isSupplyKey (boolean, optional): If user wants to set supply key set to true, otherwise false\n${usageInstructions}\n`;\n};\n\nconst postProcess = (response: RawTransactionResponse) => {\n  return `Token created successfully at address ${response.tokenId?.toString()} with transaction id ${response.transactionId}`;\n};\n\nconst createFungibleToken = async (\n  client: Client,\n  context: Context,\n  params: z.infer<ReturnType<typeof createFungibleTokenParameters>>,\n) => {\n  try {\n    const mirrornodeService = getMirrornodeService(context.mirrornodeService!, client.ledgerId!);\n    const normalisedParams = await HederaParameterNormaliser.normaliseCreateFungibleTokenParams(\n      params,\n      context,\n      client,\n      mirrornodeService,\n    );\n    const tx = HederaBuilder.createFungibleToken(normalisedParams);\n    const result = await handleTransaction(tx, client, context, postProcess);\n    return result;\n  } catch (error) {\n    const desc = 'Failed to create fungible token';\n    const message = desc + (error instanceof Error ? `: ${error.message}` : '');\n    console.error('[create_fungible_token_tool]', message);\n    return { raw: { status: Status.InvalidTransaction, error: message }, humanMessage: message };\n  }\n};\n\nexport const CREATE_FUNGIBLE_TOKEN_TOOL = 'create_fungible_token_tool';\n\nconst tool = (context: Context): Tool => ({\n  method: CREATE_FUNGIBLE_TOKEN_TOOL,\n  name: 'Create Fungible Token',\n  description: createFungibleTokenPrompt(context),\n  parameters: createFungibleTokenParameters(context),\n  execute: createFungibleToken,\n});\n\nexport default tool;\n","import { z } from 'zod';\nimport type { Context } from '@/shared/configuration';\nimport type { Tool } from '@/shared/tools';\nimport HederaParameterNormaliser from '@/shared/hedera-utils/hedera-parameter-normaliser';\nimport { Client, Status } from '@hashgraph/sdk';\nimport { handleTransaction, RawTransactionResponse } from '@/shared/strategies/tx-mode-strategy';\nimport { mintFungibleTokenParameters } from '@/shared/parameter-schemas/token.zod';\nimport HederaBuilder from '@/shared/hedera-utils/hedera-builder';\nimport { getMirrornodeService } from '@/shared/hedera-utils/mirrornode/hedera-mirrornode-utils';\nimport { PromptGenerator } from '@/shared/utils/prompt-generator';\n\nconst mintFungibleTokenPrompt = (context: Context = {}) => {\n  const contextSnippet = PromptGenerator.getContextSnippet(context);\n  const usageInstructions = PromptGenerator.getParameterUsageInstructions();\n\n  return `\n${contextSnippet}\n\nThis tool will mint a given amount (supply) of an existing fungible token on Hedera.\n\nParameters:\n- tokenId (str, required): The id of the token\n- amount (number, required): The amount to be minted\n${usageInstructions}\n\nExample: \"Mint 1 of 0.0.6458037\" means minting the amount of 1 of the token with id 0.0.6458037.\n`;\n};\n\nconst postProcess = (response: RawTransactionResponse) => {\n  return `Tokens successfully minted with transaction id ${response.transactionId.toString()}`;\n};\n\nconst mintFungibleToken = async (\n  client: Client,\n  context: Context,\n  params: z.infer<ReturnType<typeof mintFungibleTokenParameters>>,\n) => {\n  try {\n    const mirrornodeService = getMirrornodeService(context.mirrornodeService!, client.ledgerId!);\n    const normalisedParams = await HederaParameterNormaliser.normaliseMintFungibleTokenParams(\n      params,\n      context,\n      mirrornodeService,\n    );\n    const tx = HederaBuilder.mintFungibleToken(normalisedParams);\n    const result = await handleTransaction(tx, client, context, postProcess);\n    return result;\n  } catch (error) {\n    const desc = 'Failed to mint fungible token';\n    const message = desc + (error instanceof Error ? `: ${error.message}` : '');\n    console.error('[mint_fungible_token_tool]', message);\n    return { raw: { status: Status.InvalidTransaction, error: message }, humanMessage: message };\n  }\n};\n\nexport const MINT_FUNGIBLE_TOKEN_TOOL = 'mint_fungible_token_tool';\n\nconst tool = (context: Context): Tool => ({\n  method: MINT_FUNGIBLE_TOKEN_TOOL,\n  name: 'Mint Fungible Token',\n  description: mintFungibleTokenPrompt(context),\n  parameters: mintFungibleTokenParameters(context),\n  execute: mintFungibleToken,\n});\n\nexport default tool;\n","import { z } from 'zod';\nimport type { Context } from '@/shared/configuration';\nimport type { Tool } from '@/shared/tools';\nimport HederaParameterNormaliser from '@/shared/hedera-utils/hedera-parameter-normaliser';\nimport { Client, Status } from '@hashgraph/sdk';\nimport { handleTransaction, RawTransactionResponse } from '@/shared/strategies/tx-mode-strategy';\nimport { createNonFungibleTokenParameters } from '@/shared/parameter-schemas/token.zod';\nimport HederaBuilder from '@/shared/hedera-utils/hedera-builder';\nimport { getMirrornodeService } from '@/shared/hedera-utils/mirrornode/hedera-mirrornode-utils';\nimport { PromptGenerator } from '@/shared/utils/prompt-generator';\n\nconst createNonFungibleTokenPrompt = (context: Context = {}) => {\n  const contextSnippet = PromptGenerator.getContextSnippet(context);\n  const treasuryAccountDesc = PromptGenerator.getAccountParameterDescription(\n    'treasuryAccountId',\n    context,\n  );\n  const usageInstructions = PromptGenerator.getParameterUsageInstructions();\n\n  return `\n${contextSnippet}\n\nThis tool creates a non-fungible token (NFT) on Hedera.\n\nParameters:\n- tokenName (str, required): Name of the token\n- tokenSymbol (str, required): Symbol of the token\n- maxSupply (int, optional): Maximum NFT supply. Defaults to 100 if not provided\n- ${treasuryAccountDesc}\n${usageInstructions}\n`;\n};\n\nconst postProcess = (response: RawTransactionResponse) => {\n  return `Token created successfully at address ${response.tokenId?.toString()} with transaction id ${response.transactionId.toString()}`;\n};\n\nconst createNonFungibleToken = async (\n  client: Client,\n  context: Context,\n  params: z.infer<ReturnType<typeof createNonFungibleTokenParameters>>,\n) => {\n  try {\n    const mirrornodeService = getMirrornodeService(context.mirrornodeService!, client.ledgerId!);\n    const normalisedParams = await HederaParameterNormaliser.normaliseCreateNonFungibleTokenParams(\n      params,\n      context,\n      client,\n      mirrornodeService,\n    );\n    const tx = HederaBuilder.createNonFungibleToken(normalisedParams);\n    const result = await handleTransaction(tx, client, context, postProcess);\n    return result;\n  } catch (error) {\n    const desc = 'Failed to create non-fungible token';\n    const message = desc + (error instanceof Error ? `: ${error.message}` : '');\n    console.error('[create_non_fungible_token_tool]', message);\n    return { raw: { status: Status.InvalidTransaction, error: message }, humanMessage: message };\n  }\n};\n\nexport const CREATE_NON_FUNGIBLE_TOKEN_TOOL = 'create_non_fungible_token_tool';\n\nconst tool = (context: Context): Tool => ({\n  method: CREATE_NON_FUNGIBLE_TOKEN_TOOL,\n  name: 'Create Non-Fungible Token',\n  description: createNonFungibleTokenPrompt(context),\n  parameters: createNonFungibleTokenParameters(context),\n  execute: createNonFungibleToken,\n});\n\nexport default tool;\n","import { z } from 'zod';\nimport type { Context } from '@/shared/configuration';\nimport type { Tool } from '@/shared/tools';\nimport HederaParameterNormaliser from '@/shared/hedera-utils/hedera-parameter-normaliser';\nimport { Client, Status } from '@hashgraph/sdk';\nimport { handleTransaction, RawTransactionResponse } from '@/shared/strategies/tx-mode-strategy';\nimport { mintNonFungibleTokenParameters } from '@/shared/parameter-schemas/token.zod';\nimport HederaBuilder from '@/shared/hedera-utils/hedera-builder';\nimport { PromptGenerator } from '@/shared/utils/prompt-generator';\n\nconst mintNonFungibleTokenPrompt = (_context: Context = {}) => {\n  const usageInstructions = PromptGenerator.getParameterUsageInstructions();\n\n  return `\n\nThis tool will mint NFTs with its unique metadata for the class of NFTs (non-fungible tokens) defined by the tokenId on Hedera.\n\nParameters:\n- tokenId (str, required): The id of the token\n- uris (array, required): An array of strings (URIs) of maximum size 10 hosting the NFT metadata\n${usageInstructions}\n\nExample: \"Mint 0.0.6465503 with metadata: ipfs://bafyreiao6ajgsfji6qsgbqwdtjdu5gmul7tv2v3pd6kjgcw5o65b2ogst4/metadata.json\" means minting an NFT with the given metadata URI for the class of NFTs defined by the token with id 0.0.6465503.\n`;\n};\n\nconst postProcess = (response: RawTransactionResponse) => {\n  return `Token ${response.tokenId?.toString()} successfully minted with transaction id ${response.transactionId.toString()}`;\n};\n\nconst mintNonFungibleToken = async (\n  client: Client,\n  context: Context,\n  params: z.infer<ReturnType<typeof mintNonFungibleTokenParameters>>,\n) => {\n  try {\n    const normalisedParams = HederaParameterNormaliser.normaliseMintNonFungibleTokenParams(\n      params,\n      context,\n    );\n    const tx = HederaBuilder.mintNonFungibleToken(normalisedParams);\n    const result = await handleTransaction(tx, client, context, postProcess);\n    return result;\n  } catch (error) {\n    const desc = 'Failed to mint non-fungible token';\n    const message = desc + (error instanceof Error ? `: ${error.message}` : '');\n    console.error('[mint_non_fungible_token_tool]', message);\n    return { raw: { status: Status.InvalidTransaction, error: message }, humanMessage: message };\n  }\n};\n\nexport const MINT_NON_FUNGIBLE_TOKEN_TOOL = 'mint_non_fungible_token_tool';\n\nconst tool = (context: Context): Tool => ({\n  method: MINT_NON_FUNGIBLE_TOKEN_TOOL,\n  name: 'Mint Non-Fungible Token',\n  description: mintNonFungibleTokenPrompt(context),\n  parameters: mintNonFungibleTokenParameters(context),\n  execute: mintNonFungibleToken,\n});\n\nexport default tool;\n","import { z } from 'zod';\nimport type { Context } from '@/shared/configuration';\nimport type { Tool } from '@/shared/tools';\nimport { Client, PublicKey, Status } from '@hashgraph/sdk';\nimport { TokenInfo } from '@/shared/hedera-utils/mirrornode/types';\nimport { handleTransaction, RawTransactionResponse } from '@/shared/strategies/tx-mode-strategy';\nimport HederaBuilder from '@/shared/hedera-utils/hedera-builder';\nimport HederaParameterNormaliser from '@/shared/hedera-utils/hedera-parameter-normaliser';\nimport { PromptGenerator } from '@/shared/utils/prompt-generator';\nimport {\n  updateTokenParameters,\n  updateTokenParametersNormalised,\n} from '@/shared/parameter-schemas/token.zod';\nimport { IHederaMirrornodeService } from '@/shared/hedera-utils/mirrornode/hedera-mirrornode-service.interface';\nimport { getMirrornodeService } from '@/shared/hedera-utils/mirrornode/hedera-mirrornode-utils';\nimport { AccountResolver } from '@/shared';\n\nconst checkValidityOfUpdates = async (\n  params: z.infer<ReturnType<typeof updateTokenParametersNormalised>>,\n  mirrornode: IHederaMirrornodeService,\n  userPublicKey: PublicKey,\n) => {\n  const tokenDetails: TokenInfo = await mirrornode.getTokenInfo(params.tokenId.toString());\n  if (!tokenDetails) {\n    throw new Error('Token not found');\n  }\n\n  if (tokenDetails.admin_key?.key !== userPublicKey.toStringRaw()) {\n    console.error(\n      `tokenDetails.admin_key.key: ${tokenDetails.admin_key?.key} vs userPublicKey: ${userPublicKey.toStringRaw()}`,\n    );\n    throw new Error(\n      'You do not have permission to update this token. The adminKey does not match your public key.',\n    );\n  }\n\n  const keyChecks: Partial<Record<keyof typeof params, keyof TokenInfo>> = {\n    adminKey: 'admin_key',\n    kycKey: 'kyc_key',\n    freezeKey: 'freeze_key',\n    wipeKey: 'wipe_key',\n    supplyKey: 'supply_key',\n    feeScheduleKey: 'fee_schedule_key',\n    pauseKey: 'pause_key',\n    metadataKey: 'metadata_key',\n  };\n\n  for (const [paramKey, tokenField] of Object.entries(keyChecks) as [\n    keyof typeof params,\n    keyof TokenInfo,\n  ][]) {\n    const userValue = params[paramKey];\n    const tokenKey = tokenDetails[tokenField];\n\n    if (userValue instanceof PublicKey && !tokenKey) {\n      throw new Error(`Cannot update ${paramKey}: token was created without a ${paramKey}`);\n    }\n  }\n};\n\nconst updateTokenPrompt = (context: Context = {}) => {\n  const contextSnippet = PromptGenerator.getContextSnippet(context);\n  const tokenDesc = PromptGenerator.getAnyAddressParameterDescription('tokenId', context);\n  const usageInstructions = PromptGenerator.getParameterUsageInstructions();\n\n  return `\n${contextSnippet}\n\nThis tool will update an existing Hedera HTS token. Only the fields provided will be updated.\n\nKey fields (adminKey, kycKey, freezeKey, wipeKey, supplyKey, feeScheduleKey, pauseKey, metadataKey) must contain **Hedera-compatible public keys (as strings) or boolean (true/false)**. You can provide these in one of three ways:\n\n1. **Boolean true** – Set this field to use user/operator key. Injecting of the key will be handled automatically.\n2. **Not provided** – The field will not be updated.\n3. **String** – Provide a Hedera-compatible public key string to set a field explicitly.\n\nParameters:\n- ${tokenDesc}\n- tokenName (string, optional): New name for the token. Up to 100 characters.\n- tokenSymbol (string, optional): New symbol for the token. Up to 100 characters.\n- treasuryAccountId (string, optional): New treasury account for the token (Hedera account ID).\n- adminKey (boolean|string, optional): New admin key. Pass true to use your operator key, or provide a public key string.\n- kycKey (boolean|string, optional): New KYC key. Pass true to use your operator key, or provide a public key string.\n- freezeKey (boolean|string, optional): New freeze key. Pass true to use your operator key, or provide a public key string.\n- wipeKey (boolean|string, optional): New wipe key. Pass true to use your operator key, or provide a public key string.\n- supplyKey (boolean|string, optional): New supply key. Pass true to use your operator key, or provide a public key string.\n- feeScheduleKey (boolean|string, optional): New fee schedule key. Pass true to use your operator key, or provide a public key string.\n- pauseKey (boolean|string, optional): New pause key. Pass true to use your operator key, or provide a public key string.\n- metadataKey (boolean|string, optional): New metadata key. Pass true to use your operator key, or provide a public key string.\n- metadata (string, optional): New metadata for the token, in bytes (hex or base64).\n- tokenMemo (string, optional): Short public memo for the token, up to 100 characters.\n- autoRenewAccountId (string, optional): Account to automatically pay for renewal.\n\nExamples:\n- If the user asks for \"my key\" → set the field to \\`true\\`.\n- If the user does not mention the key → do not set the field.\n- If the user provides a key → set the field to the provided public key string.\n\nIf the user provides multiple fields in a single request, \ncombine them into **one tool call** with all parameters together.\n\n${usageInstructions}\n`;\n};\n\nconst postProcess = (response: RawTransactionResponse) => {\n  return `Token successfully updated. Transaction ID: ${response.transactionId}`;\n};\n\nconst updateToken = async (\n  client: Client,\n  context: Context,\n  params: z.infer<ReturnType<typeof updateTokenParameters>>,\n) => {\n  try {\n    const normalisedParams = await HederaParameterNormaliser.normaliseUpdateToken(\n      params,\n      context,\n      client,\n    );\n    const mirrornodeService = getMirrornodeService(context.mirrornodeService!, client.ledgerId!);\n    const userPublicKey = await AccountResolver.getDefaultPublicKey(context, client);\n\n    await checkValidityOfUpdates(normalisedParams, mirrornodeService, userPublicKey);\n\n    const tx = HederaBuilder.updateToken(normalisedParams);\n\n    return await handleTransaction(tx, client, context, postProcess);\n  } catch (error) {\n    const desc = 'Failed to update token';\n    const message = desc + (error instanceof Error ? `: ${error.message}` : '');\n    console.error('[update_token_tool]', message);\n    return {\n      raw: { status: Status.InvalidTransaction, error: message },\n      humanMessage: message,\n    };\n  }\n};\n\nexport const UPDATE_TOKEN_TOOL = 'update_token_tool';\n\nconst tool = (context: Context): Tool => ({\n  method: UPDATE_TOKEN_TOOL,\n  name: 'Update Token',\n  description: updateTokenPrompt(context),\n  parameters: updateTokenParameters(context),\n  execute: updateToken,\n});\n\nexport default tool;\n","import { z } from 'zod';\nimport type { Context } from '@/shared/configuration';\nimport type { Tool } from '@/shared/tools';\nimport HederaParameterNormaliser from '@/shared/hedera-utils/hedera-parameter-normaliser';\nimport { Client, Status } from '@hashgraph/sdk';\nimport { handleTransaction, RawTransactionResponse } from '@/shared/strategies/tx-mode-strategy';\nimport { dissociateTokenParameters } from '@/shared/parameter-schemas/token.zod';\nimport HederaBuilder from '@/shared/hedera-utils/hedera-builder';\nimport { PromptGenerator } from '@/shared/utils/prompt-generator';\n\nconst dissociateTokenPrompt = (context: Context = {}) => {\n  const contextSnippet = PromptGenerator.getContextSnippet(context);\n  const sourceAccountDesc = PromptGenerator.getAccountParameterDescription('accountId', context);\n  const usageInstructions = PromptGenerator.getParameterUsageInstructions();\n\n  return `\n${contextSnippet}\n\nThis tool will airdrop a fungible token on Hedera.\n\nParameters:\n- tokenIds (array of strings, required): A list of Hedera token IDs to dissociate from the account. Example: [\"0.0.1234\", \"0.0.5678\"]\n- ${sourceAccountDesc}, account from which to dissociate the token(s)\n- transactionMemo (str, optional): Optional memo for the transaction\n\nExamples:\n- Dissociate a single token: { \"tokenIds\": [\"0.0.1234\"] }\n- Dissociate multiple tokens from a specific account: { \"tokenIds\": [\"0.0.1234\", \"0.0.5678\"], \"accountId\": \"0.0.4321\" }\n\n${usageInstructions}\n`;\n};\n\nconst postProcess = (response: RawTransactionResponse) => {\n  return `Token(s) successfully dissociated with transaction id ${response.transactionId.toString()}`;\n};\n\nconst dissociateToken = async (\n  client: Client,\n  context: Context,\n  params: z.infer<ReturnType<typeof dissociateTokenParameters>>,\n) => {\n  try {\n    const normalisedParams = await HederaParameterNormaliser.normaliseDissociateTokenParams(\n      params,\n      context,\n      client,\n    );\n    const tx = HederaBuilder.dissociateToken(normalisedParams);\n    return await handleTransaction(tx, client, context, postProcess);\n  } catch (error) {\n    const desc = 'Failed to dissociate token';\n    const message = desc + (error instanceof Error ? `: ${error.message}` : '');\n    console.error('[dissociate_token_tool]', message);\n    return { raw: { status: Status.InvalidTransaction, error: message }, humanMessage: message };\n  }\n};\n\nexport const DISSOCIATE_TOKEN_TOOL = 'dissociate_token_tool';\n\nconst tool = (context: Context): Tool => ({\n  method: DISSOCIATE_TOKEN_TOOL,\n  name: 'Dissociate Token',\n  description: dissociateTokenPrompt(context),\n  parameters: dissociateTokenParameters(context),\n  execute: dissociateToken,\n});\n\nexport default tool;\n","import { z } from 'zod';\nimport type { Context } from '@/shared/configuration';\nimport type { Tool } from '@/shared/tools';\nimport HederaParameterNormaliser from '@/shared/hedera-utils/hedera-parameter-normaliser';\nimport { Client, Status } from '@hashgraph/sdk';\nimport { handleTransaction, RawTransactionResponse } from '@/shared/strategies/tx-mode-strategy';\nimport { associateTokenParameters } from '@/shared/parameter-schemas/token.zod';\nimport HederaBuilder from '@/shared/hedera-utils/hedera-builder';\nimport { PromptGenerator } from '@/shared/utils/prompt-generator';\n\nconst associateTokenPrompt = (context: Context = {}) => {\n  const contextSnippet = PromptGenerator.getContextSnippet(context);\n  const usageInstructions = PromptGenerator.getParameterUsageInstructions();\n  const accountToAssociate = PromptGenerator.getAnyAddressParameterDescription('accountId', context);\n\n  return `\n${contextSnippet}\n\nThis tool will associate one or more tokens with a Hedera account.\n\nParameters:\n${accountToAssociate}\n- tokenIds (string[], required): Array of token IDs to associate\n${usageInstructions}\n\nExample: \"Associate tokens 0.0.123 and 0.0.456 to account 0.0.789\".\n`;\n};\n\nconst postProcess = (response: RawTransactionResponse) => {\n  return `Tokens successfully associated with transaction id ${response.transactionId.toString()}`;\n};\n\nconst associateToken = async (\n  client: Client,\n  context: Context,\n  params: z.infer<ReturnType<typeof associateTokenParameters>>,\n) => {\n  try {\n    const normalisedParams = HederaParameterNormaliser.normaliseAssociateTokenParams(\n      params,\n      context,\n      client,\n    );\n    const tx = HederaBuilder.associateToken(normalisedParams);\n    const result = await handleTransaction(tx, client, context, postProcess);\n    return result;\n  } catch (error) {\n    const desc = 'Failed to associate token(s)';\n    const message = desc + (error instanceof Error ? `: ${error.message}` : '');\n    console.error('[associate_token_tool]', message);\n    return { raw: { status: Status.InvalidTransaction, error: message }, humanMessage: message };\n  }\n};\n\nexport const ASSOCIATE_TOKEN_TOOL = 'associate_token_tool';\n\nconst tool = (context: Context): Tool => ({\n  method: ASSOCIATE_TOKEN_TOOL,\n  name: 'Associate Token(s)',\n  description: associateTokenPrompt(context),\n  parameters: associateTokenParameters(context),\n  execute: associateToken,\n});\n\nexport default tool;\n\n\n","import { Context } from '@/shared';\nimport { Plugin } from '@/shared/plugin';\nimport airdropFungibleToken, {\n  AIRDROP_FUNGIBLE_TOKEN_TOOL,\n} from '@/plugins/core-token-plugin/tools/fungible-token/airdrop-fungible-token';\nimport createFungibleTokenTool, {\n  CREATE_FUNGIBLE_TOKEN_TOOL,\n} from '@/plugins/core-token-plugin/tools/fungible-token/create-fungible-token';\nimport mintFungibleTokenTool, {\n  MINT_FUNGIBLE_TOKEN_TOOL,\n} from '@/plugins/core-token-plugin/tools/fungible-token/mint-fungible-token';\nimport createNonFungibleTokenTool, {\n  CREATE_NON_FUNGIBLE_TOKEN_TOOL,\n} from '@/plugins/core-token-plugin/tools/non-fungible-token/create-non-fungible-token';\nimport mintNonFungibleTokenTool, {\n  MINT_NON_FUNGIBLE_TOKEN_TOOL,\n} from '@/plugins/core-token-plugin/tools/non-fungible-token/mint-non-fungible-token';\nimport updateTokenTool, { UPDATE_TOKEN_TOOL } from '@/plugins/core-token-plugin/tools/update-token';\nimport dissociateTokenTool, {\n  DISSOCIATE_TOKEN_TOOL,\n} from '@/plugins/core-token-plugin/tools/dissociate-token';\nimport associateTokenTool, {\n  ASSOCIATE_TOKEN_TOOL,\n} from '@/plugins/core-token-plugin/tools/associate-token';\n\nexport const coreTokenPlugin: Plugin = {\n  name: 'core-token-plugin',\n  version: '1.0.0',\n  description: 'A plugin for the Hedera Token Service',\n  tools: (context: Context) => {\n    return [\n      createFungibleTokenTool(context),\n      mintFungibleTokenTool(context),\n      createNonFungibleTokenTool(context),\n      airdropFungibleToken(context),\n      mintNonFungibleTokenTool(context),\n      updateTokenTool(context),\n      dissociateTokenTool(context),\n      associateTokenTool(context),\n    ];\n  },\n};\n\n// Export tool names as an object for destructuring\nexport const coreTokenPluginToolNames = {\n  AIRDROP_FUNGIBLE_TOKEN_TOOL,\n  CREATE_FUNGIBLE_TOKEN_TOOL,\n  MINT_FUNGIBLE_TOKEN_TOOL,\n  CREATE_NON_FUNGIBLE_TOKEN_TOOL,\n  MINT_NON_FUNGIBLE_TOKEN_TOOL,\n  DISSOCIATE_TOKEN_TOOL,\n  ASSOCIATE_TOKEN_TOOL,\n  UPDATE_TOKEN_TOOL,\n} as const;\n\nexport default { coreTokenPlugin, coreTokenPluginToolNames };\n","import { z } from 'zod';\nimport type { Context } from '@/shared/configuration';\nimport type { Tool } from '@/shared/tools';\nimport { Client, Status } from '@hashgraph/sdk';\nimport { handleTransaction, RawTransactionResponse } from '@/shared/strategies/tx-mode-strategy';\nimport HederaBuilder from '@/shared/hedera-utils/hedera-builder';\nimport { transferHbarParameters } from '@/shared/parameter-schemas/account.zod';\nimport HederaParameterNormaliser from '@/shared/hedera-utils/hedera-parameter-normaliser';\nimport { PromptGenerator } from '@/shared/utils/prompt-generator';\n\nconst transferHbarPrompt = (context: Context = {}) => {\n  const contextSnippet = PromptGenerator.getContextSnippet(context);\n  const sourceAccountDesc = PromptGenerator.getAccountParameterDescription(\n    'sourceAccountId',\n    context,\n  );\n  const usageInstructions = PromptGenerator.getParameterUsageInstructions();\n\n  return `\n${contextSnippet}\n\nThis tool will transfer HBAR to an account.\n\nParameters:\n- transfers (array of objects, required): List of HBAR transfers. Each object should contain:\n  - accountId (string): Recipient account ID\n  - amount (number): Amount of HBAR to transfer\n- ${sourceAccountDesc}\n- transactionMemo (string, optional): Optional memo for the transaction\n${usageInstructions}\n`;\n};\n\nconst postProcess = (response: RawTransactionResponse) => {\n  return `HBAR successfully transferred. Transaction ID: ${response.transactionId}`;\n};\n\nconst transferHbar = async (\n  client: Client,\n  context: Context,\n  params: z.infer<ReturnType<typeof transferHbarParameters>>,\n) => {\n  try {\n    const normalisedParams = HederaParameterNormaliser.normaliseTransferHbar(\n      params,\n      context,\n      client,\n    );\n    const tx = HederaBuilder.transferHbar(normalisedParams);\n    const result = await handleTransaction(tx, client, context, postProcess);\n    return result;\n  } catch (error) {\n    const desc = 'Failed to transfer HBAR';\n    const message = desc + (error instanceof Error ? `: ${error.message}` : '');\n    console.error('[transfer_hbar_tool]', message);\n    return { raw: { status: Status.InvalidTransaction, error: message }, humanMessage: message };\n  }\n};\n\nexport const TRANSFER_HBAR_TOOL = 'transfer_hbar_tool';\n\nconst tool = (context: Context): Tool => ({\n  method: TRANSFER_HBAR_TOOL,\n  name: 'Transfer HBAR',\n  description: transferHbarPrompt(context),\n  parameters: transferHbarParameters(context),\n  execute: transferHbar,\n});\n\nexport default tool;\n","import { z } from 'zod';\nimport type { Context } from '@/shared/configuration';\nimport type { Tool } from '@/shared/tools';\nimport { Client } from '@hashgraph/sdk';\nimport { handleTransaction, RawTransactionResponse } from '@/shared/strategies/tx-mode-strategy';\nimport HederaBuilder from '@/shared/hedera-utils/hedera-builder';\nimport {\n  approveHbarAllowanceParameters,\n} from '@/shared/parameter-schemas/account.zod';\nimport HederaParameterNormaliser from '@/shared/hedera-utils/hedera-parameter-normaliser';\nimport { PromptGenerator } from '@/shared/utils/prompt-generator';\n\nconst approveHbarAllowancePrompt = (context: Context = {}) => {\n  const contextSnippet = PromptGenerator.getContextSnippet(context);\n  const ownerAccountDesc = PromptGenerator.getAccountParameterDescription(\n    'ownerAccountId',\n    context,\n  );\n  const usageInstructions = PromptGenerator.getParameterUsageInstructions();\n\n  return `\n${contextSnippet}\n\nThis tool approves an HBAR allowance from the owner to the spender.\n\nParameters:\n- ${ownerAccountDesc}\n- spenderAccountId (string, required): Spender account ID\n- amount (number, required): Amount of HBAR to approve (can be decimal, cannot be negative)\n- transactionMemo (string, optional): Optional memo for the transaction\n${usageInstructions}\n`;\n};\n\nconst postProcess = (response: RawTransactionResponse) => {\n  return `HBAR allowance approved successfully. Transaction ID: ${response.transactionId}`;\n};\n\nconst approveHbarAllowance = async (\n  client: Client,\n  context: Context,\n  params: z.infer<ReturnType<typeof approveHbarAllowanceParameters>>,\n) => {\n  const normalisedParams = HederaParameterNormaliser.normaliseApproveHbarAllowance(\n    params,\n    context,\n    client,\n  );\n  const tx = HederaBuilder.approveHbarAllowance(normalisedParams);\n  const result = await handleTransaction(tx, client, context, postProcess);\n  return result;\n};\n\nexport const APPROVE_HBAR_ALLOWANCE_TOOL = 'approve_hbar_allowance_tool';\n\nconst tool = (context: Context): Tool => ({\n  method: APPROVE_HBAR_ALLOWANCE_TOOL,\n  name: 'Approve HBAR Allowance',\n  description: approveHbarAllowancePrompt(context),\n  parameters: approveHbarAllowanceParameters(context),\n  execute: approveHbarAllowance,\n});\n\nexport default tool;\n","import { z } from 'zod';\nimport type { Context } from '@/shared/configuration';\nimport type { Tool } from '@/shared/tools';\nimport { Client, Status } from '@hashgraph/sdk';\nimport { handleTransaction, RawTransactionResponse } from '@/shared/strategies/tx-mode-strategy';\nimport HederaBuilder from '@/shared/hedera-utils/hedera-builder';\nimport { createAccountParameters } from '@/shared/parameter-schemas/account.zod';\nimport HederaParameterNormaliser from '@/shared/hedera-utils/hedera-parameter-normaliser';\nimport { PromptGenerator } from '@/shared/utils/prompt-generator';\nimport { getMirrornodeService } from '@/shared/hedera-utils/mirrornode/hedera-mirrornode-utils';\n\nconst createAccountPrompt = (context: Context = {}) => {\n  const contextSnippet = PromptGenerator.getContextSnippet(context);\n  const usageInstructions = PromptGenerator.getParameterUsageInstructions();\n\n  return `\n${contextSnippet}\n\nThis tool will create a new Hedera account with a passed public key. If not passed, the tool will use operators public key.\n\nParameters:\n- publicKey (string, optional): Public key to use for the account. If not provided, the tool will use the operators public key.\n- accountMemo (string, optional): Optional memo for the account\n- initialBalance (number, optional, default 0): Initial HBAR to fund the account\n- maxAutomaticTokenAssociations (number, optional, default -1): -1 means unlimited\n${usageInstructions}\n`;\n};\n\nconst postProcess = (response: RawTransactionResponse) => {\n  const accountIdStr = response.accountId ? response.accountId.toString() : 'unknown';\n  return `Account created successfully.\\nTransaction ID: ${response.transactionId}\\nNew Account ID: ${accountIdStr}\\n}`;\n};\n\nconst createAccount = async (\n  client: Client,\n  context: Context,\n  params: z.infer<ReturnType<typeof createAccountParameters>>,\n) => {\n  try {\n    const mirrornodeService = getMirrornodeService(context.mirrornodeService!, client.ledgerId!);\n\n    // Normalise params to match AccountCreateTransaction props\n    const normalisedParams = await HederaParameterNormaliser.normaliseCreateAccount(\n      params,\n      context,\n      client,\n      mirrornodeService,\n    );\n\n    // Build transaction\n    const tx = HederaBuilder.createAccount(normalisedParams);\n\n    const result = await handleTransaction(tx, client, context, postProcess);\n    return result;\n  } catch (error) {\n    const desc = 'Failed to create account';\n    const message = desc + (error instanceof Error ? `: ${error.message}` : '');\n    console.error('[create_account_tool]', message);\n    return { raw: { status: Status.InvalidTransaction, error: message }, humanMessage: message };\n  }\n};\n\nexport const CREATE_ACCOUNT_TOOL = 'create_account_tool';\n\nconst tool = (context: Context): Tool => ({\n  method: CREATE_ACCOUNT_TOOL,\n  name: 'Create Account',\n  description: createAccountPrompt(context),\n  parameters: createAccountParameters(context),\n  execute: createAccount,\n});\n\nexport default tool;\n","import { z } from 'zod';\nimport type { Context } from '@/shared/configuration';\nimport type { Tool } from '@/shared/tools';\nimport { Client, Status } from '@hashgraph/sdk';\nimport { handleTransaction, RawTransactionResponse } from '@/shared/strategies/tx-mode-strategy';\nimport HederaBuilder from '@/shared/hedera-utils/hedera-builder';\nimport { PromptGenerator } from '@/shared/utils/prompt-generator';\nimport { deleteAccountParameters } from '@/shared/parameter-schemas/account.zod';\nimport HederaParameterNormaliser from '@/shared/hedera-utils/hedera-parameter-normaliser';\n\nconst deleteAccountPrompt = (context: Context = {}) => {\n  const contextSnippet = PromptGenerator.getContextSnippet(context);\n  const accountDesc = PromptGenerator.getAccountParameterDescription('accountId', context);\n  const usageInstructions = PromptGenerator.getParameterUsageInstructions();\n\n  return `\n${contextSnippet}\n\nThis tool will delete an existing Hedera account. The remaining balance of the account will be transferred to the transferAccountId if provided, otherwise the operator account will be used.\n\nParameters:\n- ${accountDesc}\n- accountId (str, required): The account ID to delete\n- transferAccountId (str, optional): The account ID to transfer the remaining balance to. If not provided, the operator account will be used.\n${usageInstructions}\n`;\n};\n\nconst postProcess = (response: RawTransactionResponse) => {\n  return `Account successfully deleted. Transaction ID: ${response.transactionId}`;\n};\n\nconst deleteAccount = async (\n  client: Client,\n  context: Context,\n  params: z.infer<ReturnType<typeof deleteAccountParameters>>,\n) => {\n  try {\n    const normalisedParams = HederaParameterNormaliser.normaliseDeleteAccount(\n      params,\n      context,\n      client,\n    );\n\n    let tx = HederaBuilder.deleteAccount(normalisedParams);\n\n    const result = await handleTransaction(tx, client, context, postProcess);\n    return result;\n  } catch (error) {\n    const desc = 'Failed to delete account';\n    const message = desc + (error instanceof Error ? `: ${error.message}` : '');\n    console.error('[delete_account_tool]', message);\n    return { raw: { status: Status.InvalidTransaction, error: message }, humanMessage: message };\n  }\n};\n\nexport const DELETE_ACCOUNT_TOOL = 'delete_account_tool';\n\nconst tool = (context: Context): Tool => ({\n  method: DELETE_ACCOUNT_TOOL,\n  name: 'Delete Account',\n  description: deleteAccountPrompt(context),\n  parameters: deleteAccountParameters(context),\n  execute: deleteAccount,\n});\n\nexport default tool;\n","import { z } from 'zod';\nimport type { Context } from '@/shared/configuration';\nimport type { Tool } from '@/shared/tools';\nimport { Client, Status } from '@hashgraph/sdk';\nimport { handleTransaction, RawTransactionResponse } from '@/shared/strategies/tx-mode-strategy';\nimport HederaBuilder from '@/shared/hedera-utils/hedera-builder';\nimport HederaParameterNormaliser from '@/shared/hedera-utils/hedera-parameter-normaliser';\nimport { PromptGenerator } from '@/shared/utils/prompt-generator';\nimport { updateAccountParameters } from '@/shared/parameter-schemas/account.zod';\n\nconst updateAccountPrompt = (context: Context = {}) => {\n  const contextSnippet = PromptGenerator.getContextSnippet(context);\n  const accountDesc = PromptGenerator.getAccountParameterDescription('accountId', context);\n  const usageInstructions = PromptGenerator.getParameterUsageInstructions();\n\n  return `\n${contextSnippet}\n\nThis tool will update an existing Hedera account. Only provided fields will be updated.\n\nParameters:\n- ${accountDesc}\n- accountId (string, optional) Account ID to update (e.g., 0.0.xxxxx). If not provided, operator account ID will be used\n- maxAutomaticTokenAssociations (number, optional)\n- stakedAccountId (string, optional)\n- accountMemo (string, optional)\n- declineStakingReward (boolean, optional)\n${usageInstructions}\n`;\n};\n\nconst postProcess = (response: RawTransactionResponse) => {\n  return `Account successfully updated. Transaction ID: ${response.transactionId}`;\n};\n\nconst updateAccount = async (\n  client: Client,\n  context: Context,\n  params: z.infer<ReturnType<typeof updateAccountParameters>>,\n) => {\n  try {\n    const normalisedParams = HederaParameterNormaliser.normaliseUpdateAccount(\n      params,\n      context,\n      client,\n    );\n\n    let tx = HederaBuilder.updateAccount(normalisedParams);\n\n    const result = await handleTransaction(tx, client, context, postProcess);\n    return result;\n  } catch (error) {\n    const desc = 'Failed to update account';\n    const message = desc + (error instanceof Error ? `: ${error.message}` : '');\n    console.error('[update_account_tool]', message);\n    return { raw: { status: Status.InvalidTransaction, error: message }, humanMessage: message };\n  }\n};\n\nexport const UPDATE_ACCOUNT_TOOL = 'update_account_tool';\n\nconst tool = (context: Context): Tool => ({\n  method: UPDATE_ACCOUNT_TOOL,\n  name: 'Update Account',\n  description: updateAccountPrompt(context),\n  parameters: updateAccountParameters(context),\n  execute: updateAccount,\n});\n\nexport default tool;\n","import { z } from 'zod';\nimport type { Context } from '@/shared/configuration';\nimport type { Tool } from '@/shared/tools';\nimport { Client, Status } from '@hashgraph/sdk';\nimport { handleTransaction, RawTransactionResponse } from '@/shared/strategies/tx-mode-strategy';\nimport HederaBuilder from '@/shared/hedera-utils/hedera-builder';\nimport { signScheduleTransactionParameters } from '@/shared/parameter-schemas/account.zod';\nimport { PromptGenerator } from '@/shared/utils/prompt-generator';\n\nconst signScheduleTransactionPrompt = (context: Context = {}) => {\n  const contextSnippet = PromptGenerator.getContextSnippet(context);\n  const usageInstructions = PromptGenerator.getParameterUsageInstructions();\n\n  return `\n${contextSnippet}\n\nThis tool will sign a scheduled transaction and return the transaction ID.\n\nParameters:\n- scheduleId (string, required): The ID of the scheduled transaction to sign\n${usageInstructions}\n`;\n};\n\nconst postProcess = (response: RawTransactionResponse) => {\n  return `Transaction successfully signed. Transaction ID: ${response.transactionId}`;\n};\n\nconst signScheduleTransaction = async (\n  client: Client,\n  context: Context,\n  params: z.infer<ReturnType<typeof signScheduleTransactionParameters>>,\n) => {\n  try {\n    const tx = HederaBuilder.signScheduleTransaction(params);\n    const result = await handleTransaction(tx, client, context, postProcess);\n    return result;\n  } catch (error) {\n    const desc = 'Failed to sign scheduled transaction';\n    const message = desc + (error instanceof Error ? `: ${error.message}` : '');\n    console.error('[sign_schedule_transaction_tool]', message);\n    return { raw: { status: Status.InvalidTransaction, error: message }, humanMessage: message };\n  }\n};\n\nexport const SIGN_SCHEDULE_TRANSACTION_TOOL = 'sign_schedule_transaction_tool';\n\nconst tool = (context: Context): Tool => ({\n  method: SIGN_SCHEDULE_TRANSACTION_TOOL,\n  name: 'Sign Scheduled Transaction',\n  description: signScheduleTransactionPrompt(context),\n  parameters: signScheduleTransactionParameters(context),\n  execute: signScheduleTransaction,\n});\n\nexport default tool;\n","import { z } from 'zod';\nimport type { Context } from '@/shared/configuration';\nimport type { Tool } from '@/shared/tools';\nimport { Client, Status } from '@hashgraph/sdk';\nimport { handleTransaction, RawTransactionResponse } from '@/shared/strategies/tx-mode-strategy';\nimport HederaBuilder from '@/shared/hedera-utils/hedera-builder';\nimport { scheduleDeleteTransactionParameters } from '@/shared/parameter-schemas/account.zod';\nimport { PromptGenerator } from '@/shared/utils/prompt-generator';\n\nconst scheduleDeletePrompt = (context: Context = {}) => {\n  const contextSnippet = PromptGenerator.getContextSnippet(context);\n  const usageInstructions = PromptGenerator.getParameterUsageInstructions();\n\n  return `\n${contextSnippet}\n\nThis tool will delete a scheduled transaction (by admin) so it will not execute.\n\nParameters:\n- scheduleId (string, required): The ID of the scheduled transaction to delete\n${usageInstructions}\n`;\n};\n\nconst postProcess = (response: RawTransactionResponse) => {\n  return `Scheduled transaction successfully deleted. Transaction ID: ${response.transactionId}`;\n};\n\nconst scheduleDelete = async (\n  client: Client,\n  context: Context,\n  params: z.infer<ReturnType<typeof scheduleDeleteTransactionParameters>>,\n) => {\n  try {\n    const tx = HederaBuilder.deleteScheduleTransaction(params);\n    const result = await handleTransaction(tx, client, context, postProcess);\n    return result;\n  } catch (error) {\n    const desc = 'Failed to delete scheduled transaction';\n    const message = desc + (error instanceof Error ? `: ${error.message}` : '');\n    console.error('[schedule_delete_tool]', message);\n    return { raw: { status: Status.InvalidTransaction, error: message }, humanMessage: message };\n  }\n};\n\nexport const SCHEDULE_DELETE_TOOL = 'schedule_delete_tool';\n\nconst tool = (context: Context): Tool => ({\n  method: SCHEDULE_DELETE_TOOL,\n  name: 'Delete Scheduled Transaction',\n  description: scheduleDeletePrompt(context),\n  parameters: scheduleDeleteTransactionParameters(context),\n  execute: scheduleDelete,\n});\n\nexport default tool;\n\n\n","import { Context } from '@/shared';\nimport { Plugin } from '@/shared/plugin';\nimport transferHbarTool, {\n  TRANSFER_HBAR_TOOL,\n} from '@/plugins/core-account-plugin/tools/account/transfer-hbar';\nimport approveHbarAllowanceTool, {\n  APPROVE_HBAR_ALLOWANCE_TOOL,\n} from '@/plugins/core-account-plugin/tools/account/approve-hbar-allowance';\nimport createAccountTool, {\n  CREATE_ACCOUNT_TOOL,\n} from '@/plugins/core-account-plugin/tools/account/create-account';\n\nimport deleteAccountTool, {\n  DELETE_ACCOUNT_TOOL,\n} from '@/plugins/core-account-plugin/tools/account/delete-account';\n\nimport updateAccountTool, {\n  UPDATE_ACCOUNT_TOOL,\n} from '@/plugins/core-account-plugin/tools/account/update-account';\n\nimport signScheduleTransactionTool, {\n  SIGN_SCHEDULE_TRANSACTION_TOOL,\n} from '@/plugins/core-account-plugin/tools/account/sign-schedule-transaction';\nimport scheduleDeleteTool, {\n  SCHEDULE_DELETE_TOOL,\n} from '@/plugins/core-account-plugin/tools/account/schedule-delete';\n\nexport const coreAccountPlugin: Plugin = {\n  name: 'core-account-plugin',\n  version: '1.0.0',\n  description: 'A plugin for the Hedera Account Service',\n  tools: (context: Context) => {\n    return [\n      transferHbarTool(context),\n      approveHbarAllowanceTool(context),\n      deleteAccountTool(context),\n      updateAccountTool(context),\n      createAccountTool(context),\n      signScheduleTransactionTool(context),\n      scheduleDeleteTool(context),\n    ];\n  },\n};\n\nexport const coreAccountPluginToolNames = {\n  TRANSFER_HBAR_TOOL,\n  APPROVE_HBAR_ALLOWANCE_TOOL,\n  CREATE_ACCOUNT_TOOL,\n  DELETE_ACCOUNT_TOOL,\n  UPDATE_ACCOUNT_TOOL,\n  SIGN_SCHEDULE_TRANSACTION_TOOL,\n  SCHEDULE_DELETE_TOOL,\n} as const;\n\nexport default { coreAccountPlugin, coreAccountPluginToolNames };\n","import { z } from 'zod';\nimport type { Context } from '@/shared/configuration';\nimport type { Tool } from '@/shared/tools';\nimport { Client, Status } from '@hashgraph/sdk';\nimport { handleTransaction, RawTransactionResponse } from '@/shared/strategies/tx-mode-strategy';\nimport HederaBuilder from '@/shared/hedera-utils/hedera-builder';\nimport { createTopicParameters } from '@/shared/parameter-schemas/consensus.zod';\nimport HederaParameterNormaliser from '@/shared/hedera-utils/hedera-parameter-normaliser';\nimport { getMirrornodeService } from '@/shared/hedera-utils/mirrornode/hedera-mirrornode-utils';\nimport { IHederaMirrornodeService } from '@/shared/hedera-utils/mirrornode/hedera-mirrornode-service.interface';\nimport { PromptGenerator } from '@/shared/utils/prompt-generator';\n\nconst createTopicPrompt = (_context: Context = {}) => {\n  const usageInstructions = PromptGenerator.getParameterUsageInstructions();\n\n  return `\nThis tool will create a new topic on the Hedera network.\n\nParameters:\n- topicMemo (str, optional): A memo for the topic\n- transactionMemo (str, optional): An optional memo to include on the submitted transaction\n- isSubmitKey (bool, optional): Whether to set a submit key for the topic. Set to true if user wants to set a submit key, otherwise false\n${usageInstructions}\n`;\n};\n\nconst postProcess = (response: RawTransactionResponse) => {\n  return `Topic created successfully with topic id ${response.topicId?.toString()} and transaction id ${response.transactionId.toString()}`;\n};\n\nconst createTopic = async (\n  client: Client,\n  context: Context,\n  params: z.infer<ReturnType<typeof createTopicParameters>>,\n) => {\n  try {\n    const mirrornodeService: IHederaMirrornodeService = getMirrornodeService(\n      context.mirrornodeService!,\n      client.ledgerId!,\n    );\n    const normalisedParams = await HederaParameterNormaliser.normaliseCreateTopicParams(\n      params,\n      context,\n      client,\n      mirrornodeService,\n    );\n    const tx = HederaBuilder.createTopic(normalisedParams);\n    const result = await handleTransaction(tx, client, context, postProcess);\n    return result;\n  } catch (error) {\n    const desc = 'Failed to create topic';\n    const message = desc + (error instanceof Error ? `: ${error.message}` : '');\n    console.error('[create_topic_tool]', message);\n    return { raw: { status: Status.InvalidTransaction, error: message }, humanMessage: message };\n  }\n};\n\nexport const CREATE_TOPIC_TOOL = 'create_topic_tool';\n\nconst tool = (context: Context): Tool => ({\n  method: CREATE_TOPIC_TOOL,\n  name: 'Create Topic',\n  description: createTopicPrompt(context),\n  parameters: createTopicParameters(context),\n  execute: createTopic,\n});\n\nexport default tool;\n","import { z } from 'zod';\nimport type { Context } from '@/shared/configuration';\nimport type { Tool } from '@/shared/tools';\nimport { Client, Status } from '@hashgraph/sdk';\nimport { handleTransaction, RawTransactionResponse } from '@/shared/strategies/tx-mode-strategy';\nimport HederaBuilder from '@/shared/hedera-utils/hedera-builder';\nimport HederaParameterNormaliser from '@/shared/hedera-utils/hedera-parameter-normaliser';\nimport { getMirrornodeService } from '@/shared/hedera-utils/mirrornode/hedera-mirrornode-utils';\nimport { IHederaMirrornodeService } from '@/shared/hedera-utils/mirrornode/hedera-mirrornode-service.interface';\nimport { PromptGenerator } from '@/shared/utils/prompt-generator';\nimport { deleteTopicParameters } from '@/shared/parameter-schemas/consensus.zod';\n\nconst deleteTopicPrompt = (_context: Context = {}) => {\n  const usageInstructions = PromptGenerator.getParameterUsageInstructions();\n\n  return `\nThis tool will delete a given Hedera network topic.\n\nParameters:\n- topicId (str, required): id of topic to delete\n${usageInstructions}\n`;\n};\n\nconst postProcess = (response: RawTransactionResponse) => {\n  return `Topic with id ${response.topicId?.toString()} deleted successfully. Transaction id ${response.transactionId.toString()}`;\n};\n\nconst deleteTopic = async (\n  client: Client,\n  context: Context,\n  params: z.infer<ReturnType<typeof deleteTopicParameters>>,\n) => {\n  try {\n    const mirrornodeService: IHederaMirrornodeService = getMirrornodeService(\n      context.mirrornodeService!,\n      client.ledgerId!,\n    );\n    const normalisedParams = HederaParameterNormaliser.normaliseDeleteTopic(\n      params,\n      context,\n      client,\n      mirrornodeService,\n    );\n    const tx = HederaBuilder.deleteTopic(normalisedParams);\n    return await handleTransaction(tx, client, context, postProcess);\n  } catch (error) {\n    const desc = 'Failed to delete the topic';\n    const message = desc + (error instanceof Error ? `: ${error.message}` : '');\n    console.error('[delete_topic_tool]', message);\n    return { raw: { status: Status.InvalidTransaction, error: message }, humanMessage: message };\n  }\n};\n\nexport const DELETE_TOPIC_TOOL = 'delete_topic_tool';\n\nconst tool = (context: Context): Tool => ({\n  method: DELETE_TOPIC_TOOL,\n  name: 'Delete Topic',\n  description: deleteTopicPrompt(context),\n  parameters: deleteTopicParameters(context),\n  execute: deleteTopic,\n});\n\nexport default tool;\n","import { z } from 'zod';\nimport type { Context } from '@/shared/configuration';\nimport type { Tool } from '@/shared/tools';\nimport { Client, Status } from '@hashgraph/sdk';\nimport { handleTransaction, RawTransactionResponse } from '@/shared/strategies/tx-mode-strategy';\nimport HederaBuilder from '@/shared/hedera-utils/hedera-builder';\nimport { submitTopicMessageParameters } from '@/shared/parameter-schemas/consensus.zod';\nimport { PromptGenerator } from '@/shared/utils/prompt-generator';\n\nconst submitTopicMessagePrompt = (_context: Context = {}) => {\n  const usageInstructions = PromptGenerator.getParameterUsageInstructions();\n\n  return `\nThis tool will submit a message to a topic on the Hedera network.\n\nParameters:\n- topicId (str, required): The ID of the topic to submit the message to\n- message (str, required): The message to submit to the topic\n- transactionMemo (str, optional): An optional memo to include on the transaction\n${usageInstructions}\n`;\n};\n\nconst postProcess = (response: RawTransactionResponse) => {\n  return `Message submitted successfully with transaction id ${response.transactionId.toString()}`;\n};\n\nconst submitTopicMessage = async (\n  client: Client,\n  context: Context,\n  params: z.infer<ReturnType<typeof submitTopicMessageParameters>>,\n) => {\n  try {\n    const tx = HederaBuilder.submitTopicMessage(params);\n    const result = await handleTransaction(tx, client, context, postProcess);\n    return { ...result, topicId: params.topicId };\n  } catch (error) {\n    const desc = 'Failed to submit message to topic';\n    const message = desc + (error instanceof Error ? `: ${error.message}` : '');\n    console.error('[submit_topic_message_tool]', message);\n    return { raw: { status: Status.InvalidTransaction, error: message }, humanMessage: message };\n  }\n};\n\nexport const SUBMIT_TOPIC_MESSAGE_TOOL = 'submit_topic_message_tool';\n\nconst tool = (context: Context): Tool => ({\n  method: SUBMIT_TOPIC_MESSAGE_TOOL,\n  name: 'Submit Topic Message',\n  description: submitTopicMessagePrompt(context),\n  parameters: submitTopicMessageParameters(context),\n  execute: submitTopicMessage,\n});\n\nexport default tool;\n","import { z } from 'zod';\nimport type { Context } from '@/shared/configuration';\nimport type { Tool } from '@/shared/tools';\nimport { Client, PublicKey, Status } from '@hashgraph/sdk';\nimport { handleTransaction, RawTransactionResponse } from '@/shared/strategies/tx-mode-strategy';\nimport HederaBuilder from '@/shared/hedera-utils/hedera-builder';\nimport HederaParameterNormaliser from '@/shared/hedera-utils/hedera-parameter-normaliser';\nimport { PromptGenerator } from '@/shared/utils/prompt-generator';\nimport { IHederaMirrornodeService } from '@/shared/hedera-utils/mirrornode/hedera-mirrornode-service.interface';\nimport { getMirrornodeService } from '@/shared/hedera-utils/mirrornode/hedera-mirrornode-utils';\nimport { AccountResolver } from '@/shared';\nimport {\n  updateTopicParameters,\n  updateTopicParametersNormalised,\n} from '@/shared/parameter-schemas/consensus.zod';\nimport { TopicInfo } from '@/shared/hedera-utils/mirrornode/types';\n\nconst checkValidityOfUpdates = async (\n  params: z.infer<ReturnType<typeof updateTopicParametersNormalised>>,\n  mirrornode: IHederaMirrornodeService,\n  userPublicKey: PublicKey,\n) => {\n  const topicDetails: TopicInfo = await mirrornode.getTopicInfo(params.topicId.toString());\n  if (!topicDetails) {\n    throw new Error('Topic not found');\n  }\n\n  if (topicDetails.admin_key === undefined) {\n    throw new Error('Topic does not have an admin key. It cannot be updated.');\n  }\n\n  if (topicDetails.admin_key!.key !== userPublicKey.toStringRaw()) {\n    console.error(\n      `topicDetails.admin_key.key: ${topicDetails.admin_key?.key} vs userPublicKey: ${userPublicKey.toStringRaw()}`,\n    );\n    throw new Error(\n      'You do not have permission to update this topic. The adminKey does not match your public key.',\n    );\n  }\n\n  // If a user attempts to set a key but the topic was created without that key, disallow\n  const keyChecks: Partial<Record<keyof typeof params, keyof TopicInfo>> = {\n    adminKey: 'admin_key',\n    submitKey: 'submit_key',\n  };\n\n  for (const [paramKey, topicField] of Object.entries(keyChecks) as [\n    keyof typeof params,\n    keyof TopicInfo,\n  ][]) {\n    const userValue = params[paramKey];\n    const topicKey = topicDetails[topicField as keyof TopicInfo];\n\n    if (userValue instanceof PublicKey && !topicKey) {\n      throw new Error(`Cannot update ${paramKey}: topic was created without a ${paramKey}`);\n    }\n  }\n};\n\nconst updateTopicPrompt = (context: Context = {}) => {\n  const contextSnippet = PromptGenerator.getContextSnippet(context);\n  const topicDesc = PromptGenerator.getAnyAddressParameterDescription('topicId', context);\n  const usageInstructions = PromptGenerator.getParameterUsageInstructions();\n\n  return `\n${contextSnippet}\nThis tool will update an existing Hedera Consensus Topic. Only the fields provided will be updated.\nKey fields (adminKey, submitKey) must contain **Hedera-compatible public keys (as strings) or boolean (true/false)**. You can provide these in one of three ways:\n1. **Boolean true** – Set this field to use user/operator key. Injecting of the key will be handled automatically.\n2. **Not provided** – The field will not be updated.\n3. **String** – Provide a Hedera-compatible public key string to set a field explicitly.\n\nParameters:\n- ${topicDesc}\n- topicMemo (string, optional): New memo for the topic.\n- adminKey (boolean|string, optional): New admin key. Pass true to use your operator key, or provide a public key string.\n- submitKey (boolean|string, optional): New submit key. Pass true to use your operator key, or provide a public key string.\n- autoRenewAccountId (string, optional): Account to automatically pay for renewal.\n- autoRenewPeriod (number, optional): Auto renew period in seconds.\n- expirationTime (string|Date, optional): New expiration time for the topic (ISO string or Date).\nExamples:\n- If the user asks for \"my key\" → set the field to \\`true\\`.\n- If the user does not mention the key → do not set the field.\n- If the user provides a key → set the field to the provided public key string.\n\nIf the user provides multiple fields in a single request, \ncombine them into **one tool call** with all parameters together.\n${usageInstructions}\n`;\n};\n\nconst postProcess = (response: RawTransactionResponse) => {\n  return `Topic successfully updated. Transaction ID: ${response.transactionId}`;\n};\n\nconst updateTopic = async (\n  client: Client,\n  context: Context,\n  params: z.infer<ReturnType<typeof updateTopicParameters>>,\n) => {\n  try {\n    const normalisedParams = await HederaParameterNormaliser.normaliseUpdateTopic(\n      params,\n      context,\n      client,\n    );\n    const mirrornodeService = getMirrornodeService(context.mirrornodeService!, client.ledgerId!);\n    const userPublicKey = await AccountResolver.getDefaultPublicKey(context, client);\n\n    await checkValidityOfUpdates(normalisedParams, mirrornodeService, userPublicKey);\n\n    const tx = HederaBuilder.updateTopic(normalisedParams);\n\n    return await handleTransaction(tx, client, context, postProcess);\n  } catch (error) {\n    const desc = 'Failed to update topic';\n    const message = desc + (error instanceof Error ? `: ${error.message}` : '');\n    console.error('[update_topic_tool]', message);\n    return {\n      raw: { status: Status.InvalidTransaction, error: message },\n      humanMessage: message,\n    };\n  }\n};\n\nexport const UPDATE_TOPIC_TOOL = 'update_topic_tool';\n\nconst tool = (context: Context): Tool => ({\n  method: UPDATE_TOPIC_TOOL,\n  name: 'Update Topic',\n  description: updateTopicPrompt(context),\n  parameters: updateTopicParameters(context),\n  execute: updateTopic,\n});\n\nexport default tool;\n","import { Context } from '@/shared';\nimport { Plugin } from '@/shared/plugin';\nimport createTopicTool, {\n  CREATE_TOPIC_TOOL,\n} from '@/plugins/core-consensus-plugin/tools/consensus/create-topic';\nimport deleteTopicTool, {\n  DELETE_TOPIC_TOOL,\n} from '@/plugins/core-consensus-plugin/tools/consensus/delete-topic';\nimport submitTopicMessageTool, {\n  SUBMIT_TOPIC_MESSAGE_TOOL,\n} from '@/plugins/core-consensus-plugin/tools/consensus/submit-topic-message';\nimport updateTopicTool, {\n  UPDATE_TOPIC_TOOL,\n} from '@/plugins/core-consensus-plugin/tools/consensus/update-topic';\n\nexport const coreConsensusPlugin: Plugin = {\n  name: 'core-consensus-plugin',\n  version: '1.0.0',\n  description: 'A plugin for the Hedera Consensus Service',\n  tools: (context: Context) => {\n    return [\n      createTopicTool(context),\n      submitTopicMessageTool(context),\n      deleteTopicTool(context),\n      updateTopicTool(context),\n    ];\n  },\n};\n\nexport const coreConsensusPluginToolNames = {\n  CREATE_TOPIC_TOOL,\n  SUBMIT_TOPIC_MESSAGE_TOOL,\n  DELETE_TOPIC_TOOL,\n  UPDATE_TOPIC_TOOL,\n} as const;\n\nexport default { coreConsensusPlugin, coreConsensusPluginToolNames };\n","/**\n * Converts a tinybar amount to a hbar amount.\n * @param tinyBars - The tinybar amount.\n * @returns The hbar amount.\n */\nexport function toHBar(tinyBars: BigNumber): BigNumber {\n  return tinyBars.div(100000000);\n}\n","import { z } from 'zod';\nimport type { Context } from '@/shared/configuration';\nimport type { Tool } from '@/shared/tools';\nimport { Client } from '@hashgraph/sdk';\nimport { accountBalanceQueryParameters } from '@/shared/parameter-schemas/account.zod';\nimport BigNumber from 'bignumber.js';\nimport { getMirrornodeService } from '@/shared/hedera-utils/mirrornode/hedera-mirrornode-utils';\nimport HederaParameterNormaliser from '@/shared/hedera-utils/hedera-parameter-normaliser';\nimport { PromptGenerator } from '@/shared/utils/prompt-generator';\nimport { toHBar } from '@/shared/hedera-utils/hbar-conversion-utils';\n\nexport const getHbarBalanceQueryPrompt = (context: Context = {}) => {\n  const contextSnippet = PromptGenerator.getContextSnippet(context);\n  const accountDesc = PromptGenerator.getAccountParameterDescription('accountId', context);\n  const usageInstructions = PromptGenerator.getParameterUsageInstructions();\n\n  return `\n${contextSnippet}\n\nThis tool will return the HBAR balance for a given Hedera account.\n\nParameters:\n- ${accountDesc}\n${usageInstructions}\n`;\n};\n\nconst postProcess = (hbarBalance: string, accountId: string) => {\n  return `Account ${accountId} has a balance of ${hbarBalance} HBAR`;\n};\n\nexport const getHbarBalanceQuery = async (\n  client: Client,\n  context: Context,\n  params: z.infer<ReturnType<typeof accountBalanceQueryParameters>>,\n) => {\n  try {\n    const normalisedParams = HederaParameterNormaliser.normaliseHbarBalanceParams(\n      params,\n      context,\n      client,\n    );\n    const mirrornodeService = getMirrornodeService(context.mirrornodeService!, client.ledgerId!);\n    const balance: BigNumber = await mirrornodeService.getAccountHBarBalance(\n      normalisedParams.accountId,\n    );\n    return {\n      raw: { accountId: normalisedParams.accountId, hbarBalance: toHBar(balance).toString() },\n      humanMessage: postProcess(toHBar(balance).toString() as string, normalisedParams.accountId),\n    };\n  } catch (error) {\n    const desc = 'Failed to get HBAR balance';\n    const message = desc + (error instanceof Error ? `: ${error.message}` : '');\n    console.error('[get_hbar_balance_query_tool]', message);\n    return { raw: { error: message }, humanMessage: message };\n  }\n};\n\nexport const GET_HBAR_BALANCE_QUERY_TOOL = 'get_hbar_balance_query_tool';\n\nconst tool = (context: Context): Tool => ({\n  method: GET_HBAR_BALANCE_QUERY_TOOL,\n  name: 'Get HBAR Balance',\n  description: getHbarBalanceQueryPrompt(context),\n  parameters: accountBalanceQueryParameters(context),\n  execute: getHbarBalanceQuery,\n});\n\nexport default tool;\n","import { z } from 'zod';\nimport { Client, Status } from '@hashgraph/sdk';\nimport { Context } from '@/shared/configuration';\nimport { getMirrornodeService } from '@/shared/hedera-utils/mirrornode/hedera-mirrornode-utils';\nimport { Tool } from '@/shared/tools';\nimport { PromptGenerator } from '@/shared/utils/prompt-generator';\nimport { AccountResponse } from '@/shared/hedera-utils/mirrornode/types';\nimport { accountQueryParameters } from '@/shared/parameter-schemas/account.zod';\n\nexport const getAccountQueryPrompt = (context: Context = {}) => {\n  const contextSnippet = PromptGenerator.getContextSnippet(context);\n  const usageInstructions = PromptGenerator.getParameterUsageInstructions();\n\n  return `\n${contextSnippet}\n\nThis tool will return the account information for a given Hedera account.\n\nParameters:\n- accountId (str, required): The account ID to query\n${usageInstructions}\n`;\n};\n\nconst postProcess = (account: AccountResponse) => {\n  return `Details for ${account.accountId}\nBalance: ${account.balance.balance.toString()}\nPublic Key: ${account.accountPublicKey},\nEVM address: ${account.evmAddress},\n`;\n};\n\nexport const getAccountQuery = async (\n  client: Client,\n  context: Context,\n  params: z.infer<ReturnType<typeof accountQueryParameters>>,\n) => {\n  try {\n    const mirrornodeService = getMirrornodeService(context.mirrornodeService!, client.ledgerId!);\n    const account = await mirrornodeService.getAccount(params.accountId);\n    return {\n      raw: { accountId: params.accountId, account: account },\n      humanMessage: postProcess(account),\n    };\n  } catch (error) {\n    const desc = 'Failed to get account query';\n    const message = desc + (error instanceof Error ? `: ${error.message}` : '');\n    console.error('[get_account_query_tool]', message);\n    return { raw: { status: Status.InvalidTransaction, error: message }, humanMessage: message };\n  }\n};\n\nexport const GET_ACCOUNT_QUERY_TOOL = 'get_account_query_tool';\n\nconst tool = (context: Context): Tool => ({\n  method: GET_ACCOUNT_QUERY_TOOL,\n  name: 'Get Account Query',\n  description: getAccountQueryPrompt(context),\n  parameters: accountQueryParameters(context),\n  execute: getAccountQuery,\n});\n\nexport default tool;\n","import { z } from 'zod';\nimport { Context } from '@/shared/configuration';\nimport { getMirrornodeService } from '@/shared/hedera-utils/mirrornode/hedera-mirrornode-utils';\nimport { accountTokenBalancesQueryParameters } from '@/shared/parameter-schemas/account.zod';\nimport { Client } from '@hashgraph/sdk';\nimport { Tool } from '@/shared/tools';\nimport HederaParameterNormaliser from '@/shared/hedera-utils/hedera-parameter-normaliser';\nimport { PromptGenerator } from '@/shared/utils/prompt-generator';\nimport { TokenBalancesResponse } from '@/shared/hedera-utils/mirrornode/types';\n\nexport const getAccountTokenBalancesQueryPrompt = (context: Context = {}) => {\n  const contextSnippet = PromptGenerator.getContextSnippet(context);\n  const accountDesc = PromptGenerator.getAccountParameterDescription('accountId', context);\n  const usageInstructions = PromptGenerator.getParameterUsageInstructions();\n\n  return `\n${contextSnippet}\n\nThis tool will return the token balances for a given Hedera account.\n\nParameters:\n- ${accountDesc}\n- tokenId (str, optional): The token ID to query for. If not provided, all token balances will be returned\n${usageInstructions}\n`;\n};\n\nconst postProcess = (tokenBalances: TokenBalancesResponse, accountId: string) => {\n  const balancesText = tokenBalances.tokens\n    .map(\n      token => `  Token: ${token.token_id}, Balance: ${token.balance}, Decimals: ${token.decimals}`,\n    )\n    .join('\\n');\n\n  return `Details for ${accountId}\n--- Token Balances ---\n${balancesText}`;\n};\n\nexport const getAccountTokenBalancesQuery = async (\n  client: Client,\n  context: Context,\n  params: z.infer<ReturnType<typeof accountTokenBalancesQueryParameters>>,\n) => {\n  try {\n    const normalisedParams = HederaParameterNormaliser.normaliseAccountTokenBalancesParams(\n      params,\n      context,\n      client,\n    );\n    const mirrornodeService = getMirrornodeService(context.mirrornodeService!, client.ledgerId!);\n    const tokenBalances = await mirrornodeService.getAccountTokenBalances(\n      normalisedParams.accountId,\n      normalisedParams.tokenId,\n    );\n    return {\n      raw: { accountId: normalisedParams.accountId, tokenBalances: tokenBalances },\n      humanMessage: postProcess(tokenBalances, normalisedParams.accountId),\n    };\n  } catch (error) {\n    const desc = 'Failed to get account token balances';\n    const message = desc + (error instanceof Error ? `: ${error.message}` : '');\n    console.error('[get_account_token_balances_query_tool]', message);\n    return { raw: { error: message }, humanMessage: message };\n  }\n};\n\nexport const GET_ACCOUNT_TOKEN_BALANCES_QUERY_TOOL = 'get_account_token_balances_query_tool';\n\nconst tool = (context: Context): Tool => ({\n  method: GET_ACCOUNT_TOKEN_BALANCES_QUERY_TOOL,\n  name: 'Get Account Token Balances',\n  description: getAccountTokenBalancesQueryPrompt(context),\n  parameters: accountTokenBalancesQueryParameters(context),\n  execute: getAccountTokenBalancesQuery,\n});\n\nexport default tool;\n","import { Context } from '@/shared/configuration';\nimport { getMirrornodeService } from '@/shared/hedera-utils/mirrornode/hedera-mirrornode-utils';\nimport { topicMessagesQueryParameters } from '@/shared/parameter-schemas/consensus.zod';\nimport { Client } from '@hashgraph/sdk';\nimport { z } from 'zod';\nimport { Tool } from '@/shared/tools';\nimport { TopicMessage, TopicMessagesQueryParams } from '@/shared/hedera-utils/mirrornode/types';\nimport { PromptGenerator } from '@/shared/utils/prompt-generator';\n\nexport const getTopicMessagesQueryPrompt = (context: Context = {}) => {\n  const contextSnippet = PromptGenerator.getContextSnippet(context);\n  const usageInstructions = PromptGenerator.getParameterUsageInstructions();\n\n  return `\n${contextSnippet}\n\nThis tool will return the messages for a given Hedera topic.\n\nParameters:\n- topicId (str, required): The topic ID to query\n- startTime (datetime, optional): The start datetime to query. If set, the messages will be returned after this datetime\n- endTime (datetime, optional): The end datetime to query. If set, the messages will be returned before this datetime\n- limit (int, optional): The limit of messages to query. If set, the number of messages to return\n${usageInstructions}\n`;\n};\n\nconst postProcess = (messages: TopicMessage[], topicId: string) => {\n  const messagesText = messages.map(\n    message =>\n      `${Buffer.from(message.message, 'base64').toString('utf-8')} - posted at: ${message.consensus_timestamp}\\n`,\n  );\n\n  return `Messages for topic ${topicId}:\n  --- Messages ---\n  ${messagesText}\n  `;\n};\n\nconst getTopicMessagesQueryParams = (\n  params: z.infer<ReturnType<typeof topicMessagesQueryParameters>>,\n): TopicMessagesQueryParams => {\n  return {\n    topicId: params.topicId,\n    lowerTimestamp: params.startTime\n      ? `${Math.floor(new Date(params.startTime).getTime() / 1000)}.000000000`\n      : '',\n    upperTimestamp: params.endTime\n      ? `${Math.floor(new Date(params.endTime).getTime() / 1000)}.000000000`\n      : '',\n    limit: params.limit || 100,\n  };\n};\n\nconst convertMessagesFromBase64ToString = (messages: TopicMessage[]) => {\n  return messages.map(message => {\n    return {\n      ...message,\n      message: Buffer.from(message.message, 'base64').toString('utf-8'),\n    };\n  });\n};\n\nexport const getTopicMessagesQuery = async (\n  client: Client,\n  context: Context,\n  params: z.infer<ReturnType<typeof topicMessagesQueryParameters>>,\n) => {\n  try {\n    const mirrornodeService = getMirrornodeService(context.mirrornodeService!, client.ledgerId!);\n    const messages = await mirrornodeService.getTopicMessages(getTopicMessagesQueryParams(params));\n\n    return {\n      raw: {\n        topicId: messages.topicId,\n        messages: convertMessagesFromBase64ToString(messages.messages),\n      },\n      humanMessage: postProcess(messages.messages, params.topicId),\n    };\n  } catch (error) {\n    const desc = 'Failed to get topic messages';\n    const message = desc + (error instanceof Error ? `: ${error.message}` : '');\n    console.error('[get_topic_messages_query_tool]', message);\n    return { raw: { error: message }, humanMessage: message };\n  }\n};\n\nexport const GET_TOPIC_MESSAGES_QUERY_TOOL = 'get_topic_messages_query_tool';\n\nconst tool = (context: Context): Tool => ({\n  method: GET_TOPIC_MESSAGES_QUERY_TOOL,\n  name: 'Get Topic Messages',\n  description: getTopicMessagesQueryPrompt(context),\n  parameters: topicMessagesQueryParameters(context),\n  execute: getTopicMessagesQuery,\n});\n\nexport default tool;\n","import { z } from 'zod';\nimport { Context } from '@/shared/configuration';\nimport { getMirrornodeService } from '@/shared/hedera-utils/mirrornode/hedera-mirrornode-utils';\nimport { tokenInfoQueryParameters } from '@/shared/parameter-schemas/token.zod';\nimport { Client } from '@hashgraph/sdk';\nimport { Tool } from '@/shared/tools';\nimport { PromptGenerator } from '@/shared/utils/prompt-generator';\nimport { TokenInfo } from '@/shared/hedera-utils/mirrornode/types';\n\nexport const getTokenInfoQueryPrompt = (context: Context = {}) => {\n  const contextSnippet = PromptGenerator.getContextSnippet(context);\n  const usageInstructions = PromptGenerator.getParameterUsageInstructions();\n\n  return `\n${contextSnippet}\n\nThis tool will return the information for a given Hedera token.\n\nParameters:\n- tokenId (str): The token ID to query for.\n${usageInstructions}\n`;\n};\n\nconst postProcess = (tokenInfo: TokenInfo) => {\n  const formatSupply = (supply?: string) => {\n    if (!supply) return 'N/A';\n\n    const decimals = Number(tokenInfo.decimals || '0');\n    const amount = Number(supply);\n    if (isNaN(amount)) return supply;\n\n    return (amount / 10 ** decimals).toLocaleString();\n  };\n\n  const formatKey = (key?: { _type: string; key: string } | null) => {\n    if (!key) return 'Not Set';\n    return key._type ? `${key.key}` : 'Present';\n  };\n\n  const supplyType =\n    tokenInfo.supply_type === 'INFINITE' ? 'Infinite' : tokenInfo.max_supply || 'Finite';\n  const freezeStatus = tokenInfo.freeze_default ? 'Frozen' : 'Active';\n\n  return `Here are the details for token **${tokenInfo.token_id}**:\n\n- **Token Name**: ${tokenInfo.name}\n- **Token Symbol**: ${tokenInfo.symbol}\n- **Token Type**: ${tokenInfo.type || 'N/A'}\n- **Decimals**: ${tokenInfo.decimals}\n- **Max Supply**: ${formatSupply(tokenInfo.max_supply)}\n- **Current Supply**: ${formatSupply(tokenInfo.total_supply)}\n- **Supply Type**: ${supplyType}\n- **Treasury Account ID**: ${tokenInfo.treasury_account_id || 'N/A'}\n- **Status (Deleted/Active)**: ${tokenInfo.deleted ? 'Deleted' : 'Active'}\n- **Status (Frozen/Active)**: ${freezeStatus}\n\n**Keys**:\n- Admin Key: ${formatKey(tokenInfo.admin_key)}\n- Supply Key: ${formatKey(tokenInfo.supply_key)}\n- Wipe Key: ${formatKey(tokenInfo.wipe_key)}\n- KYC Key: ${formatKey(tokenInfo.kyc_key)}\n- Freeze Key: ${formatKey(tokenInfo.freeze_key)}\n- Fee Schedule Key: ${formatKey(tokenInfo.fee_schedule_key)}\n- Pause Key: ${formatKey(tokenInfo.pause_key)}\n- Metadata Key: ${formatKey(tokenInfo.metadata_key)}\n\n${tokenInfo.memo ? `**Memo**: ${tokenInfo.memo}` : ''}\n`;\n};\n\nexport const getTokenInfoQuery = async (\n  client: Client,\n  context: Context,\n  params: z.infer<ReturnType<typeof tokenInfoQueryParameters>>,\n) => {\n  try {\n    const mirrornodeService = getMirrornodeService(context.mirrornodeService!, client.ledgerId!);\n    const tokenInfo: TokenInfo = {\n      ...(await mirrornodeService.getTokenInfo(params.tokenId!)),\n      token_id: params.tokenId!,\n    };\n\n    return {\n      raw: { tokenId: params.tokenId, tokenInfo },\n      humanMessage: postProcess(tokenInfo),\n    };\n  } catch (error) {\n    const desc = 'Failed to get token info';\n    const message = desc + (error instanceof Error ? `: ${error.message}` : '');\n    console.error('[get_token_info_query_tool]', message);\n    return { raw: { error: message }, humanMessage: message };\n  }\n};\n\nexport const GET_TOKEN_INFO_QUERY_TOOL = 'get_token_info_query_tool';\n\nconst tool = (context: Context): Tool => ({\n  method: GET_TOKEN_INFO_QUERY_TOOL,\n  name: 'Get Token Info',\n  description: getTokenInfoQueryPrompt(context),\n  parameters: tokenInfoQueryParameters(context),\n  execute: getTokenInfoQuery,\n});\n\nexport default tool;\n","import { Plugin } from '@/shared/plugin';\nimport { Context } from '@/shared/configuration';\nimport getHbarBalanceQuery, {\n  GET_HBAR_BALANCE_QUERY_TOOL,\n} from '@/plugins/core-queries-plugin/tools/queries/get-hbar-balance-query';\nimport getAccountQuery, {\n  GET_ACCOUNT_QUERY_TOOL,\n} from '@/plugins/core-queries-plugin/tools/queries/get-account-query';\nimport getAccountTokenBalancesQuery, {\n  GET_ACCOUNT_TOKEN_BALANCES_QUERY_TOOL,\n} from '@/plugins/core-queries-plugin/tools/queries/get-account-token-balances-query';\nimport getTopicMessagesQuery, {\n  GET_TOPIC_MESSAGES_QUERY_TOOL,\n} from '@/plugins/core-queries-plugin/tools/queries/get-topic-messages-query';\nimport getTokenInfoQuery, {\n  GET_TOKEN_INFO_QUERY_TOOL,\n} from '@/plugins/core-queries-plugin/tools/queries/get-token-info-query';\n\n/**\n * @deprecated This plugin is deprecated. Use the specific query plugins instead:\n * - coreAccountQueryPlugin for account-related queries\n * - coreTokenQueryPlugin for token-related queries\n * - coreConsensusQueryPlugin for consensus-related queries\n * This export will be removed in a future version.\n */\nexport const coreQueriesPlugin: Plugin = {\n  name: 'core-queries-plugin',\n  version: '1.0.0',\n  description: 'A plugin for the Hedera Queries Service (DEPRECATED)',\n  tools: (context: Context) => {\n    return [\n      getHbarBalanceQuery(context),\n      getAccountQuery(context),\n      getAccountTokenBalancesQuery(context),\n      getTopicMessagesQuery(context),\n      getTokenInfoQuery(context),\n    ];\n  },\n};\n\n/**\n * @deprecated Use the specific query plugin tool names instead:\n * - coreAccountQueryPluginToolNames for account-related query tools\n * - coreTokenQueryPluginToolNames for token-related query tools\n * - coreConsensusQueryPluginToolNames for consensus-related query tools\n * This export will be removed in a future version.\n */\nexport const coreQueriesPluginToolNames = {\n  GET_HBAR_BALANCE_QUERY_TOOL,\n  GET_ACCOUNT_QUERY_TOOL,\n  GET_ACCOUNT_TOKEN_BALANCES_QUERY_TOOL,\n  GET_TOPIC_MESSAGES_QUERY_TOOL,\n  GET_TOKEN_INFO_QUERY_TOOL,\n} as const;\n\nexport default { coreQueriesPlugin, coreQueriesPluginToolNames };\n","import { Context } from '@/shared/configuration';\nimport { z } from 'zod';\n\nexport const exchangeRateQueryParameters = (_context: Context) =>\n  z.object({\n    timestamp: z\n      .string()\n      .describe('Historical timestamp to query (seconds or nanos since epoch)')\n      .optional(),\n  });\n","import { z } from 'zod';\nimport { Client } from '@hashgraph/sdk';\nimport { Context } from '@/shared/configuration';\nimport { getMirrornodeService } from '@/shared/hedera-utils/mirrornode/hedera-mirrornode-utils';\nimport { Tool } from '@/shared/tools';\nimport { PromptGenerator } from '@/shared/utils/prompt-generator';\nimport { ExchangeRateResponse } from '@/shared/hedera-utils/mirrornode/types';\nimport { exchangeRateQueryParameters } from '@/shared/parameter-schemas/core-misc.zod';\n\nexport const getExchangeRatePrompt = (context: Context = {}) => {\n  const contextSnippet = PromptGenerator.getContextSnippet(context);\n  const usageInstructions = PromptGenerator.getParameterUsageInstructions();\n\n  return `\n${contextSnippet}\n\nThis tool returns the Hedera network HBAR exchange rate from the Mirror Node.\n\nParameters:\n- timestamp (str, optional): Historical timestamp to query. Pass seconds or nanos since epoch (e.g., 1726000000.123456789). If omitted, returns the latest rate.\n${usageInstructions}\n`;\n};\n\nconst calculateUsdPerHBAR = (cent_equivalent: number, hbar_equivalent: number) => {\n  return cent_equivalent / 100 / hbar_equivalent;\n};\n\nconst postProcess = (rates: ExchangeRateResponse) => {\n  const { current_rate, next_rate, timestamp } = rates;\n\n  const usdPerHBAR = calculateUsdPerHBAR(\n    current_rate.cent_equivalent,\n    current_rate.hbar_equivalent,\n  );\n  const nextUsdPerHBAR = calculateUsdPerHBAR(next_rate.cent_equivalent, next_rate.hbar_equivalent);\n\n  return `\n  Details for timestamp: ${timestamp}\n  \n  Current exchange rate: ${usdPerHBAR}\n  Expires at ${new Date(current_rate.expiration_time * 1000).toISOString()})\n  \n  Next exchange rate: ${nextUsdPerHBAR}\n  Expires at ${new Date(next_rate.expiration_time * 1000).toISOString()})`;\n};\n\nexport const getExchangeRateQuery = async (\n  client: Client,\n  context: Context,\n  params: z.infer<ReturnType<typeof exchangeRateQueryParameters>>,\n) => {\n  try {\n    const mirrornodeService = getMirrornodeService(context.mirrornodeService!, client.ledgerId!);\n    const rates: ExchangeRateResponse = await mirrornodeService.getExchangeRate(params.timestamp);\n    return {\n      raw: rates,\n      humanMessage: postProcess(rates),\n    };\n  } catch (error) {\n    console.error('[GetExchangeRate] Error getting exchange rate', error);\n    const message = error instanceof Error ? error.message : 'Failed to get exchange rate';\n\n    return {\n      raw: { error: message },\n      humanMessage: message,\n    };\n  }\n};\n\nexport const GET_EXCHANGE_RATE_TOOL = 'get_exchange_rate_tool';\n\nconst tool = (context: Context): Tool => ({\n  method: GET_EXCHANGE_RATE_TOOL,\n  name: 'Get Exchange Rate',\n  description: getExchangeRatePrompt(context),\n  parameters: exchangeRateQueryParameters(context),\n  execute: getExchangeRateQuery,\n});\n\nexport default tool;\n","import { Plugin } from '@/shared/plugin';\nimport { Context } from '@/shared/configuration';\nimport getExchangeRateQuery, {\n  GET_EXCHANGE_RATE_TOOL,\n} from '@/plugins/core-misc-query-plugin/tools/queries/get-exchange-rate-query';\n\nexport const coreMiscQueriesPlugin: Plugin = {\n  name: 'core-misc-queries-plugin',\n  version: '1.0.0',\n  description: 'A plugin for Hedera Misc Queries',\n  tools: (context: Context) => {\n    return [getExchangeRateQuery(context)];\n  },\n};\n\nexport const coreMiscQueriesPluginsToolNames = {\n  GET_EXCHANGE_RATE_TOOL,\n} as const;\n\nexport default { coreMiscQueriesPluginsToolNames };\n","import { z } from 'zod';\nimport { AgentMode, type Context } from '@/shared/configuration';\nimport type { Tool } from '@/shared/tools';\nimport { Client, Status, TransactionRecordQuery } from '@hashgraph/sdk';\nimport { ExecuteStrategyResult, handleTransaction } from '@/shared/strategies/tx-mode-strategy';\nimport { createERC20Parameters } from '@/shared/parameter-schemas/evm.zod';\nimport HederaBuilder from '@/shared/hedera-utils/hedera-builder';\nimport { PromptGenerator } from '@/shared/utils/prompt-generator';\nimport HederaParameterNormaliser from '@/shared/hedera-utils/hedera-parameter-normaliser';\nimport { getERC20FactoryAddress, ERC20_FACTORY_ABI } from '@/shared/constants/contracts';\n\nconst createERC20Prompt = (context: Context = {}) => {\n  const contextSnippet = PromptGenerator.getContextSnippet(context);\n  const usageInstructions = PromptGenerator.getParameterUsageInstructions();\n\n  return `\n${contextSnippet}\n\nThis tool creates an ERC20 token on Hedera by calling the BaseERC20Factory contract.\n\nParameters:\n- tokenName (str, required): The name of the token\n- tokenSymbol (str, required): The symbol of the token\n- decimals (int, optional): The number of decimals the token supports. Defaults to 18\n- initialSupply (int, optional): The initial supply of the token. Defaults to 0\n${usageInstructions}\n`;\n};\n\nconst getERC20Address = async (client: Client, executeStrategyResult: ExecuteStrategyResult) => {\n  const record = await new TransactionRecordQuery()\n    .setTransactionId(executeStrategyResult.raw.transactionId)\n    .execute(client);\n  return '0x' + record.contractFunctionResult?.getAddress(0);\n};\n\nconst createERC20 = async (\n  client: Client,\n  context: Context,\n  params: z.infer<ReturnType<typeof createERC20Parameters>>,\n) => {\n  try {\n    const factoryContractAddress = getERC20FactoryAddress(client.ledgerId!);\n    const normalisedParams = HederaParameterNormaliser.normaliseCreateERC20Params(\n      params,\n      factoryContractAddress,\n      ERC20_FACTORY_ABI,\n      'deployToken',\n      context,\n    );\n    const tx = HederaBuilder.executeTransaction(normalisedParams);\n    const result = await handleTransaction(tx, client, context);\n    if (context.mode == AgentMode.AUTONOMOUS) {\n      const erc20Address = await getERC20Address(client, result as ExecuteStrategyResult);\n      return {\n        ...(result as ExecuteStrategyResult),\n        erc20Address: erc20Address?.toString(),\n        humanMessage: `ERC20 token created successfully at address ${erc20Address?.toString()}`,\n      };\n    }\n    return result;\n  } catch (error) {\n    const desc = 'Failed to create ERC20 token';\n    const message = desc + (error instanceof Error ? `: ${error.message}` : '');\n    console.error('[create_erc20_tool]', message);\n    return { raw: { status: Status.InvalidTransaction, error: message }, humanMessage: message };\n  }\n};\n\nexport const CREATE_ERC20_TOOL = 'create_erc20_tool';\n\nconst tool = (context: Context): Tool => ({\n  method: CREATE_ERC20_TOOL,\n  name: 'Create ERC20 Token',\n  description: createERC20Prompt(context),\n  parameters: createERC20Parameters(context),\n  execute: createERC20,\n});\n\nexport default tool;\n","import { LedgerId } from '@hashgraph/sdk';\n\nconst TESTNET_ERC20_FACTORY_ADDRESS = '0.0.6471814';\nconst TESTNET_ERC721_FACTORY_ADDRESS = '0.0.6510666'; // TODO: Update with actual deployed address\n\n// ERC20 Factory contract addresses for different networks\nexport const ERC20_FACTORY_ADDRESSES: Map<string, string> = new Map([\n  [LedgerId.TESTNET.toString(), TESTNET_ERC20_FACTORY_ADDRESS], // Current testnet address\n]);\n\n// ERC721 Factory contract addresses for different networks\nexport const ERC721_FACTORY_ADDRESSES: Map<string, string> = new Map([\n  [LedgerId.TESTNET.toString(), TESTNET_ERC721_FACTORY_ADDRESS], // Current testnet address\n]);\n\n// ERC20 Factory contract ABI\nexport const ERC20_FACTORY_ABI = [\n  'function deployToken(string memory name_, string memory symbol_, uint8 decimals_, uint256 initialSupply_) external returns (address)',\n];\n\n// ERC721 Factory contract ABI\nexport const ERC721_FACTORY_ABI = [\n  'function deployToken(string memory name_, string memory symbol_, string memory baseURI_) external returns (address)',\n];\n\nexport const ERC20_TRANSFER_FUNCTION_NAME = 'transfer';\nexport const ERC20_TRANSFER_FUNCTION_ABI = [\n  'function transfer(address to, uint256 amount) external returns (bool)',\n];\n\nexport const ERC721_TRANSFER_FUNCTION_NAME = 'transferFrom';\nexport const ERC721_TRANSFER_FUNCTION_ABI = [\n  'function transferFrom(address from, address to, uint256 tokenId) external returns (bool)',\n];\n\nexport const ERC721_MINT_FUNCTION_NAME = 'safeMint';\nexport const ERC721_MINT_FUNCTION_ABI = ['function safeMint(address to) external returns (bool)'];\n\n/**\n * Get the ERC20 factory contract address for the specified network\n * @param ledgerId - The Hedera network ledger ID\n * @returns The factory contract address for the network\n * @throws Error if the network is not supported\n */\nexport function getERC20FactoryAddress(ledgerId: LedgerId): string {\n  const address = ERC20_FACTORY_ADDRESSES.get(ledgerId.toString());\n  if (!address) {\n    throw new Error(`Network type ${ledgerId} not supported for ERC20 factory`);\n  }\n  return address;\n}\n\n/**\n * Get the ERC721 factory contract address for the specified network\n * @param ledgerId - The Hedera network ledger ID\n * @returns The factory contract address for the network\n * @throws Error if the network is not supported\n */\nexport function getERC721FactoryAddress(ledgerId: LedgerId): string {\n  const address = ERC721_FACTORY_ADDRESSES.get(ledgerId.toString());\n  if (!address) {\n    throw new Error(`Network type ${ledgerId} not supported for ERC721 factory`);\n  }\n  return address;\n}\n","import { z } from 'zod';\nimport type { Context } from '@/shared/configuration';\nimport type { Tool } from '@/shared/tools';\nimport HederaParameterNormaliser from '@/shared/hedera-utils/hedera-parameter-normaliser';\nimport { Client, Status } from '@hashgraph/sdk';\nimport { handleTransaction } from '@/shared/strategies/tx-mode-strategy';\nimport { transferERC20Parameters } from '@/shared/parameter-schemas/evm.zod';\nimport HederaBuilder from '@/shared/hedera-utils/hedera-builder';\nimport { PromptGenerator } from '@/shared/utils/prompt-generator';\nimport { getMirrornodeService } from '@/shared/hedera-utils/mirrornode/hedera-mirrornode-utils';\nimport {\n  ERC20_TRANSFER_FUNCTION_ABI,\n  ERC20_TRANSFER_FUNCTION_NAME,\n} from '@/shared/constants/contracts';\n\nconst transferERC20Prompt = (context: Context = {}) => {\n  const contextSnippet = PromptGenerator.getContextSnippet(context);\n  const usageInstructions = PromptGenerator.getParameterUsageInstructions();\n\n  return `\n${contextSnippet}\n\nThis tool will transfer a given amount of an existing ERC20 token on Hedera.\n\nParameters:\n- contractId (str, required): The id of the ERC20 contract. This can be the EVM address or the Hedera account id.\n- recipientAddress (str, required): The EVM or Hedera address to which the tokens will be transferred. This can be the EVM address or the Hedera account id.\n- amount (number, required): The amount to be transferred\n${usageInstructions}\n\nExample: \"Transfer 1 ERC20 token 0.0.6473135 to 0xd94dc7f82f103757f715514e4a37186be6e4580b\" means transferring the amount of 1 of the ERC20 token with contract id 0.0.6473135 to the 0xd94dc7f82f103757f715514e4a37186be6e4580b EVM address.\nExample: \"Transfer 1 ERC20 token 0xd94dc7f82f103757f715514e4a37186be6e4580b to 0.0.6473135\" means transferring the amount of 1 of the ERC20 token with contract id 0xd94dc7f82f103757f715514e4a37186be6e4580b to the 0.0.6473135 Hedera account id.\n`;\n};\n\nconst transferERC20 = async (\n  client: Client,\n  context: Context,\n  params: z.infer<ReturnType<typeof transferERC20Parameters>>,\n) => {\n  const mirrorNode = getMirrornodeService(context.mirrornodeService, client.ledgerId!);\n  try {\n    const normalisedParams = await HederaParameterNormaliser.normaliseTransferERC20Params(\n      params,\n      ERC20_TRANSFER_FUNCTION_ABI,\n      ERC20_TRANSFER_FUNCTION_NAME,\n      context,\n      mirrorNode,\n    );\n\n    const tx = HederaBuilder.executeTransaction(normalisedParams);\n    const result = await handleTransaction(tx, client, context);\n    return result;\n  } catch (error) {\n    const desc = 'Failed to transfer ERC20';\n    const message = desc + (error instanceof Error ? `: ${error.message}` : '');\n    console.error('[transfer_erc20_tool]', message);\n    return { raw: { status: Status.InvalidTransaction, error: message }, humanMessage: message };\n  }\n};\n\nexport const TRANSFER_ERC20_TOOL = 'transfer_erc20_tool';\n\nconst tool = (context: Context): Tool => ({\n  method: TRANSFER_ERC20_TOOL,\n  name: 'Transfer ERC20',\n  description: transferERC20Prompt(context),\n  parameters: transferERC20Parameters(context),\n  execute: transferERC20,\n});\n\nexport default tool;\n","import { z } from 'zod';\nimport type { Context } from '@/shared/configuration';\nimport type { Tool } from '@/shared/tools';\nimport HederaParameterNormaliser from '@/shared/hedera-utils/hedera-parameter-normaliser';\nimport { Client, Status } from '@hashgraph/sdk';\nimport { handleTransaction } from '@/shared/strategies/tx-mode-strategy';\nimport HederaBuilder from '@/shared/hedera-utils/hedera-builder';\nimport { PromptGenerator } from '@/shared/utils/prompt-generator';\nimport { getMirrornodeService } from '@/shared/hedera-utils/mirrornode/hedera-mirrornode-utils';\nimport {\n  ERC721_TRANSFER_FUNCTION_ABI,\n  ERC721_TRANSFER_FUNCTION_NAME,\n} from '@/shared/constants/contracts';\nimport { transferERC721Parameters } from '@/shared/parameter-schemas/evm.zod';\n\nconst transferERC721Prompt = (context: Context = {}) => {\n  const contextSnippet = PromptGenerator.getContextSnippet(context);\n  const fromAddressDesc = PromptGenerator.getAnyAddressParameterDescription('fromAddress', context);\n  const usageInstructions = PromptGenerator.getParameterUsageInstructions();\n\n  return `\n${contextSnippet}\n\nThis tool will transfer an existing ERC721 token on Hedera.\n\nParameters:\n- contractId (str, required): The id of the ERC721 contract\n- ${fromAddressDesc}\n- toAddress (str, required): The address to which the token will be transferred. This can be the EVM address or the Hedera account id.\n- tokenId (number, required): The ID of the transfered token\n${usageInstructions}\n\nExample: \"Transfer ERC721 token 0.0.6486793 with id 0 from 0xd94dc7f82f103757f715514e4a37186be6e4580b to 0xd94dc7f82f103757f715514e4a37186be6e4580b\" means transfering the ERC721 token (identified by 0) with contract id 0.0.6486793 from the 0xd94dc7f82f103757f715514e4a37186be6e4580b EVM address to the 0xd94dc7f82f103757f715514e4a37186be6e4580b EVM address.\nExample: \"Transfer ERC721 token 0.0.6486793 with id 0 from 0.0.6486793 to 0xd94dc7f82f103757f715514e4a37186be6e4580b\" means transfering the ERC721 token (identified by 0) with contract id 0.0.6486793 from the 0.0.6486793 Hedera account id to the 0xd94dc7f82f103757f715514e4a37186be6e4580b EVM address.\n`;\n};\n\nconst transferERC721 = async (\n  client: Client,\n  context: Context,\n  params: z.infer<ReturnType<typeof transferERC721Parameters>>,\n) => {\n  try {\n    const mirrorNode = getMirrornodeService(context.mirrornodeService, client.ledgerId!);\n\n    const normalisedParams = await HederaParameterNormaliser.normaliseTransferERC721Params(\n      params,\n      ERC721_TRANSFER_FUNCTION_ABI,\n      ERC721_TRANSFER_FUNCTION_NAME,\n      context,\n      mirrorNode,\n      client,\n    );\n    const tx = HederaBuilder.executeTransaction(normalisedParams);\n    const result = await handleTransaction(tx, client, context);\n    return result;\n  } catch (error) {\n    const desc = 'Failed to transfer ERC721';\n    const message = desc + (error instanceof Error ? `: ${error.message}` : '');\n    console.error('[transfer_erc721_tool]', message);\n    return { raw: { status: Status.InvalidTransaction, error: message }, humanMessage: message };\n  }\n};\n\nexport const TRANSFER_ERC721_TOOL = 'transfer_erc721_tool';\n\nconst tool = (context: Context): Tool => ({\n  method: TRANSFER_ERC721_TOOL,\n  name: 'Transfer ERC721',\n  description: transferERC721Prompt(context),\n  parameters: transferERC721Parameters(context),\n  execute: transferERC721,\n});\n\nexport default tool;\n","import { z } from 'zod';\nimport type { Context } from '@/shared/configuration';\nimport type { Tool } from '@/shared/tools';\nimport HederaParameterNormaliser from '@/shared/hedera-utils/hedera-parameter-normaliser';\nimport { Client, Status } from '@hashgraph/sdk';\nimport { handleTransaction } from '@/shared/strategies/tx-mode-strategy';\nimport HederaBuilder from '@/shared/hedera-utils/hedera-builder';\nimport { PromptGenerator } from '@/shared/utils/prompt-generator';\nimport { getMirrornodeService } from '@/shared/hedera-utils/mirrornode/hedera-mirrornode-utils';\nimport { ERC721_MINT_FUNCTION_ABI, ERC721_MINT_FUNCTION_NAME } from '@/shared/constants/contracts';\nimport { mintERC721Parameters } from '@/shared/parameter-schemas/evm.zod';\n\nconst mintERC721Prompt = (context: Context = {}) => {\n  const contextSnippet = PromptGenerator.getContextSnippet(context);\n  const usageInstructions = PromptGenerator.getParameterUsageInstructions();\n  const toAddressDesc = PromptGenerator.getAnyAddressParameterDescription('toAddress', context);\n\n  return `\n${contextSnippet}\n\nThis tool will mint a new ERC721 token on Hedera.\n\nParameters:\n- contractId (str, required): The id of the ERC721 contract\n- ${toAddressDesc}\n${usageInstructions}\n\nExample: \"Mint ERC721 token 0.0.6486793 to 0xd94dc7f82f103757f715514e4a37186be6e4580b\" means minting the ERC721 token with contract id 0.0.6486793 to the 0xd94dc7f82f103757f715514e4a37186be6e4580b EVM address.\nExample: \"Mint ERC721 token 0.0.6486793 to 0.0.6486793\" means minting the ERC721 token with contract id 0.0.6486793 to the 0.0.6486793 Hedera account id.\n`;\n};\n\nconst mintERC721 = async (\n  client: Client,\n  context: Context,\n  params: z.infer<ReturnType<typeof mintERC721Parameters>>,\n) => {\n  try {\n    const mirrorNode = getMirrornodeService(context.mirrornodeService, client.ledgerId!);\n\n    const normalisedParams = await HederaParameterNormaliser.normaliseMintERC721Params(\n      params,\n      ERC721_MINT_FUNCTION_ABI,\n      ERC721_MINT_FUNCTION_NAME,\n      context,\n      mirrorNode,\n      client,\n    );\n    const tx = HederaBuilder.executeTransaction(normalisedParams);\n    const result = await handleTransaction(tx, client, context);\n    return result;\n  } catch (error) {\n    const desc = 'Failed to mint ERC721';\n    const message = desc + (error instanceof Error ? `: ${error.message}` : '');\n    console.error('[mint_erc721_tool]', message);\n    return { raw: { status: Status.InvalidTransaction, error: message }, humanMessage: message };\n  }\n};\n\nexport const MINT_ERC721_TOOL = 'mint_erc721_tool';\n\nconst tool = (context: Context): Tool => ({\n  method: MINT_ERC721_TOOL,\n  name: 'Mint ERC721',\n  description: mintERC721Prompt(context),\n  parameters: mintERC721Parameters(context),\n  execute: mintERC721,\n});\n\nexport default tool;\n","import { z } from 'zod';\nimport { AgentMode, type Context } from '@/shared/configuration';\nimport type { Tool } from '@/shared/tools';\nimport { Client, Status, TransactionRecordQuery } from '@hashgraph/sdk';\nimport { ExecuteStrategyResult, handleTransaction } from '@/shared/strategies/tx-mode-strategy';\nimport { createERC721Parameters } from '@/shared/parameter-schemas/evm.zod';\nimport HederaBuilder from '@/shared/hedera-utils/hedera-builder';\nimport { PromptGenerator } from '@/shared/utils/prompt-generator';\nimport HederaParameterNormaliser from '@/shared/hedera-utils/hedera-parameter-normaliser';\nimport { getERC721FactoryAddress, ERC721_FACTORY_ABI } from '@/shared/constants/contracts';\n\nconst createERC721Prompt = (context: Context = {}) => {\n  const contextSnippet = PromptGenerator.getContextSnippet(context);\n  const usageInstructions = PromptGenerator.getParameterUsageInstructions();\n\n  return `\n${contextSnippet}\n\nThis tool creates an ERC721 token on Hedera by calling the BaseERC721Factory contract.\n\nParameters:\n- tokenName (str, required): The name of the token\n- tokenSymbol (str, required): The symbol of the token\n- baseURI (str, required): The base URI for token metadata.\n${usageInstructions}\n\nThe contractId returned by the tool is the address of the ERC721 Factory contract, the address of the ERC721 token is the erc721Address returned by the tool.\n`;\n};\n\nconst getERC721Address = async (client: Client, executeStrategyResult: ExecuteStrategyResult) => {\n  const record = await new TransactionRecordQuery()\n    .setTransactionId(executeStrategyResult.raw.transactionId)\n    .execute(client);\n  return '0x' + record.contractFunctionResult?.getAddress(0);\n};\n\nconst createERC721 = async (\n  client: Client,\n  context: Context,\n  params: z.infer<ReturnType<typeof createERC721Parameters>>,\n) => {\n  try {\n    const factoryContractAddress = getERC721FactoryAddress(client.ledgerId!);\n    const normalisedParams = HederaParameterNormaliser.normaliseCreateERC721Params(\n      params,\n      factoryContractAddress,\n      ERC721_FACTORY_ABI,\n      'deployToken',\n      context,\n    );\n    const tx = HederaBuilder.executeTransaction(normalisedParams);\n    const result = await handleTransaction(tx, client, context);\n\n    if (context.mode == AgentMode.AUTONOMOUS) {\n      const erc721Address = await getERC721Address(client, result as ExecuteStrategyResult);\n      return {\n        ...result,\n        erc721Address: erc721Address?.toString(),\n        message: `ERC721 token created successfully at address ${erc721Address?.toString()}`,\n      };\n    }\n    return result;\n  } catch (error) {\n    const desc = 'Failed to create ERC721 token';\n    const message = desc + (error instanceof Error ? `: ${error.message}` : '');\n    console.error('[create_erc721_tool]', message);\n    return { raw: { status: Status.InvalidTransaction, error: message }, humanMessage: message };\n  }\n};\n\nexport const CREATE_ERC721_TOOL = 'create_erc721_tool';\n\nconst tool = (context: Context): Tool => ({\n  method: CREATE_ERC721_TOOL,\n  name: 'Create ERC721 Token',\n  description: createERC721Prompt(context),\n  parameters: createERC721Parameters(context),\n  execute: createERC721,\n});\n\nexport default tool;\n","import { Plugin } from '@/shared/plugin';\nimport { Context } from '@/shared/configuration';\nimport createERC20Tool, { CREATE_ERC20_TOOL } from './tools/erc20/create-erc20';\nimport transferERC20Tool, { TRANSFER_ERC20_TOOL } from './tools/erc20/transfer-erc20';\nimport transferERC721Tool, {\n  TRANSFER_ERC721_TOOL,\n} from '@/plugins/core-evm-plugin/tools/erc721/transfer-erc721';\nimport mintERC721Tool, {\n  MINT_ERC721_TOOL,\n} from '@/plugins/core-evm-plugin/tools/erc721/mint-erc721';\nimport createERC721Tool, {\n  CREATE_ERC721_TOOL,\n} from '@/plugins/core-evm-plugin/tools/erc721/create-erc721';\n\nexport const coreEVMPlugin: Plugin = {\n  name: 'core-evm-plugin',\n  version: '1.0.0',\n  description: 'A plugin for the Hedera EVM',\n  tools: (context: Context) => {\n    return [\n      createERC20Tool(context),\n      transferERC20Tool(context),\n      transferERC721Tool(context),\n      mintERC721Tool(context),\n      createERC721Tool(context),\n    ];\n  },\n};\n\n// Export tool names as an object for destructuring\nexport const coreEVMPluginToolNames = {\n  TRANSFER_ERC721_TOOL,\n  MINT_ERC721_TOOL,\n  CREATE_ERC20_TOOL,\n  TRANSFER_ERC20_TOOL,\n  CREATE_ERC721_TOOL,\n} as const;\n\nexport default { coreEVMPlugin, coreEVMPluginToolNames };\n","import { z } from 'zod';\nimport type { Context } from '@/shared/configuration';\nimport type { Tool } from '@/shared/tools';\nimport { Client } from '@hashgraph/sdk';\nimport { accountBalanceQueryParameters } from '@/shared/parameter-schemas/account.zod';\nimport BigNumber from 'bignumber.js';\nimport { getMirrornodeService } from '@/shared/hedera-utils/mirrornode/hedera-mirrornode-utils';\nimport HederaParameterNormaliser from '@/shared/hedera-utils/hedera-parameter-normaliser';\nimport { PromptGenerator } from '@/shared/utils/prompt-generator';\nimport { toHBar } from '@/shared/hedera-utils/hbar-conversion-utils';\n\nexport const getHbarBalanceQueryPrompt = (context: Context = {}) => {\n  const contextSnippet = PromptGenerator.getContextSnippet(context);\n  const accountDesc = PromptGenerator.getAccountParameterDescription('accountId', context);\n  const usageInstructions = PromptGenerator.getParameterUsageInstructions();\n\n  return `\n${contextSnippet}\n\nThis tool will return the HBAR balance for a given Hedera account.\n\nParameters:\n- ${accountDesc}\n${usageInstructions}\n`;\n};\n\nconst postProcess = (hbarBalance: string, accountId: string) => {\n  return `Account ${accountId} has a balance of ${hbarBalance} HBAR`;\n};\n\nexport const getHbarBalanceQuery = async (\n  client: Client,\n  context: Context,\n  params: z.infer<ReturnType<typeof accountBalanceQueryParameters>>,\n) => {\n  try {\n    const normalisedParams = HederaParameterNormaliser.normaliseHbarBalanceParams(\n      params,\n      context,\n      client,\n    );\n    const mirrornodeService = getMirrornodeService(context.mirrornodeService!, client.ledgerId!);\n    const balance: BigNumber = await mirrornodeService.getAccountHBarBalance(\n      normalisedParams.accountId,\n    );\n    return {\n      raw: { accountId: normalisedParams.accountId, hbarBalance: toHBar(balance).toString() },\n      humanMessage: postProcess(toHBar(balance).toString() as string, normalisedParams.accountId),\n    };\n  } catch (error) {\n    const desc = 'Failed to get HBAR balance';\n    const message = desc + (error instanceof Error ? `: ${error.message}` : '');\n    console.error('[get_hbar_balance_query_tool]', message);\n    return { raw: { error: message }, humanMessage: message };\n  }\n};\n\nexport const GET_HBAR_BALANCE_QUERY_TOOL = 'get_hbar_balance_query_tool';\n\nconst tool = (context: Context): Tool => ({\n  method: GET_HBAR_BALANCE_QUERY_TOOL,\n  name: 'Get HBAR Balance',\n  description: getHbarBalanceQueryPrompt(context),\n  parameters: accountBalanceQueryParameters(context),\n  execute: getHbarBalanceQuery,\n});\n\nexport default tool;\n","import { z } from 'zod';\nimport { Client, Status } from '@hashgraph/sdk';\nimport { Context } from '@/shared/configuration';\nimport { getMirrornodeService } from '@/shared/hedera-utils/mirrornode/hedera-mirrornode-utils';\nimport { Tool } from '@/shared/tools';\nimport { PromptGenerator } from '@/shared/utils/prompt-generator';\nimport { AccountResponse } from '@/shared/hedera-utils/mirrornode/types';\nimport { accountQueryParameters } from '@/shared/parameter-schemas/account.zod';\n\nexport const getAccountQueryPrompt = (context: Context = {}) => {\n  const contextSnippet = PromptGenerator.getContextSnippet(context);\n  const usageInstructions = PromptGenerator.getParameterUsageInstructions();\n\n  return `\n${contextSnippet}\n\nThis tool will return the account information for a given Hedera account.\n\nParameters:\n- accountId (str, required): The account ID to query\n${usageInstructions}\n`;\n};\n\nconst postProcess = (account: AccountResponse) => {\n  return `Details for ${account.accountId}\nBalance: ${account.balance.balance.toString()}\nPublic Key: ${account.accountPublicKey},\nEVM address: ${account.evmAddress},\n`;\n};\n\nexport const getAccountQuery = async (\n  client: Client,\n  context: Context,\n  params: z.infer<ReturnType<typeof accountQueryParameters>>,\n) => {\n  try {\n    const mirrornodeService = getMirrornodeService(context.mirrornodeService!, client.ledgerId!);\n    const account = await mirrornodeService.getAccount(params.accountId);\n    return {\n      raw: { accountId: params.accountId, account: account },\n      humanMessage: postProcess(account),\n    };\n  } catch (error) {\n    const desc = 'Failed to get account query';\n    const message = desc + (error instanceof Error ? `: ${error.message}` : '');\n    console.error('[get_account_query_tool]', message);\n    return { raw: { status: Status.InvalidTransaction, error: message }, humanMessage: message };\n  }\n};\n\nexport const GET_ACCOUNT_QUERY_TOOL = 'get_account_query_tool';\n\nconst tool = (context: Context): Tool => ({\n  method: GET_ACCOUNT_QUERY_TOOL,\n  name: 'Get Account Query',\n  description: getAccountQueryPrompt(context),\n  parameters: accountQueryParameters(context),\n  execute: getAccountQuery,\n});\n\nexport default tool;\n","import { z } from 'zod';\nimport { Context } from '@/shared/configuration';\nimport { getMirrornodeService } from '@/shared/hedera-utils/mirrornode/hedera-mirrornode-utils';\nimport { accountTokenBalancesQueryParameters } from '@/shared/parameter-schemas/account.zod';\nimport { Client } from '@hashgraph/sdk';\nimport { Tool } from '@/shared/tools';\nimport HederaParameterNormaliser from '@/shared/hedera-utils/hedera-parameter-normaliser';\nimport { PromptGenerator } from '@/shared/utils/prompt-generator';\nimport { TokenBalancesResponse } from '@/shared/hedera-utils/mirrornode/types';\n\nexport const getAccountTokenBalancesQueryPrompt = (context: Context = {}) => {\n  const contextSnippet = PromptGenerator.getContextSnippet(context);\n  const accountDesc = PromptGenerator.getAccountParameterDescription('accountId', context);\n  const usageInstructions = PromptGenerator.getParameterUsageInstructions();\n\n  return `\n${contextSnippet}\n\nThis tool will return the token balances for a given Hedera account.\n\nParameters:\n- ${accountDesc}\n- tokenId (str, optional): The token ID to query for. If not provided, all token balances will be returned\n${usageInstructions}\n`;\n};\n\nconst postProcess = (tokenBalances: TokenBalancesResponse, accountId: string) => {\n  if (tokenBalances.tokens.length === 0) {\n    return `No token balances found for account ${accountId}`;\n  }\n  const balancesText = tokenBalances.tokens\n    .map(\n      token => `  Token: ${token.token_id}, Balance: ${token.balance}, Decimals: ${token.decimals}`,\n    )\n    .join('\\n');\n\n  return `Details for ${accountId}\n--- Token Balances ---\n${balancesText}`;\n};\n\nexport const getAccountTokenBalancesQuery = async (\n  client: Client,\n  context: Context,\n  params: z.infer<ReturnType<typeof accountTokenBalancesQueryParameters>>,\n) => {\n  try {\n    const normalisedParams = HederaParameterNormaliser.normaliseAccountTokenBalancesParams(\n      params,\n      context,\n      client,\n    );\n    const mirrornodeService = getMirrornodeService(context.mirrornodeService!, client.ledgerId!);\n    const tokenBalances = await mirrornodeService.getAccountTokenBalances(\n      normalisedParams.accountId,\n      normalisedParams.tokenId,\n    );\n    return {\n      raw: { accountId: normalisedParams.accountId, tokenBalances: tokenBalances },\n      humanMessage: postProcess(tokenBalances, normalisedParams.accountId),\n    };\n  } catch (error) {\n    const desc = 'Failed to get account token balances';\n    const message = desc + (error instanceof Error ? `: ${error.message}` : '');\n    console.error('[get_account_token_balances_query_tool]', message);\n    return { raw: { error: message }, humanMessage: message };\n  }\n};\n\nexport const GET_ACCOUNT_TOKEN_BALANCES_QUERY_TOOL = 'get_account_token_balances_query_tool';\n\nconst tool = (context: Context): Tool => ({\n  method: GET_ACCOUNT_TOKEN_BALANCES_QUERY_TOOL,\n  name: 'Get Account Token Balances',\n  description: getAccountTokenBalancesQueryPrompt(context),\n  parameters: accountTokenBalancesQueryParameters(context),\n  execute: getAccountTokenBalancesQuery,\n});\n\nexport default tool;\n","import { Plugin } from '@/shared/plugin';\nimport { Context } from '@/shared/configuration';\nimport getHbarBalanceQuery, {\n  GET_HBAR_BALANCE_QUERY_TOOL,\n} from '@/plugins/core-account-query-plugin/tools/queries/get-hbar-balance-query';\nimport getAccountQuery, {\n  GET_ACCOUNT_QUERY_TOOL,\n} from '@/plugins/core-account-query-plugin/tools/queries/get-account-query';\nimport getAccountTokenBalancesQuery, {\n  GET_ACCOUNT_TOKEN_BALANCES_QUERY_TOOL,\n} from '@/plugins/core-account-query-plugin/tools/queries/get-account-token-balances-query';\n\nexport const coreAccountQueryPlugin: Plugin = {\n  name: 'core-account-query-plugin',\n  version: '1.0.0',\n  description: 'A plugin for Hedera Account Service queries',\n  tools: (context: Context) => {\n    return [\n      getHbarBalanceQuery(context),\n      getAccountQuery(context),\n      getAccountTokenBalancesQuery(context),\n    ];\n  },\n};\n\nexport const coreAccountQueryPluginToolNames = {\n  GET_HBAR_BALANCE_QUERY_TOOL,\n  GET_ACCOUNT_QUERY_TOOL,\n  GET_ACCOUNT_TOKEN_BALANCES_QUERY_TOOL,\n} as const;\n\nexport default { coreAccountQueryPlugin, coreAccountQueryPluginToolNames };\n","import { z } from 'zod';\nimport { Context } from '@/shared/configuration';\nimport { getMirrornodeService } from '@/shared/hedera-utils/mirrornode/hedera-mirrornode-utils';\nimport { tokenInfoQueryParameters } from '@/shared/parameter-schemas/token.zod';\nimport { Client } from '@hashgraph/sdk';\nimport { Tool } from '@/shared/tools';\nimport { PromptGenerator } from '@/shared/utils/prompt-generator';\nimport { TokenInfo } from '@/shared/hedera-utils/mirrornode/types';\n\nexport const getTokenInfoQueryPrompt = (context: Context = {}) => {\n  const contextSnippet = PromptGenerator.getContextSnippet(context);\n  const usageInstructions = PromptGenerator.getParameterUsageInstructions();\n\n  return `\n${contextSnippet}\n\nThis tool will return the information for a given Hedera token.\n\nParameters:\n- tokenId (str): The token ID to query for.\n${usageInstructions}\n`;\n};\n\nconst postProcess = (tokenInfo: TokenInfo) => {\n  const formatSupply = (supply?: string) => {\n    if (!supply) return 'N/A';\n\n    const decimals = Number(tokenInfo.decimals || '0');\n    const amount = Number(supply);\n    if (isNaN(amount)) return supply;\n\n    return (amount / 10 ** decimals).toLocaleString();\n  };\n\n  const formatKey = (key?: { _type: string; key: string } | null) => {\n    if (!key) return 'Not Set';\n    return key._type ? `${key.key}` : 'Present';\n  };\n\n  const supplyType = tokenInfo.supply_type === 'INFINITE' ? 'Infinite' : 'Finite';\n  const freezeStatus = tokenInfo.freeze_default ? 'Frozen' : 'Active';\n\n  return `Here are the details for token **${tokenInfo.token_id}**:\n\n- **Token Name**: ${tokenInfo.name}\n- **Token Symbol**: ${tokenInfo.symbol}\n- **Token Type**: ${tokenInfo.type || 'N/A'}\n- **Decimals**: ${tokenInfo.decimals}\n- **Max Supply**: ${formatSupply(tokenInfo.max_supply)}\n- **Current Supply**: ${formatSupply(tokenInfo.total_supply)}\n- **Supply Type**: ${supplyType}\n- **Treasury Account ID**: ${tokenInfo.treasury_account_id || 'N/A'}\n- **Status (Deleted/Active)**: ${tokenInfo.deleted ? 'Deleted' : 'Active'}\n- **Status (Frozen/Active)**: ${freezeStatus}\n\n**Keys**:\n- Admin Key: ${formatKey(tokenInfo.admin_key)}\n- Supply Key: ${formatKey(tokenInfo.supply_key)}\n- Wipe Key: ${formatKey(tokenInfo.wipe_key)}\n- KYC Key: ${formatKey(tokenInfo.kyc_key)}\n- Freeze Key: ${formatKey(tokenInfo.freeze_key)}\n- Fee Schedule Key: ${formatKey(tokenInfo.fee_schedule_key)}\n- Pause Key: ${formatKey(tokenInfo.pause_key)}\n- Metadata Key: ${formatKey(tokenInfo.metadata_key)}\n\n${tokenInfo.memo ? `**Memo**: ${tokenInfo.memo}` : ''}\n`;\n};\n\nexport const getTokenInfoQuery = async (\n  client: Client,\n  context: Context,\n  params: z.infer<ReturnType<typeof tokenInfoQueryParameters>>,\n) => {\n  try {\n    const mirrornodeService = getMirrornodeService(context.mirrornodeService!, client.ledgerId!);\n    const tokenInfo: TokenInfo = {\n      ...(await mirrornodeService.getTokenInfo(params.tokenId!)),\n      token_id: params.tokenId!,\n    };\n\n    return {\n      raw: { tokenId: params.tokenId, tokenInfo },\n      humanMessage: postProcess(tokenInfo),\n    };\n  } catch (error) {\n    const desc = 'Failed to get token info';\n    const message = desc + (error instanceof Error ? `: ${error.message}` : '');\n    console.error('[get_token_info_query_tool]', message);\n    return { raw: { error: message }, humanMessage: message };\n  }\n};\n\nexport const GET_TOKEN_INFO_QUERY_TOOL = 'get_token_info_query_tool';\n\nconst tool = (context: Context): Tool => ({\n  method: GET_TOKEN_INFO_QUERY_TOOL,\n  name: 'Get Token Info',\n  description: getTokenInfoQueryPrompt(context),\n  parameters: tokenInfoQueryParameters(context),\n  execute: getTokenInfoQuery,\n});\n\nexport default tool;\n","import { z } from 'zod';\nimport { Context } from '@/shared/configuration';\nimport { getMirrornodeService } from '@/shared/hedera-utils/mirrornode/hedera-mirrornode-utils';\nimport { accountBalanceQueryParameters } from '@/shared/parameter-schemas/account.zod';\nimport { Client } from '@hashgraph/sdk';\nimport { Tool } from '@/shared/tools';\nimport { PromptGenerator } from '@/shared/utils/prompt-generator';\nimport { TokenAirdropsResponse, TokenAirdrop } from '@/shared/hedera-utils/mirrornode/types';\nimport { pendingAirdropQueryParameters } from '@/shared/parameter-schemas/token.zod';\nimport { AccountResolver } from '@/shared/utils/account-resolver';\n\nexport const getPendingAirdropQueryPrompt = (context: Context = {}) => {\n  const contextSnippet = PromptGenerator.getContextSnippet(context);\n  const accountDesc = PromptGenerator.getAccountParameterDescription('accountId', context);\n  const usageInstructions = PromptGenerator.getParameterUsageInstructions();\n\n  return `\n${contextSnippet}\n\nThis tool will return pending airdrops for a given Hedera account.\n\nParameters:\n- ${accountDesc}\n${usageInstructions}\n`;\n};\n\nconst formatAirdrop = (airdrop: TokenAirdrop, index: number) => {\n  const token = airdrop.token_id ?? 'N/A';\n  const amount = airdrop.amount ?? 0;\n  const serial = airdrop.serial_number ?? 'N/A';\n  const sender = airdrop.sender_id ?? 'N/A';\n  const receiver = airdrop.receiver_id ?? 'N/A';\n  const fromTs = airdrop.timestamp?.from ?? 'N/A';\n  const toTs = airdrop.timestamp?.to ?? 'N/A';\n  return `#${index + 1} Token: ${token}, Amount: ${amount}, Serial: ${serial}, Sender: ${sender}, Receiver: ${receiver}, Timestamp: ${fromTs}${toTs ? ` → ${toTs}` : ''}`;\n};\n\nconst postProcess = (accountId: string, response: TokenAirdropsResponse) => {\n  const count = response.airdrops?.length ?? 0;\n  if (count === 0) {\n    return `No pending airdrops found for account ${accountId}`;\n  }\n\n  const details = response.airdrops.map(formatAirdrop).join('\\n');\n  return `Here are the pending airdrops for account **${accountId}** (total: ${count}):\\n\\n${details}`;\n};\n\nexport const getPendingAirdropQuery = async (\n  client: Client,\n  context: Context,\n  params: z.infer<ReturnType<typeof pendingAirdropQueryParameters>>,\n) => {\n  try {\n    const accountId = params.accountId ?? AccountResolver.getDefaultAccount(context, client);\n    if (!accountId) throw new Error('Account ID is required and was not provided');\n\n    const mirrornodeService = getMirrornodeService(context.mirrornodeService!, client.ledgerId!);\n    const response = await mirrornodeService.getPendingAirdrops(accountId);\n\n    return {\n      raw: { accountId, pendingAirdrops: response },\n      humanMessage: postProcess(accountId, response),\n    };\n  } catch (error) {\n    const desc = 'Failed to get pending airdrops';\n    const message = desc + (error instanceof Error ? `: ${error.message}` : '');\n    console.error('[get_pending_airdrop_query_tool]', message);\n    return { raw: { error: message }, humanMessage: message };\n  }\n};\n\nexport const GET_PENDING_AIRDROP_TOOL = 'get_pending_airdrop_tool';\n\nconst tool = (context: Context): Tool => ({\n  method: GET_PENDING_AIRDROP_TOOL,\n  name: 'Get Pending Airdrops',\n  description: getPendingAirdropQueryPrompt(context),\n  parameters: pendingAirdropQueryParameters(context),\n  execute: getPendingAirdropQuery,\n});\n\nexport default tool;\n\n\n","import { Plugin } from '@/shared/plugin';\nimport { Context } from '@/shared/configuration';\nimport getTokenInfoQuery, {\n  GET_TOKEN_INFO_QUERY_TOOL,\n} from '@/plugins/core-token-query-plugin/tools/queries/get-token-info-query';\nimport getPendingAirdropQuery, {\n  GET_PENDING_AIRDROP_TOOL,\n} from '@/plugins/core-token-query-plugin/tools/queries/get-pending-airdrop-query';\n\nexport const coreTokenQueryPlugin: Plugin = {\n  name: 'core-token-query-plugin',\n  version: '1.0.0',\n  description: 'A plugin for Hedera Token Service queries',\n  tools: (context: Context) => {\n    return [getTokenInfoQuery(context), getPendingAirdropQuery(context)];\n  },\n};\n\nexport const coreTokenQueryPluginToolNames = {\n  GET_TOKEN_INFO_QUERY_TOOL,\n  GET_PENDING_AIRDROP_TOOL,\n} as const;\n\nexport default { coreTokenQueryPlugin, coreTokenQueryPluginToolNames };\n","import { Context } from '@/shared/configuration';\nimport { getMirrornodeService } from '@/shared/hedera-utils/mirrornode/hedera-mirrornode-utils';\nimport { topicMessagesQueryParameters } from '@/shared/parameter-schemas/consensus.zod';\nimport { Client } from '@hashgraph/sdk';\nimport { z } from 'zod';\nimport { Tool } from '@/shared/tools';\nimport { TopicMessage, TopicMessagesQueryParams } from '@/shared/hedera-utils/mirrornode/types';\nimport { PromptGenerator } from '@/shared/utils/prompt-generator';\n\nexport const getTopicMessagesQueryPrompt = (context: Context = {}) => {\n  const contextSnippet = PromptGenerator.getContextSnippet(context);\n  const usageInstructions = PromptGenerator.getParameterUsageInstructions();\n\n  return `\n${contextSnippet}\n\nThis tool will return the messages for a given Hedera topic.\n\nParameters:\n- topicId (str, required): The topic ID to query\n- startTime (datetime, optional): The start datetime to query. If set, the messages will be returned after this datetime\n- endTime (datetime, optional): The end datetime to query. If set, the messages will be returned before this datetime\n- limit (int, optional): The limit of messages to query. If set, the number of messages to return\n${usageInstructions}\n`;\n};\n\nconst postProcess = (messages: TopicMessage[], topicId: string) => {\n  if (messages.length === 0) {\n    return `No messages found for topic ${topicId}.`;\n  }\n\n  const messagesText = messages.map(\n    message =>\n      `${Buffer.from(message.message, 'base64').toString('utf-8')} - posted at: ${message.consensus_timestamp}\\n`,\n  );\n\n  return `Messages for topic ${topicId}:\n  --- Messages ---\n  ${messagesText}\n  `;\n};\n\nconst getTopicMessagesQueryParams = (\n  params: z.infer<ReturnType<typeof topicMessagesQueryParameters>>,\n): TopicMessagesQueryParams => {\n  return {\n    topicId: params.topicId,\n    lowerTimestamp: params.startTime\n      ? `${Math.floor(new Date(params.startTime).getTime() / 1000)}.000000000`\n      : '',\n    upperTimestamp: params.endTime\n      ? `${Math.floor(new Date(params.endTime).getTime() / 1000)}.000000000`\n      : '',\n    limit: params.limit || 100,\n  };\n};\n\nconst convertMessagesFromBase64ToString = (messages: TopicMessage[]) => {\n  return messages.map(message => {\n    return {\n      ...message,\n      message: Buffer.from(message.message, 'base64').toString('utf-8'),\n    };\n  });\n};\n\nexport const getTopicMessagesQuery = async (\n  client: Client,\n  context: Context,\n  params: z.infer<ReturnType<typeof topicMessagesQueryParameters>>,\n) => {\n  try {\n    const mirrornodeService = getMirrornodeService(context.mirrornodeService!, client.ledgerId!);\n    const messages = await mirrornodeService.getTopicMessages(getTopicMessagesQueryParams(params));\n\n    return {\n      raw: {\n        topicId: messages.topicId,\n        messages: convertMessagesFromBase64ToString(messages.messages),\n      },\n      humanMessage: postProcess(messages.messages, params.topicId),\n    };\n  } catch (error) {\n    const desc = 'Failed to get topic messages';\n    const message = desc + (error instanceof Error ? `: ${error.message}` : '');\n    console.error('[get_topic_messages_query_tool]', message);\n    return { raw: { error: message }, humanMessage: message };\n  }\n};\n\nexport const GET_TOPIC_MESSAGES_QUERY_TOOL = 'get_topic_messages_query_tool';\n\nconst tool = (context: Context): Tool => ({\n  method: GET_TOPIC_MESSAGES_QUERY_TOOL,\n  name: 'Get Topic Messages',\n  description: getTopicMessagesQueryPrompt(context),\n  parameters: topicMessagesQueryParameters(context),\n  execute: getTopicMessagesQuery,\n});\n\nexport default tool;\n","import { z } from 'zod';\nimport { Context } from '@/shared/configuration';\nimport { getMirrornodeService } from '@/shared/hedera-utils/mirrornode/hedera-mirrornode-utils';\nimport { Client } from '@hashgraph/sdk';\nimport { Tool } from '@/shared/tools';\nimport { PromptGenerator } from '@/shared/utils/prompt-generator';\nimport { TopicInfo } from '@/shared/hedera-utils/mirrornode/types';\nimport { getTopicInfoParameters } from '@/shared/parameter-schemas/consensus.zod';\n\nexport const getTopicInfoQueryPrompt = (context: Context = {}) => {\n  const contextSnippet = PromptGenerator.getContextSnippet(context);\n  const usageInstructions = PromptGenerator.getParameterUsageInstructions();\n\n  return `\n${contextSnippet}\n\nThis tool will return the information for a given Hedera topic (HCS).\n\nParameters:\n- topicId (str): The topic ID to query for.\n${usageInstructions}\n`;\n};\n\nconst postProcess = (topic: TopicInfo) => {\n  const formatKey = (key?: { _type?: string; key?: string } | null) => {\n    if (!key) return 'Not Set';\n    return key._type ? key.key || 'Present' : 'Present';\n  };\n\n  const formatTimestamp = (ts?: string | null) => {\n    if (!ts) return 'N/A';\n    const [seconds] = ts.split('.');\n    const date = new Date(Number(seconds) * 1000);\n    return date.toISOString();\n  };\n\n  return `Here are the details for topic **${topic.topic_id || 'N/A'}**:\n\n- **Memo**: ${topic.memo || 'N/A'}\n- **Deleted**: ${topic.deleted ? 'Yes' : 'No'}\n- **Sequence Number**: ${topic.sequence_number ?? 'N/A'}\n\n**Timestamps**:\n- Created: ${formatTimestamp(topic.created_timestamp)}\n\n**Entity IDs**:\n- Auto Renew Account: ${topic.auto_renew_account || 'N/A'}\n- Auto Renew Period: ${topic.auto_renew_period ?? 'N/A'}\n\n**Keys**:\n- Admin Key: ${formatKey(topic.admin_key)}\n- Submit Key: ${formatKey(topic.submit_key)}\n`;\n};\n\nexport const getTopicInfoQuery = async (\n  client: Client,\n  context: Context,\n  params: z.infer<ReturnType<typeof getTopicInfoParameters>>,\n) => {\n  try {\n    const mirrornodeService = getMirrornodeService(context.mirrornodeService!, client.ledgerId!);\n    const topicInfo: TopicInfo = {\n      ...(await mirrornodeService.getTopicInfo(params.topicId)),\n      topic_id: params.topicId,\n    };\n\n    return {\n      raw: { topicId: params.topicId, topicInfo },\n      humanMessage: postProcess(topicInfo),\n    };\n  } catch (error) {\n    const desc = 'Failed to get topic info';\n    const message = desc + (error instanceof Error ? `: ${error.message}` : '');\n    console.error('[get_topic_info_query_tool]', message);\n    return { raw: { error: message }, humanMessage: message };\n  }\n};\n\nexport const GET_TOPIC_INFO_QUERY_TOOL = 'get_topic_info_query_tool';\n\nconst tool = (context: Context): Tool => ({\n  method: GET_TOPIC_INFO_QUERY_TOOL,\n  name: 'Get Topic Info',\n  description: getTopicInfoQueryPrompt(context),\n  parameters: getTopicInfoParameters(context),\n  execute: getTopicInfoQuery,\n});\n\nexport default tool;\n","import { Plugin } from '@/shared/plugin';\nimport { Context } from '@/shared/configuration';\nimport getTopicMessagesQuery, {\n  GET_TOPIC_MESSAGES_QUERY_TOOL,\n} from '@/plugins/core-consensus-query-plugin/tools/queries/get-topic-messages-query';\nimport getTopicInfoQuery, {\n  GET_TOPIC_INFO_QUERY_TOOL,\n} from '@/plugins/core-consensus-query-plugin/tools/queries/get-topic-info-query';\n\nexport const coreConsensusQueryPlugin: Plugin = {\n  name: 'core-consensus-query-plugin',\n  version: '1.0.0',\n  description: 'A plugin for Hedera Consensus Service queries',\n  tools: (context: Context) => {\n    return [getTopicMessagesQuery(context), getTopicInfoQuery(context)];\n  },\n};\n\nexport const coreConsensusQueryPluginToolNames = {\n  GET_TOPIC_MESSAGES_QUERY_TOOL,\n  GET_TOPIC_INFO_QUERY_TOOL,\n} as const;\n\nexport default { coreConsensusQueryPlugin, coreConsensusQueryPluginToolNames };\n","import { z } from 'zod';\nimport { Context } from '@/shared/configuration';\nimport { getMirrornodeService } from '@/shared/hedera-utils/mirrornode/hedera-mirrornode-utils';\nimport { contractInfoQueryParameters } from '@/shared/parameter-schemas/evm.zod';\nimport { Client } from '@hashgraph/sdk';\nimport { Tool } from '@/shared/tools';\nimport { PromptGenerator } from '@/shared/utils/prompt-generator';\nimport { ContractInfo } from '@/shared/hedera-utils/mirrornode/types';\n\nexport const getContractInfoQueryPrompt = (context: Context = {}) => {\n  const contextSnippet = PromptGenerator.getContextSnippet(context);\n  const usageInstructions = PromptGenerator.getParameterUsageInstructions();\n\n  return `\n${contextSnippet}\n\nThis tool will return the information for a given Hedera contract.\n\nParameters:\n- contractId (str): The contract ID to query for.\n${usageInstructions}\n`;\n};\n\nconst postProcess = (contract: ContractInfo) => {\n  const formatKey = (key?: { _type?: string; key?: string } | null) => {\n    if (!key) return 'Not Set';\n    return key._type ? key.key || 'Present' : 'Present';\n  };\n\n  const formatTimestamp = (ts?: string | null) => {\n    if (!ts) return 'N/A';\n    const [seconds, nanos] = ts.split('.');\n    const date = new Date(Number(seconds) * 1000);\n    return date.toISOString() + (nanos ? `.${nanos}` : '');\n  };\n\n  return `Here are the details for contract **${contract.contract_id || 'N/A'}**:\n\n- **Memo**: ${contract.memo || 'N/A'}\n- **Deleted**: ${contract.deleted ? 'Yes' : 'No'}\n- **Permanent Removal**: ${contract.permanent_removal ? 'Yes' : 'No'}\n- **Nonce**: ${contract.nonce ?? 'N/A'}\n\n**Timestamps**:\n- Created: ${formatTimestamp(contract.created_timestamp)}\n- Expiration: ${formatTimestamp(contract.expiration_timestamp)}\n- Valid From: ${contract.timestamp?.from || 'N/A'}\n- Valid To: ${contract.timestamp?.to || 'N/A'}\n\n**Entity IDs**:\n- Auto Renew Account: ${contract.auto_renew_account || 'N/A'}\n- File ID: ${contract.file_id || 'N/A'}\n- Obtainer ID: ${contract.obtainer_id || 'N/A'}\n- Proxy Account ID: ${contract.proxy_account_id || 'N/A'}\n\n**Keys**:\n- Admin Key: ${formatKey(contract.admin_key)}\n\n**EVM**:\n- Address: ${contract.evm_address || 'N/A'}\n`;\n};\n\nexport const getContractInfoQuery = async (\n  client: Client,\n  context: Context,\n  params: z.infer<ReturnType<typeof contractInfoQueryParameters>>,\n) => {\n  try {\n    const mirrornodeService = getMirrornodeService(context.mirrornodeService!, client.ledgerId!);\n    const contractInfo: ContractInfo = await mirrornodeService.getContractInfo(params.contractId);\n\n    return {\n      raw: { contractId: params.contractId, contractInfo },\n      humanMessage: postProcess(contractInfo),\n    };\n  } catch (error) {\n    const desc = 'Failed to get contract info';\n    const message = desc + (error instanceof Error ? `: ${error.message}` : '');\n    console.error('[get_contract_info_query_tool]', message);\n    return { raw: { error: message }, humanMessage: message };\n  }\n};\n\nexport const GET_CONTRACT_INFO_QUERY_TOOL = 'get_contract_info_query_tool';\n\nconst tool = (context: Context): Tool => ({\n  method: GET_CONTRACT_INFO_QUERY_TOOL,\n  name: 'Get Contract Info',\n  description: getContractInfoQueryPrompt(context),\n  parameters: contractInfoQueryParameters(context),\n  execute: getContractInfoQuery,\n});\n\nexport default tool;\n","import { Plugin } from '@/shared/plugin';\nimport { Context } from '@/shared/configuration';\nimport getContractInfoQuery, {\n  GET_CONTRACT_INFO_QUERY_TOOL,\n} from '@/plugins/core-evm-query-plugin/tools/queries/get-contract-info-query';\n\nexport const coreEVMQueryPlugin: Plugin = {\n  name: 'core-evm-query-plugin',\n  version: '1.0.0',\n  description: 'A plugin for Hedera EVM Service queries',\n  tools: (context: Context) => {\n    return [getContractInfoQuery(context)];\n  },\n};\n\nexport const coreEVMQueryPluginToolNames = {\n  GET_CONTRACT_INFO_QUERY_TOOL,\n} as const;\n\nexport default { coreEVMQueryPlugin, coreEVMQueryPluginToolNames };\n","import { z } from 'zod';\nimport { Client } from '@hashgraph/sdk';\nimport { Context } from '@/shared/configuration';\nimport { getMirrornodeService } from '@/shared/hedera-utils/mirrornode/hedera-mirrornode-utils';\nimport { Tool } from '@/shared/tools';\nimport { PromptGenerator } from '@/shared/utils/prompt-generator';\nimport { TransactionDetailsResponse } from '@/shared/hedera-utils/mirrornode/types';\nimport { toDisplayUnit } from '@/shared/hedera-utils/decimals-utils';\nimport HederaParameterNormaliser from '@/shared/hedera-utils/hedera-parameter-normaliser';\nimport { transactionRecordQueryParameters } from '@/shared/parameter-schemas/transaction.zod';\n\nexport const getTransactionRecordQueryPrompt = (context: Context = {}) => {\n  const contextSnippet = PromptGenerator.getContextSnippet(context);\n  const usageInstructions = PromptGenerator.getParameterUsageInstructions();\n\n  return `\n${contextSnippet}\n\nThis tool will return the transaction record for a given Hedera transaction ID.\n\nParameters:\n- transactionId (str, required): The transaction ID to fetch record for. Should be in format \\\\\"shard.realm.num-sss-nnn\\\\\" format where sss are seconds and nnn are nanoseconds\n- nonce (number, optional): Optional nonce value for the transaction\n${usageInstructions}\n\nAdditional information:\nIf user provides transaction ID in format 0.0.4177806@1755169980.051721264, parse it to 0.0.4177806-1755169980-051721264 and use it as transaction ID. Do not remove the staring zeros.\n`;\n};\n\nconst postProcess = (transactionRecord: TransactionDetailsResponse, transactionId: string) => {\n  if (!transactionRecord.transactions || transactionRecord.transactions.length === 0) {\n    return `No transaction details found for transaction ID: ${transactionId}`;\n  }\n\n  const results = transactionRecord.transactions.map((tx, index) => {\n    let transfersInfo = '';\n    if (tx.transfers && tx.transfers.length > 0) {\n      transfersInfo =\n        '\\nTransfers:\\n' +\n        tx.transfers\n          .map(\n            transfer =>\n              `  Account: ${transfer.account}, Amount: ${toDisplayUnit(transfer.amount, 8)}ℏ`,\n          )\n          .join('\\n');\n    }\n\n    const transactionHeader =\n      transactionRecord.transactions.length > 1\n        ? `Transaction ${index + 1} Details for ${transactionId}`\n        : `Transaction Details for ${transactionId}`;\n\n    return `${transactionHeader}\nStatus: ${tx.result}\nConsensus Timestamp: ${tx.consensus_timestamp}\nTransaction Hash: ${tx.transaction_hash}\nTransaction Fee: ${tx.charged_tx_fee}\nType: ${tx.name}\nEntity ID: ${tx.entity_id}${transfersInfo}`;\n  });\n\n  return results.join('\\n\\n' + '='.repeat(50) + '\\n\\n');\n};\n\nexport const getTransactionRecordQuery = async (\n  client: Client,\n  context: Context,\n  params: z.infer<ReturnType<typeof transactionRecordQueryParameters>>,\n) => {\n  try {\n    const mirrornodeService = getMirrornodeService(context.mirrornodeService!, client.ledgerId!);\n    const normalisedParams = HederaParameterNormaliser.normaliseGetTransactionRecordParams(\n      params,\n      context,\n    );\n\n    const transactionRecord = await mirrornodeService.getTransactionRecord(\n      normalisedParams.transactionId,\n      normalisedParams.nonce,\n    );\n\n    return {\n      raw: { transactionId: params.transactionId, transactionRecord: transactionRecord },\n      humanMessage: postProcess(transactionRecord, params.transactionId),\n    };\n  } catch (error) {\n    const desc = 'Failed to get transaction record';\n    const message = desc + (error instanceof Error ? `: ${error.message}` : '');\n    console.error('[get_transaction_record_query_tool]', message);\n    return { raw: { error: message }, humanMessage: message };\n  }\n};\n\nexport const GET_TRANSACTION_RECORD_QUERY_TOOL = 'get_transaction_record_query_tool';\n\nconst tool = (context: Context): Tool => ({\n  method: GET_TRANSACTION_RECORD_QUERY_TOOL,\n  name: 'Get Transaction Record Query',\n  description: getTransactionRecordQueryPrompt(context),\n  parameters: transactionRecordQueryParameters(context),\n  execute: getTransactionRecordQuery,\n});\n\nexport default tool;\n","import { Plugin } from '@/shared/plugin';\nimport { Context } from '@/shared/configuration';\nimport getTransactionRecordQuery, {\n  GET_TRANSACTION_RECORD_QUERY_TOOL,\n} from '@/plugins/core-transactions-query-plugin/tools/queries/get-transaction-record-query';\n\nexport const coreTransactionQueryPlugin: Plugin = {\n  name: 'core-transaction-query-plugin',\n  version: '1.0.0',\n  description: 'A plugin for Hedera Transactions queries',\n  tools: (context: Context) => {\n    return [getTransactionRecordQuery(context)];\n  },\n};\n\nexport const coreTransactionQueryPluginToolNames = {\n  GET_TRANSACTION_RECORD_QUERY_TOOL,\n} as const;\n\nexport default { coreTransactionQueryPlugin, coreTransactionQueryPluginToolNames };\n","import { coreTokenPlugin, coreTokenPluginToolNames } from './core-token-plugin';\nimport { coreAccountPlugin, coreAccountPluginToolNames } from './core-account-plugin';\nimport { coreConsensusPlugin, coreConsensusPluginToolNames } from './core-consensus-plugin';\nimport { coreQueriesPlugin, coreQueriesPluginToolNames } from './core-queries-plugin';\nimport { coreMiscQueriesPluginsToolNames, coreMiscQueriesPlugin } from './core-misc-query-plugin';\nimport { coreEVMPlugin, coreEVMPluginToolNames } from './core-evm-plugin';\nimport {\n  coreAccountQueryPlugin,\n  coreAccountQueryPluginToolNames,\n} from './core-account-query-plugin';\nimport { coreTokenQueryPlugin, coreTokenQueryPluginToolNames } from './core-token-query-plugin';\nimport {\n  coreConsensusQueryPlugin,\n  coreConsensusQueryPluginToolNames,\n} from './core-consensus-query-plugin';\nimport { coreEVMQueryPlugin, coreEVMQueryPluginToolNames } from './core-evm-query-plugin';\nimport {\n  coreTransactionQueryPlugin,\n  coreTransactionQueryPluginToolNames,\n} from './core-transactions-query-plugin';\n\nexport {\n  coreTokenPlugin,\n  coreAccountPlugin,\n  coreConsensusPlugin,\n  coreMiscQueriesPlugin,\n  coreQueriesPlugin,\n  coreTokenPluginToolNames,\n  coreAccountPluginToolNames,\n  coreConsensusPluginToolNames,\n  coreQueriesPluginToolNames,\n  coreEVMPlugin,\n  coreEVMPluginToolNames,\n  coreAccountQueryPlugin,\n  coreTokenQueryPlugin,\n  coreConsensusQueryPlugin,\n  coreAccountQueryPluginToolNames,\n  coreTokenQueryPluginToolNames,\n  coreConsensusQueryPluginToolNames,\n  coreEVMQueryPlugin,\n  coreEVMQueryPluginToolNames,\n  coreTransactionQueryPlugin,\n  coreTransactionQueryPluginToolNames,\n  coreMiscQueriesPluginsToolNames,\n};\n\n// Deprecated exports for backward compatibility\n/**\n * @deprecated Use coreTokenPlugin instead. This export will be removed in a future version.\n */\nexport const coreHTSPlugin = coreTokenPlugin;\n\n/**\n * @deprecated Use coreTokenPluginToolNames instead. This export will be removed in a future version.\n */\nexport const coreHTSPluginToolNames = coreTokenPluginToolNames;\n\n/**\n * @deprecated Use coreEVMPlugin instead. This export will be removed in a future version.\n */\nexport const coreSCSPlugin = coreEVMPlugin;\n\n/**\n * @deprecated Use coreEVMPluginToolNames instead. This export will be removed in a future version.\n */\nexport const coreSCSPluginToolNames = coreEVMPluginToolNames;\n","import { Context } from './configuration';\nimport { Tool } from './tools';\nimport {\n  coreAccountPlugin,\n  coreTokenPlugin,\n  coreConsensusPlugin,\n  coreEVMPlugin,\n  coreAccountQueryPlugin,\n  coreTokenQueryPlugin,\n  coreConsensusQueryPlugin,\n} from '@/plugins';\n\nconst CORE_PLUGINS = [\n  coreAccountPlugin,\n  coreTokenPlugin,\n  coreConsensusPlugin,\n  coreEVMPlugin,\n  coreAccountQueryPlugin,\n  coreTokenQueryPlugin,\n  coreConsensusQueryPlugin,\n];\n\nexport interface Plugin {\n  name: string;\n  version?: string;\n  description?: string;\n  tools: (context: Context) => Tool[];\n}\n\nexport class PluginRegistry {\n  private plugins = new Map<string, Plugin>();\n\n  register(plugin: Plugin): void {\n    if (this.plugins.has(plugin.name)) {\n      console.warn(`Plugin \"${plugin.name}\" is already registered. Overwriting.`);\n    }\n    this.plugins.set(plugin.name, plugin);\n  }\n\n  getPlugins(): Plugin[] {\n    return Array.from(this.plugins.values());\n  }\n\n  private loadCorePlugins(context: Context): Tool[] {\n    const pluginTools: Tool[] = [];\n    for (const plugin of CORE_PLUGINS) {\n      try {\n        const tools = plugin.tools(context);\n        pluginTools.push(...tools);\n      } catch (error) {\n        console.error(`Error loading tools from plugin \"${plugin.name}\":`, error);\n      }\n    }\n    return pluginTools;\n  }\n\n  private loadPlugins(context: Context): Tool[] {\n    const pluginTools: Tool[] = [];\n    for (const plugin of this.plugins.values()) {\n      try {\n        const tools = plugin.tools(context);\n        pluginTools.push(...tools);\n      } catch (error) {\n        console.error(`Error loading tools from plugin \"${plugin.name}\":`, error);\n      }\n    }\n    return pluginTools;\n  }\n\n  getTools(context: Context): Tool[] {\n    if (this.plugins.size === 0) {\n      return this.loadCorePlugins(context);\n    } else {\n      return this.loadPlugins(context);\n    }\n  }\n\n  clear(): void {\n    this.plugins.clear();\n  }\n}\n","import { z } from 'zod';\nimport { StructuredTool } from '@langchain/core/tools';\nimport { CallbackManagerForToolRun } from '@langchain/core/callbacks/manager';\nimport { RunnableConfig } from '@langchain/core/runnables';\nimport HederaAgentKitAPI from '@/shared/api';\n\nclass HederaAgentKitTool extends StructuredTool {\n  hederaAPI: HederaAgentKitAPI;\n\n  method: string;\n\n  name: string;\n\n  description: string;\n\n  schema: z.ZodObject<any, any>;\n\n  constructor(\n    HederaAgentKitAPI: HederaAgentKitAPI,\n    method: string,\n    description: string,\n    schema: z.ZodObject<any, any>,\n  ) {\n    super();\n\n    this.hederaAPI = HederaAgentKitAPI;\n    this.method = method;\n    this.name = method;\n    this.description = description;\n    this.schema = schema;\n  }\n\n  _call(\n    arg: z.output<typeof this.schema>,\n    _runManager?: CallbackManagerForToolRun,\n    _parentConfig?: RunnableConfig,\n  ): Promise<any> {\n    return this.hederaAPI.run(this.method, arg);\n  }\n}\n\nexport default HederaAgentKitTool;\n","import { Context, Configuration } from './configuration';\nimport { Tool } from './tools';\nimport { Plugin, PluginRegistry } from './plugin';\n\nexport class ToolDiscovery {\n  private pluginRegistry = new PluginRegistry();\n\n  constructor(plugins: Plugin[] = []) {\n    plugins.forEach(plugin => this.pluginRegistry.register(plugin));\n  }\n\n  getAllTools(context: Context, configuration?: Configuration): Tool[] {\n    // Get plugin tools\n    const pluginTools = this.pluginRegistry.getTools(context);\n\n    // Merge all tools (core tools take precedence in case of name conflicts)\n    const allTools: any = [];\n    const allToolNames = new Set<string>();\n\n    // Add plugin tools that don't conflict with core tools\n    pluginTools.forEach(pluginTool => {\n      if (!allToolNames.has(pluginTool.method)) {\n        allTools.push(pluginTool);\n        allToolNames.add(pluginTool.method);\n      } else {\n        console.warn(\n          `Plugin tool \"${pluginTool.method}\" conflicts with core tool. Using core tool.`,\n        );\n      }\n    });\n\n    // Apply tool filtering if specified in configuration\n    if (configuration?.tools && configuration.tools.length > 0) {\n      return allTools.filter((tool: any) => configuration.tools!.includes(tool.method));\n    }\n\n    return allTools;\n  }\n\n  static createFromConfiguration(configuration: Configuration): ToolDiscovery {\n    return new ToolDiscovery(configuration.plugins || []);\n  }\n}\n","import { BaseToolkit } from '@langchain/core/tools';\nimport HederaAgentKitTool from '@/langchain/tool';\nimport HederaAgentKitAPI from '@/shared/api';\nimport { type Configuration } from '@/shared/configuration';\nimport { ToolDiscovery } from '@/shared/tool-discovery';\nimport { Client } from '@hashgraph/sdk';\n\nclass HederaLangchainToolkit implements BaseToolkit {\n  private _hederaAgentKit: HederaAgentKitAPI;\n\n  tools: HederaAgentKitTool[];\n\n  constructor({ client, configuration }: { client: Client; configuration: Configuration }) {\n    const context = configuration.context || {};\n    const toolDiscovery = ToolDiscovery.createFromConfiguration(configuration);\n    const allTools = toolDiscovery.getAllTools(context, configuration);\n\n    this._hederaAgentKit = new HederaAgentKitAPI(client, configuration.context, allTools);\n    this.tools = allTools.map(\n      tool =>\n        new HederaAgentKitTool(\n          this._hederaAgentKit,\n          tool.method,\n          tool.description,\n          tool.parameters,\n        ),\n    );\n  }\n\n  getTools(): HederaAgentKitTool[] {\n    return this.tools;\n  }\n\n  getHederaAgentKitAPI(): HederaAgentKitAPI {\n    return this._hederaAgentKit;\n  }\n}\n\nexport default HederaLangchainToolkit;\n","import { McpServer } from '@modelcontextprotocol/sdk/server/mcp.js';\nimport { Client } from '@hashgraph/sdk';\nimport { Configuration } from '@/shared/configuration';\nimport HederaAgentKitAPI from '@/shared/api';\nimport { ToolDiscovery } from '@/shared/tool-discovery';\nimport { RequestHandlerExtra } from '@modelcontextprotocol/sdk/shared/protocol.js';\n\nclass HederaMCPToolkit extends McpServer {\n  private _hederaAgentKit: HederaAgentKitAPI;\n\n  constructor({ client, configuration }: { client: Client; configuration: Configuration }) {\n    super({\n      name: 'Hedera Agent Kit',\n      version: '0.1.0',\n      configuration: {\n        ...configuration,\n        context: {\n          ...configuration.context,\n          mode: 'modelcontextprotocol',\n        },\n      },\n    });\n\n    const context = configuration.context || {};\n    const toolDiscovery = ToolDiscovery.createFromConfiguration(configuration);\n    const allTools = toolDiscovery.getAllTools(context, configuration);\n    this._hederaAgentKit = new HederaAgentKitAPI(client, configuration.context, allTools);\n\n    allTools.map(tool => {\n      this.tool(\n        tool.method,\n        tool.description,\n        tool.parameters.shape,\n        async (arg: any, _extra: RequestHandlerExtra<any, any>) => {\n          const result = await this._hederaAgentKit.run(tool.method, arg);\n          return {\n            content: [\n              {\n                type: 'text' as const,\n                text: String(result),\n              },\n            ],\n          };\n        },\n      );\n    });\n  }\n}\n\nexport default HederaMCPToolkit;\n","import HederaAgentAPI from '@/shared/api';\nimport { tool } from 'ai';\nimport z from 'zod';\n\nexport default function HederaAgentKitTool(\n  hederaAPI: HederaAgentAPI,\n  method: string,\n  description: string,\n  schema: z.ZodObject<any, any>,\n) {\n  return tool({\n    description: description,\n    parameters: schema,\n    execute: (arg: z.output<typeof schema>) => {\n      return hederaAPI.run(method, arg);\n    },\n  });\n}\n","import HederaAgentAPI from '../shared/api';\nimport { type Configuration } from '@/shared';\nimport { ToolDiscovery } from '@/shared/tool-discovery';\nimport type { Tool, LanguageModelV1Middleware } from 'ai';\nimport { Client } from '@hashgraph/sdk';\nimport HederaAgentKitTool from './tool';\n\nclass HederaAIToolkit {\n  private _hedera: HederaAgentAPI;\n\n  tools: { [key: string]: Tool };\n\n  constructor({ client, configuration }: { client: Client; configuration: Configuration }) {\n    const context = configuration.context || {};\n    const toolDiscovery = ToolDiscovery.createFromConfiguration(configuration);\n    const allTools = toolDiscovery.getAllTools(context, configuration);\n    this._hedera = new HederaAgentAPI(client, configuration.context, allTools);\n    this.tools = {};\n\n    allTools.forEach(tool => {\n      this.tools[tool.method] = HederaAgentKitTool(\n        this._hedera,\n        tool.method,\n        tool.description,\n        tool.parameters,\n      );\n    });\n  }\n\n  middleware(): LanguageModelV1Middleware {\n    return {\n      wrapGenerate: async ({ doGenerate }) => {\n        return doGenerate();\n      },\n      wrapStream: async ({ doStream }) => {\n        // Pre-processing can be added here if needed\n        return doStream();\n      },\n    };\n  }\n  getTools(): { [key: string]: Tool } {\n    return this.tools;\n  }\n}\n\nexport default HederaAIToolkit;\n","import {\n  Action,\n  ActionExample,\n  ActionResult,\n  composePromptFromState,\n  Handler,\n  type HandlerCallback,\n  type IAgentRuntime,\n  logger,\n  type Memory,\n  ModelType,\n  type State,\n  Validator,\n} from '@elizaos/core';\nimport { Client } from '@hashgraph/sdk';\nimport type { Tool } from '@/shared/tools';\nimport { Context } from '@/shared/configuration';\nimport { generateExtractionTemplate } from '@/elizaos/utils/extraction';\nimport { customParseJSONObjectFromText } from '@/elizaos/utils/parser';\n\nclass HederaAgentKitTool implements Action {\n  description: string;\n  handler: Handler;\n  similes?: string[] | undefined;\n  examples?: ActionExample[][] | undefined;\n  name: string;\n  validate: Validator;\n\n  constructor(client: Client, context: Context, tool: Tool) {\n    const parameterSchema = tool.parameters;\n    this.description = tool.description;\n\n    // Set Action properties\n    this.name = tool.method.toUpperCase();\n    this.similes = [tool.method.toUpperCase()];\n    this.validate = async (_runtime: IAgentRuntime, _message: Memory) => true;\n\n    this.handler = async (\n      runtime: IAgentRuntime,\n      _message: Memory,\n      state: State | undefined,\n      _options: any,\n      callback?: HandlerCallback,\n    ): Promise<ActionResult> => {\n      logger.log(`Running ${tool.method} handler...`);\n      if (!state) {\n        throw new Error('State is undefined');\n      }\n\n      // create an extraction prompt for extracting tool parameters from recent user messages\n      const prompt = composePromptFromState({\n        state,\n        template: generateExtractionTemplate(tool),\n      });\n      logger.debug(`prompt: ${prompt}`);\n\n      // execute extraction prompt\n      const modelOutput = await runtime.useModel(ModelType.TEXT_LARGE, { prompt });\n      logger.debug(`Model extraction output: ${modelOutput}`);\n\n      // custom parsing params from Markdown JSON notation to JS object\n      const parsedParams = customParseJSONObjectFromText(modelOutput) as Record<string, any>;\n      logger.debug('Parsed params object', parsedParams);\n\n      // validating parameters with tools input zod schema\n      const validation = parameterSchema.safeParse(parsedParams); // parsing extracted params before calling a tool\n      logger.debug('Validated params:' + JSON.stringify(validation, null, 2));\n\n      // print error if validation failed\n      if (!validation.success) {\n        // call llm to generate a comprehensive message to the user about missing params\n        const promptText = `given the recent messages {{recent_messages}}, \n        tool description: ${tool.description}\n        and the error message: ${validation.error.format()}\n        generate a comprehensive message to the user about missing params\n        `;\n\n        const modelOutput = await runtime.useModel(ModelType.TEXT_LARGE, { promptText });\n        if (callback) {\n          await callback({\n            text: modelOutput,\n            content: { error: validation.error.format() },\n          });\n        }\n        return {\n          success: false,\n          text: modelOutput,\n          error: validation.error.toString(),\n        };\n      }\n\n      // call the action\n      try {\n        const result = await tool.execute(client, context, validation.data);\n        const responseText = result.humanMessage; // extract the human-readable response provided by the tool\n\n        if (callback) {\n          await callback({\n            text: responseText,\n            content: result,\n          });\n        }\n\n        return { success: true, text: responseText };\n      } catch (err) {\n        // handle other errors\n        const message = err instanceof Error ? err.message : 'Unknown error';\n        logger.error(`Error running tool ${tool.method}:`, err);\n\n        if (callback) {\n          await callback({\n            text: `Execution failed: ${message}`,\n            content: { error: message },\n          });\n        }\n\n        return { success: false, text: `Execution failed: ${message}`, error: message };\n      }\n    };\n  }\n}\n\nexport default HederaAgentKitTool;\n","import { Tool } from '@/shared';\nimport { zodToJsonSchema } from 'zod-to-json-schema';\n\n/**\n * Generates an extraction template based on the tool description, params and zod schema.\n * @param tool\n */\nexport function generateExtractionTemplate(tool: Tool): string {\n  const zodSchema = tool.parameters; // Zod Schema of the tool parameters, used for generating JSON schema for extraction response\n  const description = tool.description; // description of the tool, used for generating a list of required/optional params\n  const actionName = tool.name;\n  const toolParamsJSONSchema = zodToJsonSchema(zodSchema, actionName); // JSON schema created based on the tool's params\n\n  return `Given the recent messages and Hedera wallet information below:\n{{recentMessages}}\n{{hederaAccountDetails}}\n\nExtract the following parameters based on the tool/action description and json schema below:\n\n### Tool/action description:\n${description}\n\n⚠️ Do **not** assume values or apply defaults. Do **not** set a field unless it is clearly specified in the latest user input.\n⚠️ **IMPORTANT**: Always ensure numeric values are provided as NUMBERS WITHOUT QUOTES in the JSON response.\n⚠️ **IMPORTANT**: Always ensure string values are provided as QUOTED STRINGS in the JSON response.\n⚠️ **CRITICAL**: Enum values must be provided as QUOTED STRINGS (e.g., \"finite\", not finite).\n⚠️ **CRITICAL**: The returned JSON must be a valid JSON object in markdown format. Don not include comments inside it. If no params is passed return an empty JSON object.\n\n---\n\n### Response format:\nRespond with a JSON markdown block including the fields that were explicitly mentioned in the most recent user message.\n\nResponse JSON schema:\n${JSON.stringify(toolParamsJSONSchema, null, 2)}\n\n---\n\nNumeric values should be numbers without quotes. Enum values must be quoted strings.`;\n}\n","const jsonBlockPattern = /```(?:json)?\\s*([\\s\\S]*?)```/;\n\n/**\n * Custom implementation of JSON Parser form ElizaOS\n * Parses a JSON object or array from a given text.\n * Extracts JSON from code blocks and handles normalization of improperly formatted JSON.\n * Preserves data types (numbers, booleans, arrays) in the parsed result.\n *\n * @param text - The input text from which to extract and parse the JSON.\n * @returns The parsed JSON object or array if successful; otherwise, null.\n */\nexport function customParseJSONObjectFromText(text: string): Record<string, any> | any[] | null {\n  if (!text) return null;\n\n  let jsonData = null;\n  const jsonBlockMatch = text.match(jsonBlockPattern);\n\n  try {\n    if (jsonBlockMatch) {\n      // Clean the extracted JSON content\n      const jsonContent = jsonBlockMatch[1].trim().replace(/[\\u0000-\\u001F\\u007F-\\u009F]/g, ''); // Remove control characters\n      jsonData = JSON.parse(jsonContent);\n    } else {\n      // Try direct parsing first for well-formatted JSON\n      try {\n        jsonData = JSON.parse(text.trim());\n      } catch {\n        // Fall back to normalization for poorly formatted JSON\n        jsonData = JSON.parse(customNormalizeJsonString(text.trim()));\n      }\n    }\n  } catch (error) {\n    console.warn('Could not parse text as JSON:', error);\n    return null;\n  }\n\n  // Accept both objects and arrays, but ensure we have something valid\n  if (jsonData && typeof jsonData === 'object') {\n    return jsonData;\n  }\n\n  console.warn('Parsed result is not a valid object or array');\n  return null;\n}\n\n/**\n * Custom Implementation of JSON string normalization from ElizaOS\n * Normalizes a JSON-like string by correcting formatting issues without converting numbers or booleans to strings.\n *\n * @param str - The JSON-like string to normalize.\n * @returns A properly formatted JSON string.\n */\nfunction customNormalizeJsonString(str: string): string {\n  if (!str) return str;\n\n  // Remove extra spaces after '{' and before '}'\n  str = str.replace(/\\{\\s+/, '{').replace(/\\s+\\}/, '}').trim();\n\n  // Fix missing quotes around property names\n  str = str.replace(/(\\s*)(\\w+)(\\s*):(\\s*)/g, '$1\"$2\"$3:$4');\n\n  // Fix single quotes around property values but ONLY when they're strings\n  // Don't convert numbers or booleans that are properly formatted\n  str = str.replace(/\"([^\"]+)\"\\s*:\\s*'([^']*)'/g, (_, key, value) => `\"${key}\": \"${value}\"`);\n\n  // Handle unquoted property values that should be strings\n  // But skip numbers, true, false, and null which should remain unquoted\n  str = str.replace(/\"([^\"]+)\"\\s*:\\s*([^\",\\{\\[\\]\\}0-9][^\",\\{\\[\\]\\}\\s]*)/g, (match, key, value) => {\n    // Skip if value is true, false, or null\n    if (value === 'true' || value === 'false' || value === 'null') {\n      return `\"${key}\": ${value}`;\n    }\n    // Skip if value is a number\n    if (!isNaN(Number(value))) {\n      return `\"${key}\": ${value}`;\n    }\n    return `\"${key}\": \"${value}\"`;\n  });\n\n  return str;\n}\n","import { Client } from '@hashgraph/sdk';\nimport { Configuration, Context } from '@/shared/configuration';\nimport { ToolDiscovery } from '@/shared/tool-discovery';\nimport HederaAgentKitTool from '@/elizaos/tool';\n\nexport class HederaElizaOSToolkit {\n  private readonly tools: HederaAgentKitTool[];\n  private readonly client: Client;\n  private readonly context: Context;\n\n  constructor({ client, configuration }: { client: Client; configuration: Configuration }) {\n    this.client = client;\n    this.context = configuration.context || {};\n    const toolDiscovery = ToolDiscovery.createFromConfiguration(configuration);\n    const allTools = toolDiscovery.getAllTools(this.context, configuration);\n\n    this.tools = allTools.map(tool => new HederaAgentKitTool(this.client, this.context, tool));\n  }\n\n  /**\n   * Maps hedera-agent-kit tools and returns ElizaOS compatible actions\n   */\n  getTools(): HederaAgentKitTool[] {\n    return this.tools;\n  }\n}\n"],"mappings":"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","names":["tool","AgentMode","z","AccountId","z","z","z","z","z","z","AccountId","PublicKey","z","z","AccountId","Hbar","PublicKey","TokenId","TokenSupplyType","TokenType","TopicId","HbarAllowance","z","BigNumber","Long","PublicKey","PublicKey","z","z","z","z","TokenSupplyType","PublicKey","TokenType","Long","Hbar","HbarAllowance","AccountId","TokenId","TopicId","AccountId","postProcess","AccountId","AccountId","TokenId","BigNumber","Status","postProcess","Status","tool","Status","postProcess","Status","tool","Status","postProcess","Status","tool","Status","postProcess","Status","tool","PublicKey","Status","PublicKey","postProcess","Status","tool","Status","postProcess","Status","tool","Status","postProcess","Status","tool","Status","postProcess","Status","tool","postProcess","tool","Status","postProcess","Status","tool","Status","postProcess","Status","tool","Status","postProcess","Status","tool","Status","postProcess","Status","tool","Status","postProcess","Status","tool","Status","postProcess","Status","tool","Status","postProcess","Status","tool","Status","postProcess","Status","tool","PublicKey","Status","checkValidityOfUpdates","PublicKey","postProcess","Status","tool","postProcess","tool","Status","postProcess","Status","tool","postProcess","tool","postProcess","tool","postProcess","tool","z","postProcess","tool","Status","LedgerId","Status","tool","Status","Status","tool","Status","Status","tool","Status","Status","tool","Status","TransactionRecordQuery","TransactionRecordQuery","Status","tool","getHbarBalanceQueryPrompt","postProcess","getHbarBalanceQuery","GET_HBAR_BALANCE_QUERY_TOOL","tool","get_hbar_balance_query_default","Status","getAccountQueryPrompt","postProcess","getAccountQuery","Status","GET_ACCOUNT_QUERY_TOOL","tool","get_account_query_default","getAccountTokenBalancesQueryPrompt","postProcess","getAccountTokenBalancesQuery","GET_ACCOUNT_TOKEN_BALANCES_QUERY_TOOL","tool","get_account_token_balances_query_default","get_hbar_balance_query_default","get_account_query_default","get_account_token_balances_query_default","GET_HBAR_BALANCE_QUERY_TOOL","GET_ACCOUNT_QUERY_TOOL","GET_ACCOUNT_TOKEN_BALANCES_QUERY_TOOL","getTokenInfoQueryPrompt","postProcess","getTokenInfoQuery","GET_TOKEN_INFO_QUERY_TOOL","tool","get_token_info_query_default","postProcess","tool","get_token_info_query_default","GET_TOKEN_INFO_QUERY_TOOL","getTopicMessagesQueryPrompt","postProcess","getTopicMessagesQueryParams","convertMessagesFromBase64ToString","getTopicMessagesQuery","GET_TOPIC_MESSAGES_QUERY_TOOL","tool","get_topic_messages_query_default","postProcess","tool","get_topic_messages_query_default","GET_TOPIC_MESSAGES_QUERY_TOOL","postProcess","tool","postProcess","tool","tool","tool","tool","toolkit_default","tool","HederaAgentKitTool","tool","HederaAgentKitTool","toolkit_default","tool","HederaAgentKitTool","tool","modelOutput","tool_default","tool","tool_default"]}