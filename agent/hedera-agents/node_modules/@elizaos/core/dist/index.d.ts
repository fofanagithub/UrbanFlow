import { z } from 'zod';
import pino from 'pino';
import * as browser from '@sentry/browser';
export { browser as Sentry };

/**
 * Defines a custom type UUID representing a universally unique identifier
 */
type UUID = `${string}-${string}-${string}-${string}-${string}`;
/**
 * Helper function to safely cast a string to strongly typed UUID
 * @param id The string UUID to validate and cast
 * @returns The same UUID with branded type information
 */
declare function asUUID(id: string): UUID;
/**
 * Represents the content of a memory, message, or other information
 */
interface Content {
    /** The agent's internal thought process */
    thought?: string;
    /** The main text content visible to users */
    text?: string;
    /** Optional actions to be performed */
    actions?: string[];
    /** Optional providers to use for context generation */
    providers?: string[];
    /** Optional source/origin of the content */
    source?: string;
    /** Optional target/destination for responses */
    target?: string;
    /** URL of the original message/post (e.g. tweet URL, Discord message link) */
    url?: string;
    /** UUID of parent message if this is a reply/thread */
    inReplyTo?: UUID;
    /** Array of media attachments */
    attachments?: Media[];
    /** room type */
    channelType?: string;
    /**
     * Additional dynamic properties
     * Use specific properties above instead of this when possible
     */
    [key: string]: unknown;
}
/**
 * Represents a media attachment
 */
type Media = {
    /** Unique identifier */
    id: string;
    /** Media URL */
    url: string;
    /** Media title */
    title?: string;
    /** Media source */
    source?: string;
    /** Media description */
    description?: string;
    /** Text content */
    text?: string;
    /** Content type */
    contentType?: ContentType;
};
declare enum ContentType {
    IMAGE = "image",
    VIDEO = "video",
    AUDIO = "audio",
    DOCUMENT = "document",
    LINK = "link"
}
/**
 * A generic type for metadata objects, allowing for arbitrary key-value pairs.
 * This encourages consumers to perform type checking or casting.
 */
type Metadata = Record<string, unknown>;

/**
 * Represents the current state or context of a conversation or agent interaction.
 * This interface is a flexible container for various pieces of information that define the agent's
 * understanding at a point in time. It includes:
 * - `values`: A key-value store for general state variables, often populated by providers.
 * - `data`: Another key-value store, potentially for more structured or internal data.
 * - `text`: A string representation of the current context, often a summary or concatenated history.
 * The `[key: string]: any;` allows for dynamic properties, though `EnhancedState` offers better typing.
 * This state object is passed to handlers for actions, evaluators, and providers.
 */
interface State {
    /** Additional dynamic properties */
    [key: string]: any;
    values: {
        [key: string]: any;
    };
    data: {
        [key: string]: any;
    };
    text: string;
}
/**
 * Defines the possible primitive types or structured types for a value within the agent's state.
 * This type is used to provide more specific typing for properties within `StateObject` and `StateArray`,
 * moving away from a generic 'any' type for better type safety and clarity in state management.
 */
type StateValue = string | number | boolean | null | StateObject | StateArray;
/**
 * Represents a generic object structure within the agent's state, where keys are strings
 * and values can be any `StateValue`. This allows for nested objects within the state.
 * It's a fundamental part of the `EnhancedState` interface.
 */
interface StateObject {
    [key: string]: StateValue;
}
/**
 * Represents an array of `StateValue` types within the agent's state.
 * This allows for lists of mixed or uniform types to be stored in the state,
 * contributing to the structured definition of `EnhancedState`.
 */
type StateArray = StateValue[];
/**
 * Enhanced State interface with more specific types for its core properties.
 * This interface provides a more structured representation of an agent's conversational state,
 * building upon the base `State` by typing `values` and `data` as `StateObject`.
 * The `text` property typically holds a textual summary or context derived from the state.
 * Additional dynamic properties are still allowed via the index signature `[key: string]: StateValue;`.
 */
interface EnhancedState {
    /** Holds directly accessible state values, often used for template rendering or quick lookups. */
    values: StateObject;
    /** Stores more complex or structured data, potentially namespaced by providers or internal systems. */
    data: StateObject;
    /** A textual representation or summary of the current state, often used as context for models. */
    text: string;
    /** Allows for additional dynamic properties to be added to the state object. */
    [key: string]: StateValue;
}

/**
 * Memory type enumeration for built-in memory types
 */
type MemoryTypeAlias = string;
/**
 * Enumerates the built-in types of memories that can be stored and retrieved.
 * - `DOCUMENT`: Represents a whole document or a large piece of text.
 * - `FRAGMENT`: A chunk or segment of a `DOCUMENT`, often created for embedding and search.
 * - `MESSAGE`: A conversational message, typically from a user or the agent.
 * - `DESCRIPTION`: A descriptive piece of information, perhaps about an entity or concept.
 * - `CUSTOM`: For any other type of memory not covered by the built-in types.
 * This enum is used in `MemoryMetadata` to categorize memories and influences how they are processed or queried.
 */
declare enum MemoryType {
    DOCUMENT = "document",
    FRAGMENT = "fragment",
    MESSAGE = "message",
    DESCRIPTION = "description",
    CUSTOM = "custom"
}
/**
 * Defines the scope of a memory, indicating its visibility and accessibility.
 * - `shared`: The memory is accessible to multiple entities or across different contexts (e.g., a public fact).
 * - `private`: The memory is specific to a single entity or a private context (e.g., a user's personal preference).
 * - `room`: The memory is scoped to a specific room or channel.
 * This is used in `MemoryMetadata` to control how memories are stored and retrieved based on context.
 */
type MemoryScope = 'shared' | 'private' | 'room';
/**
 * Base interface for all memory metadata types.
 * It includes common properties for all memories, such as:
 * - `type`: The kind of memory (e.g., `MemoryType.MESSAGE`, `MemoryType.DOCUMENT`).
 * - `source`: An optional string indicating the origin of the memory (e.g., 'discord', 'user_input').
 * - `sourceId`: An optional UUID linking to a source entity or object.
 * - `scope`: The visibility scope of the memory (`shared`, `private`, or `room`).
 * - `timestamp`: An optional numerical timestamp (e.g., milliseconds since epoch) of when the memory was created or relevant.
 * - `tags`: Optional array of strings for categorizing or filtering memories.
 * Specific metadata types like `DocumentMetadata` or `MessageMetadata` extend this base.
 */
interface BaseMetadata {
    type: MemoryTypeAlias;
    source?: string;
    sourceId?: UUID;
    scope?: MemoryScope;
    timestamp?: number;
    tags?: string[];
}
interface DocumentMetadata extends BaseMetadata {
    type: MemoryType.DOCUMENT;
}
interface FragmentMetadata extends BaseMetadata {
    type: MemoryType.FRAGMENT;
    documentId: UUID;
    position: number;
}
interface MessageMetadata extends BaseMetadata {
    type: MemoryType.MESSAGE;
}
interface DescriptionMetadata extends BaseMetadata {
    type: MemoryType.DESCRIPTION;
}
interface CustomMetadata extends BaseMetadata {
    [key: string]: unknown;
}
type MemoryMetadata = DocumentMetadata | FragmentMetadata | MessageMetadata | DescriptionMetadata | CustomMetadata;
/**
 * Represents a stored memory/message
 */
interface Memory {
    /** Optional unique identifier */
    id?: UUID;
    /** Associated user ID */
    entityId: UUID;
    /** Associated agent ID */
    agentId?: UUID;
    /** Optional creation timestamp in milliseconds since epoch */
    createdAt?: number;
    /** Memory content */
    content: Content;
    /** Optional embedding vector for semantic search */
    embedding?: number[];
    /** Associated room ID */
    roomId: UUID;
    /** Associated world ID (optional) */
    worldId?: UUID;
    /** Whether memory is unique (used to prevent duplicates) */
    unique?: boolean;
    /** Embedding similarity score (set when retrieved via search) */
    similarity?: number;
    /** Metadata for the memory */
    metadata?: MemoryMetadata;
}
/**
 * Specialized memory type for messages with enhanced type checking
 */
interface MessageMemory extends Memory {
    metadata: MessageMetadata;
    content: Content & {
        text: string;
    };
}
/**
 * Factory function to create a new message memory with proper defaults
 */
declare function createMessageMemory(params: {
    id?: UUID;
    entityId: UUID;
    agentId?: UUID;
    roomId: UUID;
    content: Content & {
        text: string;
    };
    embedding?: number[];
}): MessageMemory;
/**
 * Type guard to check if a memory metadata is a DocumentMetadata
 * @param metadata The metadata to check
 * @returns True if the metadata is a DocumentMetadata
 */
declare function isDocumentMetadata(metadata: MemoryMetadata): metadata is DocumentMetadata;
/**
 * Type guard to check if a memory metadata is a FragmentMetadata
 * @param metadata The metadata to check
 * @returns True if the metadata is a FragmentMetadata
 */
declare function isFragmentMetadata(metadata: MemoryMetadata): metadata is FragmentMetadata;
/**
 * Type guard to check if a memory metadata is a MessageMetadata
 * @param metadata The metadata to check
 * @returns True if the metadata is a MessageMetadata
 */
declare function isMessageMetadata(metadata: MemoryMetadata): metadata is MessageMetadata;
/**
 * Type guard to check if a memory metadata is a DescriptionMetadata
 * @param metadata The metadata to check
 * @returns True if the metadata is a DescriptionMetadata
 */
declare function isDescriptionMetadata(metadata: MemoryMetadata): metadata is DescriptionMetadata;
/**
 * Type guard to check if a memory metadata is a CustomMetadata
 * @param metadata The metadata to check
 * @returns True if the metadata is a CustomMetadata
 */
declare function isCustomMetadata(metadata: MemoryMetadata): metadata is CustomMetadata;
/**
 * Memory type guard for document memories
 */
declare function isDocumentMemory(memory: Memory): memory is Memory & {
    metadata: DocumentMetadata;
};
/**
 * Memory type guard for fragment memories
 */
declare function isFragmentMemory(memory: Memory): memory is Memory & {
    metadata: FragmentMetadata;
};
/**
 * Safely access the text content of a memory
 * @param memory The memory to extract text from
 * @param defaultValue Optional default value if no text is found
 * @returns The text content or default value
 */
declare function getMemoryText(memory: Memory, defaultValue?: string): string;

/**
 * Represents a single item of knowledge that can be processed and stored by the agent.
 * Knowledge items consist of content (text and optional structured data) and metadata.
 * These items are typically added to the agent's knowledge base via `AgentRuntime.addKnowledge`
 * and retrieved using `AgentRuntime.getKnowledge`.
 * The `id` is a unique identifier for the knowledge item, often derived from its source or content.
 */
type KnowledgeItem = {
    /** A Universally Unique Identifier for this specific knowledge item. */
    id: UUID;
    /** The actual content of the knowledge item, which must include text and can have other fields. */
    content: Content;
    /** Optional metadata associated with this knowledge item, conforming to `MemoryMetadata`. */
    metadata?: MemoryMetadata;
};
/**
 * Defines the scope or visibility of knowledge items within the agent's system.
 * - `SHARED`: Indicates knowledge that is broadly accessible, potentially across different agents or users if the system architecture permits.
 * - `PRIVATE`: Indicates knowledge that is restricted, typically to the specific agent or user context it belongs to.
 * This enum is used to manage access and retrieval of knowledge items, often in conjunction with `AgentRuntime.addKnowledge` or `AgentRuntime.getKnowledge` scopes.
 */
declare enum KnowledgeScope {
    SHARED = "shared",
    PRIVATE = "private"
}
/**
 * Specifies prefixes for keys used in caching mechanisms, helping to namespace cached data.
 * For example, `KNOWLEDGE` might be used to prefix keys for cached knowledge embeddings or processed documents.
 * This helps in organizing the cache and avoiding key collisions.
 * Used internally by caching strategies, potentially within `IDatabaseAdapter` cache methods or runtime caching layers.
 */
declare enum CacheKeyPrefix {
    KNOWLEDGE = "knowledge"
}
/**
 * Represents an item within a directory listing, specifically for knowledge loading.
 * When an agent's `Character.knowledge` configuration includes a directory, this type
 * is used to specify the path to that directory and whether its contents should be treated as shared.
 * - `directory`: The path to the directory containing knowledge files.
 * - `shared`: An optional boolean (defaults to false) indicating if the knowledge from this directory is considered shared or private.
 */
interface DirectoryItem {
    /** The path to the directory containing knowledge files. */
    directory: string;
    /** If true, knowledge from this directory is considered shared; otherwise, it's private. Defaults to false. */
    shared?: boolean;
}
/**
 * Represents a row structure, typically from a database query related to text chunking or processing.
 * This interface is quite minimal and seems to be a placeholder or a base for more specific chunk-related types.
 * The `id` would be the unique identifier for the chunk.
 * It might be used when splitting large documents into smaller, manageable pieces for embedding or analysis.
 */
interface ChunkRow {
    /** The unique identifier for this chunk of text. */
    id: string;
}

interface Component {
    id: UUID;
    entityId: UUID;
    agentId: UUID;
    roomId: UUID;
    worldId: UUID;
    sourceEntityId: UUID;
    type: string;
    createdAt: number;
    data: Metadata;
}
/**
 * Represents a user account
 */
interface Entity {
    /** Unique identifier, optional on creation */
    id?: UUID;
    /** Names of the entity */
    names: string[];
    /** Optional additional metadata */
    metadata?: Metadata;
    /** Agent ID this account is related to, for agents should be themselves */
    agentId: UUID;
    /** Optional array of components */
    components?: Component[];
}
/**
 * Defines roles within a system, typically for access control or permissions, often within a `World`.
 * - `OWNER`: Represents the highest level of control, typically the creator or primary administrator.
 * - `ADMIN`: Represents administrative privileges, usually a subset of owner capabilities.
 * - `NONE`: Indicates no specific role or default, minimal permissions.
 * These roles are often used in `World.metadata.roles` to assign roles to entities.
 */
declare enum Role {
    OWNER = "OWNER",
    ADMIN = "ADMIN",
    NONE = "NONE"
}
type World = {
    id: UUID;
    name?: string;
    agentId: UUID;
    serverId: string;
    metadata?: {
        ownership?: {
            ownerId: string;
        };
        roles?: {
            [entityId: UUID]: Role;
        };
        [key: string]: unknown;
    };
};
declare enum ChannelType {
    SELF = "SELF",// Messages to self
    DM = "DM",// Direct messages between two participants
    GROUP = "GROUP",// Group messages with multiple participants
    VOICE_DM = "VOICE_DM",// Voice direct messages
    VOICE_GROUP = "VOICE_GROUP",// Voice channels with multiple participants
    FEED = "FEED",// Social media feed
    THREAD = "THREAD",// Threaded conversation
    WORLD = "WORLD",// World channel
    FORUM = "FORUM",// Forum discussion
    API = "API"
}
type Room = {
    id: UUID;
    name?: string;
    agentId?: UUID;
    source: string;
    type: ChannelType;
    channelId?: string;
    serverId?: string;
    worldId?: UUID;
    metadata?: Metadata;
};
type RoomMetadata = {
    [key: string]: unknown;
};
/**
 * Room participant with account details
 */
interface Participant {
    /** Unique identifier */
    id: UUID;
    /** Associated account */
    entity: Entity;
}
/**
 * Represents a relationship between users
 */
interface Relationship {
    /** Unique identifier */
    id: UUID;
    /** First user ID */
    sourceEntityId: UUID;
    /** Second user ID */
    targetEntityId: UUID;
    /** Agent ID */
    agentId: UUID;
    /** Tags for filtering/categorizing relationships */
    tags: string[];
    /** Additional metadata about the relationship */
    metadata: Metadata;
    /** Optional creation timestamp */
    createdAt?: string;
}

/**
 * Example message for demonstration
 */
interface MessageExample {
    /** Associated user */
    name: string;
    /** Message content */
    content: Content;
}
type TemplateType = string | ((options: {
    state: State | {
        [key: string]: string;
    };
}) => string);
/**
 * Configuration for an agent's character, defining its personality, knowledge, and capabilities.
 * This is a central piece of an agent's definition, used by the `AgentRuntime` to initialize and operate the agent.
 * It includes:
 * - `id`: Optional unique identifier for the character.
 * - `name`, `username`: Identifying names for the character.
 * - `system`: A system prompt that guides the agent's overall behavior.
 * - `templates`: A map of prompt templates for various situations (e.g., message generation, summarization).
 * - `bio`: A textual biography or description of the character.
 * - `messageExamples`, `postExamples`: Examples of how the character communicates.
 * - `topics`, `adjectives`: Keywords describing the character's knowledge areas and traits.
 * - `knowledge`: Paths to knowledge files or directories to be loaded into the agent's memory.
 * - `plugins`: A list of plugin names to be loaded for this character.
 * - `settings`, `secrets`: Configuration key-value pairs, with secrets being handled more securely.
 * - `style`: Guidelines for the character's writing style in different contexts (chat, post).
 */
interface Character {
    /** Optional unique identifier */
    id?: UUID;
    /** Character name */
    name: string;
    /** Optional username */
    username?: string;
    /** Optional system prompt */
    system?: string;
    /** Optional prompt templates */
    templates?: {
        [key: string]: TemplateType;
    };
    /** Character biography */
    bio: string | string[];
    /** Example messages */
    messageExamples?: MessageExample[][];
    /** Example posts */
    postExamples?: string[];
    /** Known topics */
    topics?: string[];
    /** Character traits */
    adjectives?: string[];
    /** Optional knowledge base */
    knowledge?: (string | {
        path: string;
        shared?: boolean;
    } | DirectoryItem)[];
    /** Available plugins */
    plugins?: string[];
    /** Optional configuration */
    settings?: {
        [key: string]: string | boolean | number | Record<string, any>;
    };
    /** Optional secrets */
    secrets?: {
        [key: string]: string | boolean | number;
    };
    /** Writing style guides */
    style?: {
        all?: string[];
        chat?: string[];
        post?: string[];
    };
}
declare enum AgentStatus {
    ACTIVE = "active",
    INACTIVE = "inactive"
}
/**
 * Represents an operational agent, extending the `Character` definition with runtime status and timestamps.
 * While `Character` defines the blueprint, `Agent` represents an instantiated and potentially running version.
 * It includes:
 * - `enabled`: A boolean indicating if the agent is currently active or disabled.
 * - `status`: The current operational status, typically `AgentStatus.ACTIVE` or `AgentStatus.INACTIVE`.
 * - `createdAt`, `updatedAt`: Timestamps for when the agent record was created and last updated in the database.
 * This interface is primarily used by the `IDatabaseAdapter` for agent management.
 */
interface Agent extends Character {
    enabled?: boolean;
    status?: AgentStatus;
    createdAt: number;
    updatedAt: number;
}

/**
 * Defines the contract for a Task Worker, which is responsible for executing a specific type of task.
 * Task workers are registered with the `AgentRuntime` and are invoked when a `Task` of their designated `name` needs processing.
 * This pattern allows for modular and extensible background task processing.
 */
interface TaskWorker {
    /** The unique name of the task type this worker handles. This name links `Task` instances to this worker. */
    name: string;
    /**
     * The core execution logic for the task. This function is called by the runtime when a task needs to be processed.
     * It receives the `AgentRuntime`, task-specific `options`, and the `Task` object itself.
     */
    execute: (runtime: IAgentRuntime, options: {
        [key: string]: unknown;
    }, task: Task) => Promise<void>;
    /**
     * Optional validation function that can be used to determine if a task is valid or should be executed,
     * often based on the current message and state. This might be used by an action or evaluator
     * before creating or queueing a task.
     */
    validate?: (runtime: IAgentRuntime, message: Memory, state: State) => Promise<boolean>;
}
/**
 * Defines metadata associated with a `Task`.
 * This can include scheduling information like `updateInterval` or UI-related details
 * for presenting task options to a user.
 * The `[key: string]: unknown;` allows for additional, unspecified metadata fields.
 */
type TaskMetadata = {
    /** Optional. If the task is recurring, this specifies the interval in milliseconds between updates or executions. */
    updateInterval?: number;
    /** Optional. Describes options or parameters that can be configured for this task, often for UI presentation. */
    options?: {
        name: string;
        description: string;
    }[];
    /** Allows for other dynamic metadata properties related to the task. */
    [key: string]: unknown;
};
/**
 * Represents a task to be performed, often in the background or at a later time.
 * Tasks are managed by the `AgentRuntime` and processed by registered `TaskWorker`s.
 * They can be associated with a room, world, and tagged for categorization and retrieval.
 * The `IDatabaseAdapter` handles persistence of task data.
 */
interface Task {
    /** Optional. A Universally Unique Identifier for the task. Generated if not provided. */
    id?: UUID;
    /** The name of the task, which should correspond to a registered `TaskWorker.name`. */
    name: string;
    /** Optional. Timestamp of the last update to this task. */
    updatedAt?: number;
    /** Optional. Metadata associated with the task, conforming to `TaskMetadata`. */
    metadata?: TaskMetadata;
    /** A human-readable description of what the task does or its purpose. */
    description: string;
    /** Optional. The UUID of the room this task is associated with. */
    roomId?: UUID;
    /** Optional. The UUID of the world this task is associated with. */
    worldId?: UUID;
    entityId?: UUID;
    tags: string[];
}

/**
 * Represents a log entry
 */
interface Log {
    /** Optional unique identifier */
    id?: UUID;
    /** Associated entity ID */
    entityId: UUID;
    /** Associated room ID */
    roomId?: UUID;
    /** Log body */
    body: {
        [key: string]: unknown;
    };
    /** Log type */
    type: string;
    /** Log creation timestamp */
    createdAt: Date;
}
/**
 * Interface for database operations
 */
interface IDatabaseAdapter {
    /** Database instance */
    db: any;
    /** Initialize database connection */
    initialize(config?: any): Promise<void>;
    /** Initialize database connection */
    init(): Promise<void>;
    /** Run database migrations */
    runMigrations(schema?: any, pluginName?: string): Promise<void>;
    /** Check if the database connection is ready */
    isReady(): Promise<boolean>;
    /** Close database connection */
    close(): Promise<void>;
    getConnection(): Promise<any>;
    getAgent(agentId: UUID): Promise<Agent | null>;
    /** Get all agents */
    getAgents(): Promise<Partial<Agent>[]>;
    createAgent(agent: Partial<Agent>): Promise<boolean>;
    updateAgent(agentId: UUID, agent: Partial<Agent>): Promise<boolean>;
    deleteAgent(agentId: UUID): Promise<boolean>;
    ensureEmbeddingDimension(dimension: number): Promise<void>;
    /** Get entity by IDs */
    getEntitiesByIds(entityIds: UUID[]): Promise<Entity[] | null>;
    /** Get entities for room */
    getEntitiesForRoom(roomId: UUID, includeComponents?: boolean): Promise<Entity[]>;
    /** Create new entities */
    createEntities(entities: Entity[]): Promise<boolean>;
    /** Update entity */
    updateEntity(entity: Entity): Promise<void>;
    /** Get component by ID */
    getComponent(entityId: UUID, type: string, worldId?: UUID, sourceEntityId?: UUID): Promise<Component | null>;
    /** Get all components for an entity */
    getComponents(entityId: UUID, worldId?: UUID, sourceEntityId?: UUID): Promise<Component[]>;
    /** Create component */
    createComponent(component: Component): Promise<boolean>;
    /** Update component */
    updateComponent(component: Component): Promise<void>;
    /** Delete component */
    deleteComponent(componentId: UUID): Promise<void>;
    /** Get memories matching criteria */
    getMemories(params: {
        entityId?: UUID;
        agentId?: UUID;
        count?: number;
        unique?: boolean;
        tableName: string;
        start?: number;
        end?: number;
        roomId?: UUID;
        worldId?: UUID;
    }): Promise<Memory[]>;
    getMemoryById(id: UUID): Promise<Memory | null>;
    getMemoriesByIds(ids: UUID[], tableName?: string): Promise<Memory[]>;
    getMemoriesByRoomIds(params: {
        tableName: string;
        roomIds: UUID[];
        limit?: number;
    }): Promise<Memory[]>;
    getCachedEmbeddings(params: {
        query_table_name: string;
        query_threshold: number;
        query_input: string;
        query_field_name: string;
        query_field_sub_name: string;
        query_match_count: number;
    }): Promise<{
        embedding: number[];
        levenshtein_score: number;
    }[]>;
    log(params: {
        body: {
            [key: string]: unknown;
        };
        entityId: UUID;
        roomId: UUID;
        type: string;
    }): Promise<void>;
    getLogs(params: {
        entityId: UUID;
        roomId?: UUID;
        type?: string;
        count?: number;
        offset?: number;
    }): Promise<Log[]>;
    deleteLog(logId: UUID): Promise<void>;
    searchMemories(params: {
        embedding: number[];
        match_threshold?: number;
        count?: number;
        unique?: boolean;
        tableName: string;
        query?: string;
        roomId?: UUID;
        worldId?: UUID;
        entityId?: UUID;
    }): Promise<Memory[]>;
    createMemory(memory: Memory, tableName: string, unique?: boolean): Promise<UUID>;
    updateMemory(memory: Partial<Memory> & {
        id: UUID;
        metadata?: MemoryMetadata;
    }): Promise<boolean>;
    deleteMemory(memoryId: UUID): Promise<void>;
    deleteManyMemories(memoryIds: UUID[]): Promise<void>;
    deleteAllMemories(roomId: UUID, tableName: string): Promise<void>;
    countMemories(roomId: UUID, unique?: boolean, tableName?: string): Promise<number>;
    createWorld(world: World): Promise<UUID>;
    getWorld(id: UUID): Promise<World | null>;
    removeWorld(id: UUID): Promise<void>;
    getAllWorlds(): Promise<World[]>;
    updateWorld(world: World): Promise<void>;
    getRoomsByIds(roomIds: UUID[]): Promise<Room[] | null>;
    createRooms(rooms: Room[]): Promise<UUID[]>;
    deleteRoom(roomId: UUID): Promise<void>;
    deleteRoomsByWorldId(worldId: UUID): Promise<void>;
    updateRoom(room: Room): Promise<void>;
    getRoomsForParticipant(entityId: UUID): Promise<UUID[]>;
    getRoomsForParticipants(userIds: UUID[]): Promise<UUID[]>;
    getRoomsByWorld(worldId: UUID): Promise<Room[]>;
    removeParticipant(entityId: UUID, roomId: UUID): Promise<boolean>;
    getParticipantsForEntity(entityId: UUID): Promise<Participant[]>;
    getParticipantsForRoom(roomId: UUID): Promise<UUID[]>;
    addParticipantsRoom(entityIds: UUID[], roomId: UUID): Promise<boolean>;
    getParticipantUserState(roomId: UUID, entityId: UUID): Promise<'FOLLOWED' | 'MUTED' | null>;
    setParticipantUserState(roomId: UUID, entityId: UUID, state: 'FOLLOWED' | 'MUTED' | null): Promise<void>;
    /**
     * Creates a new relationship between two entities.
     * @param params Object containing the relationship details
     * @returns Promise resolving to boolean indicating success
     */
    createRelationship(params: {
        sourceEntityId: UUID;
        targetEntityId: UUID;
        tags?: string[];
        metadata?: Metadata;
    }): Promise<boolean>;
    /**
     * Updates an existing relationship between two entities.
     * @param relationship The relationship object with updated data
     * @returns Promise resolving to void
     */
    updateRelationship(relationship: Relationship): Promise<void>;
    /**
     * Retrieves a relationship between two entities if it exists.
     * @param params Object containing the entity IDs and agent ID
     * @returns Promise resolving to the Relationship object or null if not found
     */
    getRelationship(params: {
        sourceEntityId: UUID;
        targetEntityId: UUID;
    }): Promise<Relationship | null>;
    /**
     * Retrieves all relationships for a specific entity.
     * @param params Object containing the user ID, agent ID and optional tags to filter by
     * @returns Promise resolving to an array of Relationship objects
     */
    getRelationships(params: {
        entityId: UUID;
        tags?: string[];
    }): Promise<Relationship[]>;
    getCache<T>(key: string): Promise<T | undefined>;
    setCache<T>(key: string, value: T): Promise<boolean>;
    deleteCache(key: string): Promise<boolean>;
    createTask(task: Task): Promise<UUID>;
    getTasks(params: {
        roomId?: UUID;
        tags?: string[];
        entityId?: UUID;
    }): Promise<Task[]>;
    getTask(id: UUID): Promise<Task | null>;
    getTasksByName(name: string): Promise<Task[]>;
    updateTask(id: UUID, task: Partial<Task>): Promise<void>;
    deleteTask(id: UUID): Promise<void>;
    getMemoriesByWorldId(params: {
        worldId: UUID;
        count?: number;
        tableName?: string;
    }): Promise<Memory[]>;
}
/**
 * Result interface for embedding similarity searches
 */
interface EmbeddingSearchResult {
    embedding: number[];
    levenshtein_score: number;
}
/**
 * Options for memory retrieval operations
 */
interface MemoryRetrievalOptions {
    roomId: UUID;
    count?: number;
    unique?: boolean;
    start?: number;
    end?: number;
    agentId?: UUID;
}
/**
 * Options for memory search operations
 */
interface MemorySearchOptions {
    embedding: number[];
    match_threshold?: number;
    count?: number;
    roomId: UUID;
    agentId?: UUID;
    unique?: boolean;
    metadata?: Partial<MemoryMetadata>;
}
/**
 * Options for multi-room memory retrieval
 */
interface MultiRoomMemoryOptions {
    roomIds: UUID[];
    limit?: number;
    agentId?: UUID;
}
/**
 * Unified options pattern for memory operations
 * Provides a simpler, more consistent interface
 */
interface UnifiedMemoryOptions {
    roomId: UUID;
    limit?: number;
    agentId?: UUID;
    unique?: boolean;
    start?: number;
    end?: number;
}
/**
 * Specialized memory search options
 */
interface UnifiedSearchOptions extends UnifiedMemoryOptions {
    embedding: number[];
    similarity?: number;
}
/**
 * Represents a generic database connection object.
 * The actual type of this connection will depend on the specific database adapter implementation
 * (e.g., a connection pool object for PostgreSQL, a client instance for a NoSQL database).
 * This `unknown` type serves as a placeholder in the abstract `IDatabaseAdapter`.
 */
type DbConnection = unknown;
declare const VECTOR_DIMS: {
    readonly SMALL: 384;
    readonly MEDIUM: 512;
    readonly LARGE: 768;
    readonly XL: 1024;
    readonly XXL: 1536;
    readonly XXXL: 3072;
};

/**
 * Information describing the target of a message.
 */
interface TargetInfo {
    source: string;
    roomId?: UUID;
    channelId?: string;
    serverId?: string;
    entityId?: UUID;
    threadId?: string;
}
/**
 * Function signature for handlers responsible for sending messages to specific platforms.
 */
type SendHandlerFunction = (runtime: IAgentRuntime, target: TargetInfo, content: Content) => Promise<void>;
declare enum SOCKET_MESSAGE_TYPE {
    ROOM_JOINING = 1,
    SEND_MESSAGE = 2,
    MESSAGE = 3,
    ACK = 4,
    THINKING = 5,
    CONTROL = 6
}
/**
 * Interface for control messages sent from the backend to the frontend
 * to manage UI state and interaction capabilities
 */
interface ControlMessage {
    /** Message type identifier */
    type: 'control';
    /** Control message payload */
    payload: {
        /** Action to perform */
        action: 'disable_input' | 'enable_input';
        /** Optional target element identifier */
        target?: string;
        /** Additional optional parameters */
        [key: string]: unknown;
    };
    /** Room ID to ensure signal is directed to the correct chat window */
    roomId: UUID;
}

type ModelTypeName = (typeof ModelType)[keyof typeof ModelType] | string;
/**
 * Defines the recognized types of models that the agent runtime can use.
 * These include models for text generation (small, large, reasoning, completion),
 * text embedding, tokenization (encode/decode), image generation and description,
 * audio transcription, text-to-speech, and generic object generation.
 * This constant is used throughout the system, particularly in `AgentRuntime.useModel`,
 * `AgentRuntime.registerModel`, and in `ModelParamsMap` / `ModelResultMap` to ensure
 * type safety and clarity when working with different AI models.
 * String values are used for extensibility with custom model types.
 */
declare const ModelType: {
    readonly SMALL: "TEXT_SMALL";
    readonly MEDIUM: "TEXT_LARGE";
    readonly LARGE: "TEXT_LARGE";
    readonly TEXT_SMALL: "TEXT_SMALL";
    readonly TEXT_LARGE: "TEXT_LARGE";
    readonly TEXT_EMBEDDING: "TEXT_EMBEDDING";
    readonly TEXT_TOKENIZER_ENCODE: "TEXT_TOKENIZER_ENCODE";
    readonly TEXT_TOKENIZER_DECODE: "TEXT_TOKENIZER_DECODE";
    readonly TEXT_REASONING_SMALL: "REASONING_SMALL";
    readonly TEXT_REASONING_LARGE: "REASONING_LARGE";
    readonly TEXT_COMPLETION: "TEXT_COMPLETION";
    readonly IMAGE: "IMAGE";
    readonly IMAGE_DESCRIPTION: "IMAGE_DESCRIPTION";
    readonly TRANSCRIPTION: "TRANSCRIPTION";
    readonly TEXT_TO_SPEECH: "TEXT_TO_SPEECH";
    readonly AUDIO: "AUDIO";
    readonly VIDEO: "VIDEO";
    readonly OBJECT_SMALL: "OBJECT_SMALL";
    readonly OBJECT_LARGE: "OBJECT_LARGE";
};
/**
 * Model configuration setting keys used in character settings.
 * These constants define the keys for accessing model parameters
 * from character configuration with support for per-model-type settings.
 *
 * Setting Precedence (highest to lowest):
 * 1. Parameters passed directly to useModel()
 * 2. Model-specific settings (e.g., TEXT_SMALL_TEMPERATURE)
 * 3. Default settings (e.g., DEFAULT_TEMPERATURE)
 *
 * Example character settings:
 * ```
 * settings: {
 *   DEFAULT_TEMPERATURE: 0.7,              // Applies to all models
 *   TEXT_SMALL_TEMPERATURE: 0.5,           // Overrides default for TEXT_SMALL
 *   TEXT_LARGE_MAX_TOKENS: 4096,           // Specific to TEXT_LARGE
 *   OBJECT_SMALL_TEMPERATURE: 0.3,         // Specific to OBJECT_SMALL
 * }
 * ```
 */
declare const MODEL_SETTINGS: {
    readonly DEFAULT_MAX_TOKENS: "DEFAULT_MAX_TOKENS";
    readonly DEFAULT_TEMPERATURE: "DEFAULT_TEMPERATURE";
    readonly DEFAULT_FREQUENCY_PENALTY: "DEFAULT_FREQUENCY_PENALTY";
    readonly DEFAULT_PRESENCE_PENALTY: "DEFAULT_PRESENCE_PENALTY";
    readonly TEXT_SMALL_MAX_TOKENS: "TEXT_SMALL_MAX_TOKENS";
    readonly TEXT_SMALL_TEMPERATURE: "TEXT_SMALL_TEMPERATURE";
    readonly TEXT_SMALL_FREQUENCY_PENALTY: "TEXT_SMALL_FREQUENCY_PENALTY";
    readonly TEXT_SMALL_PRESENCE_PENALTY: "TEXT_SMALL_PRESENCE_PENALTY";
    readonly TEXT_LARGE_MAX_TOKENS: "TEXT_LARGE_MAX_TOKENS";
    readonly TEXT_LARGE_TEMPERATURE: "TEXT_LARGE_TEMPERATURE";
    readonly TEXT_LARGE_FREQUENCY_PENALTY: "TEXT_LARGE_FREQUENCY_PENALTY";
    readonly TEXT_LARGE_PRESENCE_PENALTY: "TEXT_LARGE_PRESENCE_PENALTY";
    readonly OBJECT_SMALL_MAX_TOKENS: "OBJECT_SMALL_MAX_TOKENS";
    readonly OBJECT_SMALL_TEMPERATURE: "OBJECT_SMALL_TEMPERATURE";
    readonly OBJECT_SMALL_FREQUENCY_PENALTY: "OBJECT_SMALL_FREQUENCY_PENALTY";
    readonly OBJECT_SMALL_PRESENCE_PENALTY: "OBJECT_SMALL_PRESENCE_PENALTY";
    readonly OBJECT_LARGE_MAX_TOKENS: "OBJECT_LARGE_MAX_TOKENS";
    readonly OBJECT_LARGE_TEMPERATURE: "OBJECT_LARGE_TEMPERATURE";
    readonly OBJECT_LARGE_FREQUENCY_PENALTY: "OBJECT_LARGE_FREQUENCY_PENALTY";
    readonly OBJECT_LARGE_PRESENCE_PENALTY: "OBJECT_LARGE_PRESENCE_PENALTY";
    readonly MODEL_MAX_TOKEN: "MODEL_MAX_TOKEN";
    readonly MODEL_TEMPERATURE: "MODEL_TEMPERATURE";
    readonly MODEL_FREQ_PENALTY: "MODEL_FREQ_PENALTY";
    readonly MODEL_PRESENCE_PENALTY: "MODEL_PRESENCE_PENALTY";
};
/**
 * Helper to get the model-specific setting key for a given model type and parameter.
 * @param modelType The model type (e.g., TEXT_SMALL, TEXT_LARGE)
 * @param param The parameter name (e.g., MAX_TOKENS, TEMPERATURE)
 * @returns The appropriate setting key or null if not a supported model type
 */
declare function getModelSpecificSettingKey(modelType: ModelTypeName, param: 'MAX_TOKENS' | 'TEMPERATURE' | 'FREQUENCY_PENALTY' | 'PRESENCE_PENALTY'): string | null;
/**
 * Parameters for generating text using a language model.
 * This structure is typically passed to `AgentRuntime.useModel` when the `modelType` is one of
 * `ModelType.TEXT_SMALL`, `ModelType.TEXT_LARGE`, `ModelType.TEXT_REASONING_SMALL`,
 * `ModelType.TEXT_REASONING_LARGE`, or `ModelType.TEXT_COMPLETION`.
 * It includes essential information like the prompt, model type, and various generation controls.
 */
type GenerateTextParams = {
    /** The `AgentRuntime` instance, providing access to models and other services. */
    runtime: IAgentRuntime;
    /** The input string or prompt that the language model will use to generate text. */
    prompt: string;
    /** Specifies the type of text generation model to use (e.g., TEXT_LARGE, REASONING_SMALL). */
    modelType: ModelTypeName;
    /** Optional. The maximum number of tokens to generate in the response. */
    maxTokens?: number;
    /** Optional. Controls randomness (0.0-1.0). Lower values are more deterministic, higher are more creative. */
    temperature?: number;
    /** Optional. Penalizes new tokens based on their existing frequency in the text so far. */
    frequencyPenalty?: number;
    /** Optional. Penalizes new tokens based on whether they appear in the text so far. */
    presencePenalty?: number;
    /** Optional. A list of sequences at which the model will stop generating further tokens. */
    stopSequences?: string[];
};
/**
 * Parameters for detokenizing text, i.e., converting a sequence of numerical tokens back into a string.
 * This is the reverse operation of tokenization.
 * This structure is used with `AgentRuntime.useModel` when the `modelType` is `ModelType.TEXT_TOKENIZER_DECODE`.
 */
interface DetokenizeTextParams {
    /** An array of numerical tokens to be converted back into text. */
    tokens: number[];
    /** The model type used for detokenization, ensuring consistency with the original tokenization. */
    modelType: ModelTypeName;
}
/**
 * Base parameters common to all model types
 */
interface BaseModelParams {
    /** The agent runtime for accessing services and utilities */
    runtime: IAgentRuntime;
}
/**
 * Parameters for text generation models
 */
interface TextGenerationParams extends BaseModelParams {
    /** The prompt to generate text from */
    prompt: string;
    /** Model temperature (0.0 to 1.0, lower is more deterministic) */
    temperature?: number;
    /** Maximum number of tokens to generate */
    maxTokens?: number;
    /** Sequences that should stop generation when encountered */
    stopSequences?: string[];
    /** Frequency penalty to apply */
    frequencyPenalty?: number;
    /** Presence penalty to apply */
    presencePenalty?: number;
}
/**
 * Parameters for text embedding models
 */
interface TextEmbeddingParams extends BaseModelParams {
    /** The text to create embeddings for */
    text: string;
}
/**
 * Parameters for text tokenization models
 */
interface TokenizeTextParams extends BaseModelParams {
    /** The text to tokenize */
    prompt: string;
    /** The model type to use for tokenization */
    modelType: ModelTypeName;
}
/**
 * Parameters for image generation models
 */
interface ImageGenerationParams extends BaseModelParams {
    /** The prompt describing the image to generate */
    prompt: string;
    /** The dimensions of the image to generate */
    size?: string;
    /** Number of images to generate */
    count?: number;
}
/**
 * Parameters for image description models
 */
interface ImageDescriptionParams extends BaseModelParams {
    /** The URL or path of the image to describe */
    imageUrl: string;
    /** Optional prompt to guide the description */
    prompt?: string;
}
/**
 * Parameters for transcription models
 */
interface TranscriptionParams extends BaseModelParams {
    /** The URL or path of the audio file to transcribe */
    audioUrl: string;
    /** Optional prompt to guide transcription */
    prompt?: string;
}
/**
 * Parameters for text-to-speech models
 */
interface TextToSpeechParams extends BaseModelParams {
    /** The text to convert to speech */
    text: string;
    /** The voice to use */
    voice?: string;
    /** The speaking speed */
    speed?: number;
}
/**
 * Parameters for audio processing models
 */
interface AudioProcessingParams extends BaseModelParams {
    /** The URL or path of the audio file to process */
    audioUrl: string;
    /** The type of audio processing to perform */
    processingType: string;
}
/**
 * Parameters for video processing models
 */
interface VideoProcessingParams extends BaseModelParams {
    /** The URL or path of the video file to process */
    videoUrl: string;
    /** The type of video processing to perform */
    processingType: string;
}
/**
 * Optional JSON schema for validating generated objects
 */
type JSONSchema = {
    type: string;
    properties?: Record<string, any>;
    required?: string[];
    items?: JSONSchema;
    [key: string]: any;
};
/**
 * Parameters for object generation models
 * @template T - The expected return type, inferred from schema if provided
 */
interface ObjectGenerationParams extends BaseModelParams {
    /** The prompt describing the object to generate */
    prompt: string;
    /** Optional JSON schema for validation */
    schema?: JSONSchema;
    /** Type of object to generate */
    output?: 'object' | 'array' | 'enum';
    /** For enum type, the allowed values */
    enumValues?: string[];
    /** Model type to use */
    modelType?: ModelTypeName;
    /** Model temperature (0.0 to 1.0) */
    temperature?: number;
    /** Sequences that should stop generation */
    stopSequences?: string[];
}
/**
 * Map of model types to their parameter types
 */
interface ModelParamsMap {
    [ModelType.TEXT_SMALL]: TextGenerationParams;
    [ModelType.TEXT_LARGE]: TextGenerationParams;
    [ModelType.TEXT_EMBEDDING]: TextEmbeddingParams | string | null;
    [ModelType.TEXT_TOKENIZER_ENCODE]: TokenizeTextParams;
    [ModelType.TEXT_TOKENIZER_DECODE]: DetokenizeTextParams;
    [ModelType.TEXT_REASONING_SMALL]: TextGenerationParams;
    [ModelType.TEXT_REASONING_LARGE]: TextGenerationParams;
    [ModelType.IMAGE]: ImageGenerationParams;
    [ModelType.IMAGE_DESCRIPTION]: ImageDescriptionParams | string;
    [ModelType.TRANSCRIPTION]: TranscriptionParams | Buffer | string;
    [ModelType.TEXT_TO_SPEECH]: TextToSpeechParams | string;
    [ModelType.AUDIO]: AudioProcessingParams;
    [ModelType.VIDEO]: VideoProcessingParams;
    [ModelType.OBJECT_SMALL]: ObjectGenerationParams;
    [ModelType.OBJECT_LARGE]: ObjectGenerationParams;
    [key: string]: BaseModelParams | any;
}
/**
 * Map of model types to their return value types
 */
interface ModelResultMap {
    [ModelType.TEXT_SMALL]: string;
    [ModelType.TEXT_LARGE]: string;
    [ModelType.TEXT_EMBEDDING]: number[];
    [ModelType.TEXT_TOKENIZER_ENCODE]: number[];
    [ModelType.TEXT_TOKENIZER_DECODE]: string;
    [ModelType.TEXT_REASONING_SMALL]: string;
    [ModelType.TEXT_REASONING_LARGE]: string;
    [ModelType.IMAGE]: {
        url: string;
    }[];
    [ModelType.IMAGE_DESCRIPTION]: {
        title: string;
        description: string;
    };
    [ModelType.TRANSCRIPTION]: string;
    [ModelType.TEXT_TO_SPEECH]: any | Buffer;
    [ModelType.AUDIO]: any;
    [ModelType.VIDEO]: any;
    [ModelType.OBJECT_SMALL]: any;
    [ModelType.OBJECT_LARGE]: any;
    [key: string]: any;
}
/**
 * Defines the structure for a model handler registration within the `AgentRuntime`.
 * Each model (e.g., for text generation, embedding) is associated with a handler function,
 * the name of the provider (plugin or system) that registered it, and an optional priority.
 * The `priority` (higher is more preferred) helps in selecting which handler to use if multiple
 * handlers are registered for the same model type. The `registrationOrder` (not in type, but used in runtime)
 * serves as a tie-breaker. See `AgentRuntime.registerModel` and `AgentRuntime.getModel`.
 */
interface ModelHandler {
    /** The function that executes the model, taking runtime and parameters, and returning a Promise. */
    handler: (runtime: IAgentRuntime, params: Record<string, unknown>) => Promise<unknown>;
    /** The name of the provider (e.g., plugin name) that registered this model handler. */
    provider: string;
    /**
     * Optional priority for this model handler. Higher numbers indicate higher priority.
     * This is used by `AgentRuntime.getModel` to select the most appropriate handler
     * when multiple are available for a given model type. Defaults to 0 if not specified.
     */
    priority?: number;
    registrationOrder?: number;
}

/**
 * Standard event types across all platforms
 */
declare enum EventType {
    WORLD_JOINED = "WORLD_JOINED",
    WORLD_CONNECTED = "WORLD_CONNECTED",
    WORLD_LEFT = "WORLD_LEFT",
    ENTITY_JOINED = "ENTITY_JOINED",
    ENTITY_LEFT = "ENTITY_LEFT",
    ENTITY_UPDATED = "ENTITY_UPDATED",
    ROOM_JOINED = "ROOM_JOINED",
    ROOM_LEFT = "ROOM_LEFT",
    MESSAGE_RECEIVED = "MESSAGE_RECEIVED",
    MESSAGE_SENT = "MESSAGE_SENT",
    MESSAGE_DELETED = "MESSAGE_DELETED",
    CHANNEL_CLEARED = "CHANNEL_CLEARED",
    VOICE_MESSAGE_RECEIVED = "VOICE_MESSAGE_RECEIVED",
    VOICE_MESSAGE_SENT = "VOICE_MESSAGE_SENT",
    REACTION_RECEIVED = "REACTION_RECEIVED",
    POST_GENERATED = "POST_GENERATED",
    INTERACTION_RECEIVED = "INTERACTION_RECEIVED",
    RUN_STARTED = "RUN_STARTED",
    RUN_ENDED = "RUN_ENDED",
    RUN_TIMEOUT = "RUN_TIMEOUT",
    ACTION_STARTED = "ACTION_STARTED",
    ACTION_COMPLETED = "ACTION_COMPLETED",
    EVALUATOR_STARTED = "EVALUATOR_STARTED",
    EVALUATOR_COMPLETED = "EVALUATOR_COMPLETED",
    MODEL_USED = "MODEL_USED"
}
/**
 * Platform-specific event type prefix
 */
declare enum PlatformPrefix {
    DISCORD = "DISCORD",
    TELEGRAM = "TELEGRAM",
    TWITTER = "TWITTER"
}
/**
 * Base payload interface for all events
 */
interface EventPayload {
    runtime: IAgentRuntime;
    source: string;
    onComplete?: () => void;
}
/**
 * Payload for world-related events
 */
interface WorldPayload extends EventPayload {
    world: World;
    rooms: Room[];
    entities: Entity[];
}
/**
 * Payload for entity-related events
 */
interface EntityPayload extends EventPayload {
    entityId: UUID;
    worldId?: UUID;
    roomId?: UUID;
    metadata?: {
        orginalId: string;
        username: string;
        displayName?: string;
        [key: string]: any;
    };
}
/**
 * Payload for reaction-related events
 */
interface MessagePayload extends EventPayload {
    message: Memory;
    callback?: HandlerCallback;
    onComplete?: () => void;
}
/**
 * Payload for channel cleared events
 */
interface ChannelClearedPayload extends EventPayload {
    roomId: UUID;
    channelId: string;
    memoryCount: number;
}
/**
 * Payload for events that are invoked without a message
 */
interface InvokePayload extends EventPayload {
    worldId: UUID;
    userId: string;
    roomId: UUID;
    callback?: HandlerCallback;
    source: string;
}
/**
 * Run event payload type
 */
interface RunEventPayload extends EventPayload {
    runId: UUID;
    messageId: UUID;
    roomId: UUID;
    entityId: UUID;
    startTime: number;
    status: 'started' | 'completed' | 'timeout';
    endTime?: number;
    duration?: number;
    error?: string;
}
/**
 * Action event payload type
 */
interface ActionEventPayload extends EventPayload {
    actionId: UUID;
    actionName: string;
    startTime?: number;
    completed?: boolean;
    error?: Error;
}
/**
 * Evaluator event payload type
 */
interface EvaluatorEventPayload extends EventPayload {
    evaluatorId: UUID;
    evaluatorName: string;
    startTime?: number;
    completed?: boolean;
    error?: Error;
}
/**
 * Model event payload type
 */
interface ModelEventPayload extends EventPayload {
    provider: string;
    type: ModelTypeName;
    prompt: string;
    tokens?: {
        prompt: number;
        completion: number;
        total: number;
    };
}
type MessageReceivedHandlerParams = {
    runtime: IAgentRuntime;
    message: Memory;
    callback: HandlerCallback;
    onComplete?: () => void;
};
/**
 * Maps event types to their corresponding payload types
 */
interface EventPayloadMap {
    [EventType.WORLD_JOINED]: WorldPayload;
    [EventType.WORLD_CONNECTED]: WorldPayload;
    [EventType.WORLD_LEFT]: WorldPayload;
    [EventType.ENTITY_JOINED]: EntityPayload;
    [EventType.ENTITY_LEFT]: EntityPayload;
    [EventType.ENTITY_UPDATED]: EntityPayload;
    [EventType.MESSAGE_RECEIVED]: MessagePayload;
    [EventType.MESSAGE_SENT]: MessagePayload;
    [EventType.MESSAGE_DELETED]: MessagePayload;
    [EventType.CHANNEL_CLEARED]: ChannelClearedPayload;
    [EventType.REACTION_RECEIVED]: MessagePayload;
    [EventType.POST_GENERATED]: InvokePayload;
    [EventType.INTERACTION_RECEIVED]: MessagePayload;
    [EventType.RUN_STARTED]: RunEventPayload;
    [EventType.RUN_ENDED]: RunEventPayload;
    [EventType.RUN_TIMEOUT]: RunEventPayload;
    [EventType.ACTION_STARTED]: ActionEventPayload;
    [EventType.ACTION_COMPLETED]: ActionEventPayload;
    [EventType.EVALUATOR_STARTED]: EvaluatorEventPayload;
    [EventType.EVALUATOR_COMPLETED]: EvaluatorEventPayload;
    [EventType.MODEL_USED]: ModelEventPayload;
}
/**
 * Event handler function type
 */
type EventHandler<T extends keyof EventPayloadMap> = (payload: EventPayloadMap[T]) => Promise<void>;
/**
 * Defines a more specific type for event handlers, expecting an `Metadata`.
 * This aims to improve upon generic 'any' type handlers, providing a clearer contract
 * for functions that respond to events emitted within the agent runtime (see `emitEvent` in `AgentRuntime`).
 * Handlers can be synchronous or asynchronous.
 */
type TypedEventHandler = (data: Metadata) => Promise<void> | void;

/**
 * Core service type registry that can be extended by plugins via module augmentation.
 * Plugins can extend this interface to add their own service types:
 *
 * @example
 * ```typescript
 * declare module '@elizaos/core' {
 *   interface ServiceTypeRegistry {
 *     MY_CUSTOM_SERVICE: 'my_custom_service';
 *   }
 * }
 * ```
 */
interface ServiceTypeRegistry {
    TRANSCRIPTION: 'transcription';
    VIDEO: 'video';
    BROWSER: 'browser';
    PDF: 'pdf';
    REMOTE_FILES: 'aws_s3';
    WEB_SEARCH: 'web_search';
    EMAIL: 'email';
    TEE: 'tee';
    TASK: 'task';
    WALLET: 'wallet';
    LP_POOL: 'lp_pool';
    TOKEN_DATA: 'token_data';
    MESSAGE: 'message';
    POST: 'post';
    UNKNOWN: 'unknown';
}
/**
 * Type for service names that includes both core services and any plugin-registered services
 */
type ServiceTypeName = ServiceTypeRegistry[keyof ServiceTypeRegistry];
/**
 * Helper type to extract service type values from the registry
 */
type ServiceTypeValue<K extends keyof ServiceTypeRegistry> = ServiceTypeRegistry[K];
/**
 * Helper type to check if a service type exists in the registry
 */
type IsValidServiceType<T extends string> = T extends ServiceTypeName ? true : false;
/**
 * Type-safe service class definition
 */
type TypedServiceClass<T extends ServiceTypeName> = {
    new (runtime?: IAgentRuntime): Service;
    serviceType: T;
    start(runtime: IAgentRuntime): Promise<Service>;
};
/**
 * Map of service type names to their implementation classes
 */
interface ServiceClassMap {
}
/**
 * Helper to infer service instance type from service type name
 */
type ServiceInstance<T extends ServiceTypeName> = T extends keyof ServiceClassMap ? InstanceType<ServiceClassMap[T]> : Service;
/**
 * Runtime service registry type
 */
type ServiceRegistry<T extends ServiceTypeName = ServiceTypeName> = Map<T, Service>;
/**
 * Enumerates the recognized types of services that can be registered and used by the agent runtime.
 * Services provide specialized functionalities like audio transcription, video processing,
 * web browsing, PDF handling, file storage (e.g., AWS S3), web search, email integration,
 * secure execution via TEE (Trusted Execution Environment), and task management.
 * This constant is used in `AgentRuntime` for service registration and retrieval (e.g., `getService`).
 * Each service typically implements the `Service` abstract class or a more specific interface like `IVideoService`.
 */
declare const ServiceType: {
    readonly TRANSCRIPTION: "transcription";
    readonly VIDEO: "video";
    readonly BROWSER: "browser";
    readonly PDF: "pdf";
    readonly REMOTE_FILES: "aws_s3";
    readonly WEB_SEARCH: "web_search";
    readonly EMAIL: "email";
    readonly TEE: "tee";
    readonly TASK: "task";
    readonly WALLET: "wallet";
    readonly LP_POOL: "lp_pool";
    readonly TOKEN_DATA: "token_data";
    readonly MESSAGE: "message";
    readonly POST: "post";
    readonly UNKNOWN: "unknown";
};
/**
 * Client instance
 */
declare abstract class Service {
    /** Runtime instance */
    protected runtime: IAgentRuntime;
    constructor(runtime?: IAgentRuntime);
    abstract stop(): Promise<void>;
    /** Service type */
    static serviceType: string;
    /** Service name */
    abstract capabilityDescription: string;
    /** Service configuration */
    config?: Metadata;
    /** Start service connection */
    static start(_runtime: IAgentRuntime): Promise<Service>;
    /** Stop service connection */
    static stop(_runtime: IAgentRuntime): Promise<unknown>;
}
/**
 * Generic service interface that provides better type checking for services
 * @template ConfigType The configuration type for this service
 * @template ResultType The result type returned by the service operations
 */
interface TypedService<ConfigType extends Metadata = Metadata, ResultType = unknown> extends Service {
    /**
     * The configuration for this service instance
     */
    config?: ConfigType;
    /**
     * Process an input with this service
     * @param input The input to process
     * @returns A promise resolving to the result
     */
    process(input: unknown): Promise<ResultType>;
}
/**
 * Generic factory function to create a typed service instance
 * @param runtime The agent runtime
 * @param serviceType The type of service to get
 * @returns The service instance or null if not available
 */
declare function getTypedService<T extends TypedService<any, any>>(runtime: IAgentRuntime, serviceType: ServiceTypeName): T | null;
/**
 * Standardized service error type for consistent error handling
 */
interface ServiceError {
    code: string;
    message: string;
    details?: unknown;
    cause?: Error;
}
/**
 * Safely create a ServiceError from any caught error
 */
declare function createServiceError(error: unknown, code?: string): ServiceError;

/**
 * Represents a test case for evaluating agent or plugin functionality.
 * Each test case has a name and a function that contains the test logic.
 * The test function receives the `IAgentRuntime` instance, allowing it to interact with the agent's capabilities.
 * Test cases are typically grouped into `TestSuite`s.
 */
interface TestCase {
    /** A descriptive name for the test case, e.g., "should respond to greetings". */
    name: string;
    /**
     * The function that executes the test logic. It can be synchronous or asynchronous.
     * It receives the `IAgentRuntime` to interact with the agent and its services.
     * The function should typically contain assertions to verify expected outcomes.
     */
    fn: (runtime: IAgentRuntime) => Promise<void> | void;
}
/**
 * Represents a suite of related test cases for an agent or plugin.
 * This helps in organizing tests and running them collectively.
 * A `ProjectAgent` can define one or more `TestSuite`s.
 */
interface TestSuite {
    /** A descriptive name for the test suite, e.g., "Core Functionality Tests". */
    name: string;
    /** An array of `TestCase` objects that belong to this suite. */
    tests: TestCase[];
}

type Route = {
    type: 'GET' | 'POST' | 'PUT' | 'DELETE' | 'STATIC';
    path: string;
    filePath?: string;
    public?: boolean;
    name?: string extends {
        public: true;
    } ? string : string | undefined;
    handler?: (req: any, res: any, runtime: IAgentRuntime) => Promise<void>;
    isMultipart?: boolean;
};
/**
 * Plugin for extending agent functionality
 */
type PluginEvents = {
    [K in keyof EventPayloadMap]?: EventHandler<K>[];
} & {
    [key: string]: ((params: any) => Promise<any>)[];
};
interface Plugin {
    name: string;
    description: string;
    init?: (config: Record<string, string>, runtime: IAgentRuntime) => Promise<void>;
    config?: {
        [key: string]: any;
    };
    services?: (typeof Service)[];
    componentTypes?: {
        name: string;
        schema: Record<string, unknown>;
        validator?: (data: any) => boolean;
    }[];
    actions?: Action[];
    providers?: Provider[];
    evaluators?: Evaluator[];
    adapter?: IDatabaseAdapter;
    models?: {
        [key: string]: (...args: any[]) => Promise<any>;
    };
    events?: PluginEvents;
    routes?: Route[];
    tests?: TestSuite[];
    dependencies?: string[];
    testDependencies?: string[];
    priority?: number;
    schema?: any;
}
interface ProjectAgent {
    character: Character;
    init?: (runtime: IAgentRuntime) => Promise<void>;
    plugins?: Plugin[];
    tests?: TestSuite | TestSuite[];
}
interface Project {
    agents: ProjectAgent[];
}

/**
 * Represents the core runtime environment for an agent.
 * Defines methods for database interaction, plugin management, event handling,
 * state composition, model usage, and task management.
 */
interface IAgentRuntime extends IDatabaseAdapter {
    agentId: UUID;
    character: Character;
    providers: Provider[];
    actions: Action[];
    evaluators: Evaluator[];
    plugins: Plugin[];
    services: Map<ServiceTypeName, Service[]>;
    events: Map<string, ((params: any) => Promise<void>)[]>;
    fetch?: typeof fetch | null;
    routes: Route[];
    logger: any;
    registerPlugin(plugin: Plugin): Promise<void>;
    initialize(): Promise<void>;
    getConnection(): Promise<any>;
    getService<T extends Service>(service: ServiceTypeName | string): T | null;
    getServicesByType<T extends Service>(service: ServiceTypeName | string): T[];
    getAllServices(): Map<ServiceTypeName, Service[]>;
    registerService(service: typeof Service): Promise<void>;
    getRegisteredServiceTypes(): ServiceTypeName[];
    hasService(serviceType: ServiceTypeName | string): boolean;
    registerDatabaseAdapter(adapter: IDatabaseAdapter): void;
    setSetting(key: string, value: string | boolean | null | any, secret?: boolean): void;
    getSetting(key: string): string | boolean | null | any;
    getConversationLength(): number;
    processActions(message: Memory, responses: Memory[], state?: State, callback?: HandlerCallback): Promise<void>;
    evaluate(message: Memory, state?: State, didRespond?: boolean, callback?: HandlerCallback, responses?: Memory[]): Promise<Evaluator[] | null>;
    registerProvider(provider: Provider): void;
    registerAction(action: Action): void;
    registerEvaluator(evaluator: Evaluator): void;
    ensureConnections(entities: Entity[], rooms: Room[], source: string, world: World): Promise<void>;
    ensureConnection({ entityId, roomId, metadata, userName, worldName, name, source, channelId, serverId, type, worldId, userId, }: {
        entityId: UUID;
        roomId: UUID;
        userName?: string;
        name?: string;
        worldName?: string;
        source?: string;
        channelId?: string;
        serverId?: string;
        type: any;
        worldId: UUID;
        userId?: UUID;
        metadata?: Record<string, any>;
    }): Promise<void>;
    ensureParticipantInRoom(entityId: UUID, roomId: UUID): Promise<void>;
    ensureWorldExists(world: World): Promise<void>;
    ensureRoomExists(room: Room): Promise<void>;
    composeState(message: Memory, includeList?: string[], onlyInclude?: boolean, skipCache?: boolean): Promise<State>;
    useModel<T extends ModelTypeName, R = ModelResultMap[T]>(modelType: T, params: Omit<ModelParamsMap[T], 'runtime'> | any): Promise<R>;
    registerModel(modelType: ModelTypeName | string, handler: (params: any) => Promise<any>, provider: string, priority?: number): void;
    getModel(modelType: ModelTypeName | string): ((runtime: IAgentRuntime, params: any) => Promise<any>) | undefined;
    registerEvent(event: string, handler: (params: any) => Promise<void>): void;
    getEvent(event: string): ((params: any) => Promise<void>)[] | undefined;
    emitEvent(event: string | string[], params: any): Promise<void>;
    registerTaskWorker(taskHandler: TaskWorker): void;
    getTaskWorker(name: string): TaskWorker | undefined;
    stop(): Promise<void>;
    addEmbeddingToMemory(memory: Memory): Promise<Memory>;
    getAllMemories(): Promise<Memory[]>;
    clearAllAgentMemories(): Promise<void>;
    createRunId(): UUID;
    startRun(): UUID;
    endRun(): void;
    getCurrentRunId(): UUID;
    getEntityById(entityId: UUID): Promise<Entity | null>;
    getRoom(roomId: UUID): Promise<Room | null>;
    createEntity(entity: Entity): Promise<boolean>;
    createRoom({ id, name, source, type, channelId, serverId, worldId }: Room): Promise<UUID>;
    addParticipant(entityId: UUID, roomId: UUID): Promise<boolean>;
    getRooms(worldId: UUID): Promise<Room[]>;
    registerSendHandler(source: string, handler: SendHandlerFunction): void;
    sendMessageToTarget(target: TargetInfo, content: Content): Promise<void>;
}

/**
 * Example content with associated user for demonstration purposes
 */
interface ActionExample {
    /** User associated with the example */
    name: string;
    /** Content of the example */
    content: Content;
}
/**
 * Callback function type for handlers
 */
type HandlerCallback = (response: Content, files?: any) => Promise<Memory[]>;
/**
 * Handler function type for processing messages
 */
type Handler = (runtime: IAgentRuntime, message: Memory, state?: State, options?: {
    [key: string]: unknown;
}, callback?: HandlerCallback, responses?: Memory[]) => Promise<ActionResult | void | undefined>;
/**
 * Validator function type for actions/evaluators
 */
type Validator = (runtime: IAgentRuntime, message: Memory, state?: State) => Promise<boolean>;
/**
 * Represents an action the agent can perform
 */
interface Action {
    /** Similar action descriptions */
    similes?: string[];
    /** Detailed description */
    description: string;
    /** Example usages */
    examples?: ActionExample[][];
    /** Handler function */
    handler: Handler;
    /** Action name */
    name: string;
    /** Validation function */
    validate: Validator;
}
/**
 * Example for evaluating agent behavior
 */
interface EvaluationExample {
    /** Evaluation context */
    prompt: string;
    /** Example messages */
    messages: Array<ActionExample>;
    /** Expected outcome */
    outcome: string;
}
/**
 * Evaluator for assessing agent responses
 */
interface Evaluator {
    /** Whether to always run */
    alwaysRun?: boolean;
    /** Detailed description */
    description: string;
    /** Similar evaluator descriptions */
    similes?: string[];
    /** Example evaluations */
    examples: EvaluationExample[];
    /** Handler function */
    handler: Handler;
    /** Evaluator name */
    name: string;
    /** Validation function */
    validate: Validator;
}
interface ProviderResult {
    values?: {
        [key: string]: any;
    };
    data?: {
        [key: string]: any;
    };
    text?: string;
}
/**
 * Provider for external data/services
 */
interface Provider {
    /** Provider name */
    name: string;
    /** Description of the provider */
    description?: string;
    /** Whether the provider is dynamic */
    dynamic?: boolean;
    /** Position of the provider in the provider list, positive or negative */
    position?: number;
    /**
     * Whether the provider is private
     *
     * Private providers are not displayed in the regular provider list, they have to be called explicitly
     */
    private?: boolean;
    /** Data retrieval function */
    get: (runtime: IAgentRuntime, message: Memory, state: State) => Promise<ProviderResult>;
}
/**
 * Result returned by an action after execution
 * Used for action chaining and state management
 */
interface ActionResult {
    /** Optional text description of the result */
    text?: string;
    /** Values to merge into the state */
    values?: Record<string, any>;
    /** Data payload containing action-specific results */
    data?: Record<string, any>;
    /** Whether the action succeeded - defaults to true */
    success: boolean;
    /** Error information if the action failed */
    error?: string | Error;
}
/**
 * Context provided to actions during execution
 * Allows actions to access previous results and update state
 */
interface ActionContext {
    /** Results from previously executed actions in this run */
    previousResults: ActionResult[];
    /** Get a specific previous result by action name */
    getPreviousResult?: (actionName: string) => ActionResult | undefined;
}
/**
 * Helper function to create ActionResult with proper defaults
 */
declare function createActionResult(partial?: Partial<ActionResult>): ActionResult;

/**
 * Represents an agent's registration details within a Trusted Execution Environment (TEE) context.
 * This is typically stored in a database table (e.g., `TeeAgent`) to manage agents operating in a TEE.
 * It allows for multiple registrations of the same `agentId` to support scenarios where an agent might restart,
 * generating a new keypair and attestation each time.
 */
interface TeeAgent {
    /** Primary key for the TEE agent registration record (e.g., a UUID or auto-incrementing ID). */
    id: string;
    /** The core identifier of the agent, which can be duplicated across multiple TEE registrations. */
    agentId: string;
    /** The human-readable name of the agent. */
    agentName: string;
    /** Timestamp (e.g., Unix epoch in milliseconds) when this TEE registration was created. */
    createdAt: number;
    /** The public key associated with this specific TEE agent instance/session. */
    publicKey: string;
    /** The attestation document proving the authenticity and integrity of the TEE instance. */
    attestation: string;
}
/**
 * Defines the operational modes for a Trusted Execution Environment (TEE).
 * This enum is used to configure how TEE functionalities are engaged, allowing for
 * different setups for local development, Docker-based development, and production.
 */
declare enum TEEMode {
    /** TEE functionality is completely disabled. */
    OFF = "OFF",
    /** For local development, potentially using a TEE simulator. */
    LOCAL = "LOCAL",// For local development with simulator
    /** For Docker-based development environments, possibly with a TEE simulator. */
    DOCKER = "DOCKER",// For docker development with simulator
    /** For production deployments, using actual TEE hardware without a simulator. */
    PRODUCTION = "PRODUCTION"
}
/**
 * Represents a quote obtained during remote attestation for a Trusted Execution Environment (TEE).
 * This quote is a piece of evidence provided by the TEE, cryptographically signed, which can be
 * verified by a relying party to ensure the TEE's integrity and authenticity.
 */
interface RemoteAttestationQuote {
    /** The attestation quote data, typically a base64 encoded string or similar format. */
    quote: string;
    /** Timestamp (e.g., Unix epoch in milliseconds) when the quote was generated or received. */
    timestamp: number;
}
/**
 * Data structure used in the attestation process for deriving a key within a Trusted Execution Environment (TEE).
 * This information helps establish a secure channel or verify the identity of the agent instance
 * requesting key derivation.
 */
interface DeriveKeyAttestationData {
    /** The unique identifier of the agent for which the key derivation is being attested. */
    agentId: string;
    /** The public key of the agent instance involved in the key derivation process. */
    publicKey: string;
    /** Optional subject or context information related to the key derivation. */
    subject?: string;
}
/**
 * Represents a message that has been attested by a Trusted Execution Environment (TEE).
 * This structure binds a message to an agent's identity and a timestamp, all within the
 * context of a remote attestation process, ensuring the message originated from a trusted TEE instance.
 */
interface RemoteAttestationMessage {
    /** The unique identifier of the agent sending the attested message. */
    agentId: string;
    /** Timestamp (e.g., Unix epoch in milliseconds) when the message was attested or sent. */
    timestamp: number;
    /** The actual message content, including details about the entity, room, and the content itself. */
    message: {
        entityId: string;
        roomId: string;
        content: string;
    };
}
/**
 * Enumerates different types or vendors of Trusted Execution Environments (TEEs).
 * This allows the system to adapt to specific TEE technologies, like Intel TDX on DSTACK.
 */
declare enum TeeType {
    /** Represents Intel Trusted Domain Extensions (TDX) running on DSTACK infrastructure. */
    TDX_DSTACK = "tdx_dstack"
}
/**
 * Configuration for a TEE (Trusted Execution Environment) plugin.
 * This allows specifying the TEE vendor and any vendor-specific configurations.
 * It's used to initialize and configure TEE-related functionalities within the agent system.
 */
interface TeePluginConfig {
    /** Optional. The name or identifier of the TEE vendor (e.g., 'tdx_dstack' from `TeeType`). */
    vendor?: string;
    /** Optional. Vendor-specific configuration options, conforming to `TeeVendorConfig`. */
    vendorConfig?: Metadata;
}

/**
 * A standardized representation of a token holding.
 */
interface TokenBalance {
    address: string;
    balance: string;
    decimals: number;
    uiAmount?: number;
    name?: string;
    symbol?: string;
    logoURI?: string;
}
/**
 * Generic representation of token data that can be provided by various services.
 */
interface TokenData {
    id: string;
    symbol: string;
    name: string;
    address: string;
    chain: string;
    sourceProvider: string;
    price?: number;
    priceChange24hPercent?: number;
    priceChange24hUSD?: number;
    volume24hUSD?: number;
    marketCapUSD?: number;
    liquidity?: number;
    holders?: number;
    logoURI?: string;
    decimals?: number;
    lastUpdatedAt?: Date;
    raw?: any;
}
/**
 * Interface for a generic service that provides token data.
 */
declare abstract class ITokenDataService extends Service {
    static readonly serviceType: "token_data";
    readonly capabilityDescription: string;
    /**
     * Fetches detailed information for a single token.
     * @param address The token's contract address.
     * @param chain The blockchain the token resides on.
     * @returns A Promise resolving to TokenData or null if not found.
     */
    abstract getTokenDetails(address: string, chain: string): Promise<TokenData | null>;
    /**
     * Fetches a list of trending tokens.
     * @param chain Optional: Filter by a specific blockchain.
     * @param limit Optional: Number of tokens to return. Defaults to a service-specific value.
     * @param timePeriod Optional: Time period for trending data (e.g., '24h', '7d'). Defaults to service-specific.
     * @returns A Promise resolving to an array of TokenData.
     */
    abstract getTrendingTokens(chain?: string, limit?: number, timePeriod?: string): Promise<TokenData[]>;
    /**
     * Searches for tokens based on a query string.
     * @param query The search query (e.g., symbol, name, address).
     * @param chain Optional: Filter by a specific blockchain.
     * @param limit Optional: Number of results to return.
     * @returns A Promise resolving to an array of TokenData.
     */
    abstract searchTokens(query: string, chain?: string, limit?: number): Promise<TokenData[]>;
    /**
     * Fetches data for multiple tokens by their addresses on a specific chain.
     * @param addresses Array of token contract addresses.
     * @param chain The blockchain the tokens reside on.
     * @returns A Promise resolving to an array of TokenData. May not include all requested if some are not found.
     */
    abstract getTokensByAddresses(addresses: string[], chain: string): Promise<TokenData[]>;
}

/**
 * Interface representing settings with string key-value pairs.
 */
interface RuntimeSettings {
    [key: string]: string | undefined;
}
interface Setting {
    name: string;
    description: string;
    usageDescription: string;
    value: string | boolean | null;
    required: boolean;
    public?: boolean;
    secret?: boolean;
    validation?: (value: any) => boolean;
    dependsOn?: string[];
    onSetAction?: (value: any) => string;
    visibleIf?: (settings: {
        [key: string]: Setting;
    }) => boolean;
}
interface WorldSettings {
    [key: string]: Setting;
}
interface OnboardingConfig {
    settings: {
        [key: string]: Omit<Setting, 'value'>;
    };
}

/**
 * Represents a single asset holding within a wallet, including its value.
 * This extends a generic TokenBalance with wallet-specific valuation.
 */
interface WalletAsset extends TokenBalance {
    priceUsd?: number;
    valueUsd?: number;
}
/**
 * Represents the entire portfolio of assets in a wallet.
 */
interface WalletPortfolio {
    totalValueUsd: number;
    assets: WalletAsset[];
}
/**
 * Abstract interface for a Wallet Service.
 * Plugins that provide wallet functionality (e.g., for Solana, EVM) should implement this service.
 * It provides a standardized way for other plugins to query the state of a wallet.
 */
declare abstract class IWalletService extends Service {
    static readonly serviceType: "wallet";
    readonly capabilityDescription = "Provides standardized access to wallet balances and portfolios.";
    /**
     * Retrieves the entire portfolio of assets held by the wallet.
     * @param owner - Optional: The specific wallet address/owner to query if the service manages multiple.
     * @returns A promise that resolves to the wallet's portfolio.
     */
    abstract getPortfolio(owner?: string): Promise<WalletPortfolio>;
    /**
     * Retrieves the balance of a specific asset in the wallet.
     * @param assetAddress - The mint address or native identifier of the asset.
     * @param owner - Optional: The specific wallet address/owner to query.
     * @returns A promise that resolves to the user-friendly (decimal-adjusted) balance of the asset held.
     */
    abstract getBalance(assetAddress: string, owner?: string): Promise<number>;
    /**
     * Transfers SOL from a specified keypair to a given public key.
     * This is a low-level function primarily for Solana-based wallet services.
     * @param from - The Keypair of the sender.
     * @param to - The PublicKey of the recipient.
     * @param lamports - The amount in lamports to transfer.
     * @returns A promise that resolves with the transaction signature.
     */
    abstract transferSol(from: any, to: any, lamports: number): Promise<string>;
}

/**
 * A standardized representation of a liquidity pool from any DEX.
 */
type PoolInfo = {
    id: string;
    displayName?: string;
    dex: string;
    tokenA: {
        mint: string;
        symbol?: string;
        reserve?: string;
        decimals?: number;
    };
    tokenB: {
        mint: string;
        symbol?: string;
        reserve?: string;
        decimals?: number;
    };
    lpTokenMint?: string;
    apr?: number;
    apy?: number;
    tvl?: number;
    fee?: number;
    metadata?: Metadata;
};
/**
 * A standardized representation of a user's position in a liquidity pool.
 */
type LpPositionDetails = {
    poolId: string;
    dex: string;
    lpTokenBalance: TokenBalance;
    underlyingTokens: TokenBalance[];
    valueUsd?: number;
    accruedFees?: TokenBalance[];
    rewards?: TokenBalance[];
    metadata?: Metadata;
};
/**
 * A standardized result for blockchain transactions.
 */
type TransactionResult = {
    success: boolean;
    transactionId?: string;
    error?: string;
    data?: any;
};
/**
 * Abstract interface for a Liquidity Pool Service.
 * DEX-specific plugins (e.g., for Orca, Raydium) must implement this service
 * to allow the LP Manager to interact with them in a standardized way.
 */
declare abstract class ILpService extends Service {
    static readonly serviceType = "lp";
    readonly capabilityDescription = "Provides standardized access to DEX liquidity pools.";
    /**
     * Returns the name of the DEX this service interacts with.
     * @returns The name of the DEX (e.g., "Orca", "Raydium").
     */
    abstract getDexName(): string;
    /**
     * Fetches a list of available liquidity pools from the DEX.
     * @param tokenAMint - Optional: Filter pools by the mint address of the first token.
     * @param tokenBMint - Optional: Filter pools by the mint address of the second token.
     * @returns A promise that resolves to an array of standardized PoolInfo objects.
     */
    abstract getPools(tokenAMint?: string, tokenBMint?: string): Promise<PoolInfo[]>;
    /**
     * Adds liquidity to a specified pool.
     * @param params - The parameters for adding liquidity.
     * @returns A promise resolving to a transaction result, including the LP tokens received.
     */
    abstract addLiquidity(params: {
        userVault: any;
        poolId: string;
        tokenAAmountLamports: string;
        tokenBAmountLamports?: string;
        slippageBps: number;
        tickLowerIndex?: number;
        tickUpperIndex?: number;
    }): Promise<TransactionResult & {
        lpTokensReceived?: TokenBalance;
    }>;
    /**
     * Removes liquidity from a specified pool.
     * @param params - The parameters for removing liquidity.
     * @returns A promise resolving to a transaction result, including the tokens received.
     */
    abstract removeLiquidity(params: {
        userVault: any;
        poolId: string;
        lpTokenAmountLamports: string;
        slippageBps: number;
    }): Promise<TransactionResult & {
        tokensReceived?: TokenBalance[];
    }>;
    /**
     * Fetches the details of a specific LP position for a user.
     * @param userAccountPublicKey - The user's wallet public key.
     * @param poolOrPositionIdentifier - The identifier for the pool or a specific position (e.g., position NFT mint).
     * @returns A promise resolving to the position details or null if not found.
     */
    abstract getLpPositionDetails(userAccountPublicKey: string, poolOrPositionIdentifier: string): Promise<LpPositionDetails | null>;
    /**
     * Fetches the latest market data (e.g., APY, TVL) for a list of pools.
     * @param poolIds - An array of pool IDs to fetch data for.
     * @returns A promise resolving to a map of pool IDs to their partial market data.
     */
    abstract getMarketDataForPools(poolIds: string[]): Promise<Record<string, Partial<PoolInfo>>>;
}

interface PdfExtractionResult {
    text: string;
    pageCount: number;
    metadata?: {
        title?: string;
        author?: string;
        createdAt?: Date;
        modifiedAt?: Date;
    };
}
interface PdfGenerationOptions {
    format?: 'A4' | 'A3' | 'Letter';
    orientation?: 'portrait' | 'landscape';
    margins?: {
        top?: number;
        bottom?: number;
        left?: number;
        right?: number;
    };
    header?: string;
    footer?: string;
}
interface PdfConversionOptions {
    quality?: 'high' | 'medium' | 'low';
    outputFormat?: 'pdf' | 'pdf/a';
    compression?: boolean;
}
/**
 * Interface for PDF processing services
 */
declare abstract class IPdfService extends Service {
    static readonly serviceType: "pdf";
    readonly capabilityDescription = "PDF processing, extraction, and generation capabilities";
    /**
     * Extract text and metadata from a PDF file
     * @param pdfPath - Path to the PDF file or buffer
     * @returns Promise resolving to extracted text and metadata
     */
    abstract extractText(pdfPath: string | Buffer): Promise<PdfExtractionResult>;
    /**
     * Generate a PDF from HTML content
     * @param htmlContent - HTML content to convert to PDF
     * @param options - PDF generation options
     * @returns Promise resolving to PDF buffer
     */
    abstract generatePdf(htmlContent: string, options?: PdfGenerationOptions): Promise<Buffer>;
    /**
     * Convert a document to PDF format
     * @param filePath - Path to the document file
     * @param options - Conversion options
     * @returns Promise resolving to PDF buffer
     */
    abstract convertToPdf(filePath: string, options?: PdfConversionOptions): Promise<Buffer>;
    /**
     * Merge multiple PDF files into one
     * @param pdfPaths - Array of PDF file paths or buffers
     * @returns Promise resolving to merged PDF buffer
     */
    abstract mergePdfs(pdfPaths: (string | Buffer)[]): Promise<Buffer>;
    /**
     * Split a PDF into individual pages
     * @param pdfPath - Path to the PDF file or buffer
     * @returns Promise resolving to array of page buffers
     */
    abstract splitPdf(pdfPath: string | Buffer): Promise<Buffer[]>;
}

interface VideoInfo {
    title?: string;
    duration?: number;
    url: string;
    thumbnail?: string;
    description?: string;
    uploader?: string;
    viewCount?: number;
    uploadDate?: Date;
    formats?: VideoFormat[];
}
interface VideoFormat {
    formatId: string;
    url: string;
    extension: string;
    quality: string;
    fileSize?: number;
    videoCodec?: string;
    audioCodec?: string;
    resolution?: string;
    fps?: number;
    bitrate?: number;
}
interface VideoDownloadOptions {
    format?: string;
    quality?: 'best' | 'worst' | 'bestvideo' | 'bestaudio' | string;
    outputPath?: string;
    audioOnly?: boolean;
    videoOnly?: boolean;
    subtitles?: boolean;
    embedSubs?: boolean;
    writeInfoJson?: boolean;
}
interface VideoProcessingOptions {
    startTime?: number;
    endTime?: number;
    outputFormat?: string;
    resolution?: string;
    bitrate?: string;
    framerate?: number;
    audioCodec?: string;
    videoCodec?: string;
}
/**
 * Interface for video processing and download services
 */
declare abstract class IVideoService extends Service {
    static readonly serviceType: "video";
    readonly capabilityDescription = "Video download, processing, and conversion capabilities";
    /**
     * Get video information without downloading
     * @param url - Video URL
     * @returns Promise resolving to video information
     */
    abstract getVideoInfo(url: string): Promise<VideoInfo>;
    /**
     * Download a video from URL
     * @param url - Video URL
     * @param options - Download options
     * @returns Promise resolving to downloaded file path
     */
    abstract downloadVideo(url: string, options?: VideoDownloadOptions): Promise<string>;
    /**
     * Extract audio from video
     * @param videoPath - Path to video file or video URL
     * @param outputPath - Optional output path for audio file
     * @returns Promise resolving to audio file path
     */
    abstract extractAudio(videoPath: string, outputPath?: string): Promise<string>;
    /**
     * Generate thumbnail from video
     * @param videoPath - Path to video file or video URL
     * @param timestamp - Timestamp in seconds to capture thumbnail
     * @returns Promise resolving to thumbnail image path
     */
    abstract getThumbnail(videoPath: string, timestamp?: number): Promise<string>;
    /**
     * Convert video to different format
     * @param videoPath - Path to input video file
     * @param outputPath - Path for output video file
     * @param options - Processing options
     * @returns Promise resolving to converted video path
     */
    abstract convertVideo(videoPath: string, outputPath: string, options?: VideoProcessingOptions): Promise<string>;
    /**
     * Get available formats for a video URL
     * @param url - Video URL
     * @returns Promise resolving to available formats
     */
    abstract getAvailableFormats(url: string): Promise<VideoFormat[]>;
}

interface BrowserNavigationOptions {
    timeout?: number;
    waitUntil?: 'load' | 'domcontentloaded' | 'networkidle0' | 'networkidle2';
    viewport?: {
        width: number;
        height: number;
    };
    userAgent?: string;
    headers?: Record<string, string>;
}
interface ScreenshotOptions {
    fullPage?: boolean;
    clip?: {
        x: number;
        y: number;
        width: number;
        height: number;
    };
    format?: 'png' | 'jpeg' | 'webp';
    quality?: number;
    omitBackground?: boolean;
}
interface ElementSelector {
    selector: string;
    text?: string;
    timeout?: number;
}
interface ExtractedContent {
    text: string;
    html: string;
    links: Array<{
        url: string;
        text: string;
    }>;
    images: Array<{
        src: string;
        alt?: string;
    }>;
    title?: string;
    metadata?: Record<string, string>;
}
interface ClickOptions {
    timeout?: number;
    force?: boolean;
    waitForNavigation?: boolean;
}
interface TypeOptions {
    delay?: number;
    timeout?: number;
    clear?: boolean;
}
/**
 * Interface for browser automation services
 */
declare abstract class IBrowserService extends Service {
    static readonly serviceType: "browser";
    readonly capabilityDescription = "Web browser automation and scraping capabilities";
    /**
     * Navigate to a URL
     * @param url - URL to navigate to
     * @param options - Navigation options
     * @returns Promise resolving when navigation completes
     */
    abstract navigate(url: string, options?: BrowserNavigationOptions): Promise<void>;
    /**
     * Take a screenshot of the current page
     * @param options - Screenshot options
     * @returns Promise resolving to screenshot buffer
     */
    abstract screenshot(options?: ScreenshotOptions): Promise<Buffer>;
    /**
     * Extract text and content from the current page
     * @param selector - Optional CSS selector to extract from specific element
     * @returns Promise resolving to extracted content
     */
    abstract extractContent(selector?: string): Promise<ExtractedContent>;
    /**
     * Click on an element
     * @param selector - CSS selector or element selector
     * @param options - Click options
     * @returns Promise resolving when click completes
     */
    abstract click(selector: string | ElementSelector, options?: ClickOptions): Promise<void>;
    /**
     * Type text into an input field
     * @param selector - CSS selector for input field
     * @param text - Text to type
     * @param options - Typing options
     * @returns Promise resolving when typing completes
     */
    abstract type(selector: string, text: string, options?: TypeOptions): Promise<void>;
    /**
     * Wait for an element to appear
     * @param selector - CSS selector or element selector
     * @returns Promise resolving when element is found
     */
    abstract waitForElement(selector: string | ElementSelector): Promise<void>;
    /**
     * Evaluate JavaScript in the browser context
     * @param script - JavaScript code to evaluate
     * @param args - Arguments to pass to the script
     * @returns Promise resolving to evaluation result
     */
    abstract evaluate<T = any>(script: string, ...args: any[]): Promise<T>;
    /**
     * Get the current page URL
     * @returns Promise resolving to current URL
     */
    abstract getCurrentUrl(): Promise<string>;
    /**
     * Go back in browser history
     * @returns Promise resolving when navigation completes
     */
    abstract goBack(): Promise<void>;
    /**
     * Go forward in browser history
     * @returns Promise resolving when navigation completes
     */
    abstract goForward(): Promise<void>;
    /**
     * Refresh the current page
     * @returns Promise resolving when refresh completes
     */
    abstract refresh(): Promise<void>;
}

interface TranscriptionOptions {
    language?: string;
    model?: string;
    temperature?: number;
    prompt?: string;
    response_format?: 'json' | 'text' | 'srt' | 'vtt' | 'verbose_json';
    timestamp_granularities?: ('word' | 'segment')[];
    word_timestamps?: boolean;
    segment_timestamps?: boolean;
}
interface TranscriptionResult {
    text: string;
    language?: string;
    duration?: number;
    segments?: TranscriptionSegment[];
    words?: TranscriptionWord[];
    confidence?: number;
}
interface TranscriptionSegment {
    id: number;
    text: string;
    start: number;
    end: number;
    confidence?: number;
    tokens?: number[];
    temperature?: number;
    avg_logprob?: number;
    compression_ratio?: number;
    no_speech_prob?: number;
}
interface TranscriptionWord {
    word: string;
    start: number;
    end: number;
    confidence?: number;
}
interface SpeechToTextOptions {
    language?: string;
    model?: string;
    continuous?: boolean;
    interimResults?: boolean;
    maxAlternatives?: number;
}
interface TextToSpeechOptions {
    voice?: string;
    model?: string;
    speed?: number;
    format?: 'mp3' | 'wav' | 'flac' | 'aac';
    response_format?: 'mp3' | 'opus' | 'aac' | 'flac';
}
/**
 * Interface for audio transcription and speech services
 */
declare abstract class ITranscriptionService extends Service {
    static readonly serviceType: "transcription";
    readonly capabilityDescription = "Audio transcription and speech processing capabilities";
    /**
     * Transcribe audio file to text
     * @param audioPath - Path to audio file or audio buffer
     * @param options - Transcription options
     * @returns Promise resolving to transcription result
     */
    abstract transcribeAudio(audioPath: string | Buffer, options?: TranscriptionOptions): Promise<TranscriptionResult>;
    /**
     * Transcribe video file to text (extracts audio first)
     * @param videoPath - Path to video file or video buffer
     * @param options - Transcription options
     * @returns Promise resolving to transcription result
     */
    abstract transcribeVideo(videoPath: string | Buffer, options?: TranscriptionOptions): Promise<TranscriptionResult>;
    /**
     * Real-time speech to text from audio stream
     * @param audioStream - Audio stream or buffer
     * @param options - Speech to text options
     * @returns Promise resolving to transcription result
     */
    abstract speechToText(audioStream: NodeJS.ReadableStream | Buffer, options?: SpeechToTextOptions): Promise<TranscriptionResult>;
    /**
     * Convert text to speech
     * @param text - Text to convert to speech
     * @param options - Text to speech options
     * @returns Promise resolving to audio buffer
     */
    abstract textToSpeech(text: string, options?: TextToSpeechOptions): Promise<Buffer>;
    /**
     * Get supported languages for transcription
     * @returns Promise resolving to array of supported language codes
     */
    abstract getSupportedLanguages(): Promise<string[]>;
    /**
     * Get available voices for text to speech
     * @returns Promise resolving to array of available voices
     */
    abstract getAvailableVoices(): Promise<Array<{
        id: string;
        name: string;
        language: string;
        gender?: 'male' | 'female' | 'neutral';
    }>>;
    /**
     * Detect language of audio file
     * @param audioPath - Path to audio file or audio buffer
     * @returns Promise resolving to detected language code
     */
    abstract detectLanguage(audioPath: string | Buffer): Promise<string>;
}

interface SearchOptions {
    limit?: number;
    offset?: number;
    language?: string;
    region?: string;
    dateRange?: {
        start?: Date;
        end?: Date;
    };
    fileType?: string;
    site?: string;
    sortBy?: 'relevance' | 'date' | 'popularity';
    safeSearch?: 'strict' | 'moderate' | 'off';
}
interface SearchResult {
    title: string;
    url: string;
    description: string;
    displayUrl?: string;
    thumbnail?: string;
    publishedDate?: Date;
    source?: string;
    relevanceScore?: number;
    snippet?: string;
}
interface SearchResponse {
    query: string;
    results: SearchResult[];
    totalResults?: number;
    searchTime?: number;
    suggestions?: string[];
    nextPageToken?: string;
    relatedSearches?: string[];
}
interface NewsSearchOptions extends SearchOptions {
    category?: 'general' | 'business' | 'entertainment' | 'health' | 'science' | 'sports' | 'technology';
    freshness?: 'day' | 'week' | 'month';
}
interface ImageSearchOptions extends SearchOptions {
    size?: 'small' | 'medium' | 'large' | 'wallpaper' | 'any';
    color?: 'color' | 'monochrome' | 'red' | 'orange' | 'yellow' | 'green' | 'blue' | 'purple' | 'pink' | 'brown' | 'black' | 'gray' | 'white';
    type?: 'photo' | 'clipart' | 'line' | 'animated';
    layout?: 'square' | 'wide' | 'tall' | 'any';
    license?: 'any' | 'public' | 'share' | 'sharecommercially' | 'modify';
}
interface VideoSearchOptions extends SearchOptions {
    duration?: 'short' | 'medium' | 'long' | 'any';
    resolution?: 'high' | 'standard' | 'any';
    quality?: 'high' | 'standard' | 'any';
}
/**
 * Interface for web search services
 */
declare abstract class IWebSearchService extends Service {
    static readonly serviceType: "web_search";
    readonly capabilityDescription = "Web search and content discovery capabilities";
    /**
     * Perform a general web search
     * @param query - Search query
     * @param options - Search options
     * @returns Promise resolving to search results
     */
    abstract search(query: string, options?: SearchOptions): Promise<SearchResponse>;
    /**
     * Search for news articles
     * @param query - Search query
     * @param options - News search options
     * @returns Promise resolving to news search results
     */
    abstract searchNews(query: string, options?: NewsSearchOptions): Promise<SearchResponse>;
    /**
     * Search for images
     * @param query - Search query
     * @param options - Image search options
     * @returns Promise resolving to image search results
     */
    abstract searchImages(query: string, options?: ImageSearchOptions): Promise<SearchResponse>;
    /**
     * Search for videos
     * @param query - Search query
     * @param options - Video search options
     * @returns Promise resolving to video search results
     */
    abstract searchVideos(query: string, options?: VideoSearchOptions): Promise<SearchResponse>;
    /**
     * Get search suggestions for a query
     * @param query - Partial search query
     * @returns Promise resolving to array of suggestions
     */
    abstract getSuggestions(query: string): Promise<string[]>;
    /**
     * Get trending searches
     * @param region - Optional region code
     * @returns Promise resolving to trending search queries
     */
    abstract getTrendingSearches(region?: string): Promise<string[]>;
    /**
     * Get detailed information about a specific URL
     * @param url - URL to analyze
     * @returns Promise resolving to page information
     */
    abstract getPageInfo(url: string): Promise<{
        title: string;
        description: string;
        content: string;
        metadata: Record<string, string>;
        images: string[];
        links: string[];
    }>;
}

interface EmailAddress {
    email: string;
    name?: string;
}
interface EmailAttachment {
    filename: string;
    content: Buffer | string;
    contentType?: string;
    contentDisposition?: 'attachment' | 'inline';
    cid?: string;
}
interface EmailMessage {
    from: EmailAddress;
    to: EmailAddress[];
    cc?: EmailAddress[];
    bcc?: EmailAddress[];
    subject: string;
    text?: string;
    html?: string;
    attachments?: EmailAttachment[];
    replyTo?: EmailAddress;
    date?: Date;
    messageId?: string;
    references?: string[];
    inReplyTo?: string;
    priority?: 'high' | 'normal' | 'low';
}
interface EmailSendOptions {
    retry?: number;
    timeout?: number;
    trackOpens?: boolean;
    trackClicks?: boolean;
    tags?: string[];
}
interface EmailSearchOptions {
    query?: string;
    from?: string;
    to?: string;
    subject?: string;
    folder?: string;
    since?: Date;
    before?: Date;
    limit?: number;
    offset?: number;
    unread?: boolean;
    flagged?: boolean;
    hasAttachments?: boolean;
}
interface EmailFolder {
    name: string;
    path: string;
    type: 'inbox' | 'sent' | 'drafts' | 'trash' | 'spam' | 'custom';
    messageCount?: number;
    unreadCount?: number;
    children?: EmailFolder[];
}
interface EmailAccount {
    email: string;
    name?: string;
    provider?: string;
    folders?: EmailFolder[];
    quotaUsed?: number;
    quotaLimit?: number;
}
/**
 * Interface for email services
 */
declare abstract class IEmailService extends Service {
    static readonly serviceType: "email";
    readonly capabilityDescription = "Email sending, receiving, and management capabilities";
    /**
     * Send an email
     * @param message - Email message to send
     * @param options - Send options
     * @returns Promise resolving to message ID
     */
    abstract sendEmail(message: EmailMessage, options?: EmailSendOptions): Promise<string>;
    /**
     * Get emails from a folder
     * @param options - Search options
     * @returns Promise resolving to array of emails
     */
    abstract getEmails(options?: EmailSearchOptions): Promise<EmailMessage[]>;
    /**
     * Get a specific email by ID
     * @param messageId - Message ID
     * @returns Promise resolving to email message
     */
    abstract getEmail(messageId: string): Promise<EmailMessage>;
    /**
     * Delete an email
     * @param messageId - Message ID
     * @returns Promise resolving when deletion completes
     */
    abstract deleteEmail(messageId: string): Promise<void>;
    /**
     * Mark an email as read/unread
     * @param messageId - Message ID
     * @param read - True to mark as read, false for unread
     * @returns Promise resolving when operation completes
     */
    abstract markEmailAsRead(messageId: string, read: boolean): Promise<void>;
    /**
     * Flag/unflag an email
     * @param messageId - Message ID
     * @param flagged - True to flag, false to unflag
     * @returns Promise resolving when operation completes
     */
    abstract flagEmail(messageId: string, flagged: boolean): Promise<void>;
    /**
     * Move email to a different folder
     * @param messageId - Message ID
     * @param folderPath - Destination folder path
     * @returns Promise resolving when move completes
     */
    abstract moveEmail(messageId: string, folderPath: string): Promise<void>;
    /**
     * Get available folders
     * @returns Promise resolving to array of folders
     */
    abstract getFolders(): Promise<EmailFolder[]>;
    /**
     * Create a new folder
     * @param folderName - Name of the folder
     * @param parentPath - Optional parent folder path
     * @returns Promise resolving when folder is created
     */
    abstract createFolder(folderName: string, parentPath?: string): Promise<void>;
    /**
     * Get account information
     * @returns Promise resolving to account details
     */
    abstract getAccountInfo(): Promise<EmailAccount>;
    /**
     * Search emails
     * @param query - Search query
     * @param options - Search options
     * @returns Promise resolving to search results
     */
    abstract searchEmails(query: string, options?: EmailSearchOptions): Promise<EmailMessage[]>;
}

interface MessageParticipant {
    id: UUID;
    name: string;
    username?: string;
    avatar?: string;
    status?: 'online' | 'offline' | 'away' | 'busy';
}
interface MessageAttachment {
    id: UUID;
    filename: string;
    url: string;
    mimeType: string;
    size: number;
    width?: number;
    height?: number;
    duration?: number;
    thumbnail?: string;
}
interface MessageReaction {
    emoji: string;
    count: number;
    users: UUID[];
    hasReacted: boolean;
}
interface MessageReference {
    messageId: UUID;
    channelId: UUID;
    type: 'reply' | 'forward' | 'quote';
}
interface MessageContent {
    text?: string;
    html?: string;
    markdown?: string;
    attachments?: MessageAttachment[];
    reactions?: MessageReaction[];
    reference?: MessageReference;
    mentions?: UUID[];
    embeds?: Array<{
        title?: string;
        description?: string;
        url?: string;
        image?: string;
        fields?: Array<{
            name: string;
            value: string;
            inline?: boolean;
        }>;
    }>;
}
interface MessageInfo {
    id: UUID;
    channelId: UUID;
    senderId: UUID;
    content: MessageContent;
    timestamp: Date;
    edited?: Date;
    deleted?: Date;
    pinned?: boolean;
    thread?: {
        id: UUID;
        messageCount: number;
        participants: UUID[];
        lastMessageAt: Date;
    };
}
interface MessageSendOptions {
    replyTo?: UUID;
    ephemeral?: boolean;
    silent?: boolean;
    scheduled?: Date;
    thread?: UUID;
    nonce?: string;
}
interface MessageSearchOptions {
    query?: string;
    channelId?: UUID;
    senderId?: UUID;
    before?: Date;
    after?: Date;
    limit?: number;
    offset?: number;
    hasAttachments?: boolean;
    pinned?: boolean;
    mentions?: UUID;
}
interface MessageChannel {
    id: UUID;
    name: string;
    type: 'text' | 'voice' | 'dm' | 'group' | 'announcement' | 'thread';
    description?: string;
    participants?: MessageParticipant[];
    permissions?: {
        canSend: boolean;
        canRead: boolean;
        canDelete: boolean;
        canPin: boolean;
        canManage: boolean;
    };
    lastMessageAt?: Date;
    messageCount?: number;
    unreadCount?: number;
}
/**
 * Interface for messaging services
 */
declare abstract class IMessageService extends Service {
    static readonly serviceType: "message";
    readonly capabilityDescription = "Message sending, receiving, and management capabilities";
    /**
     * Send a message to a channel
     * @param channelId - Channel ID
     * @param content - Message content
     * @param options - Send options
     * @returns Promise resolving to message ID
     */
    abstract sendMessage(channelId: UUID, content: MessageContent, options?: MessageSendOptions): Promise<UUID>;
    /**
     * Get messages from a channel
     * @param channelId - Channel ID
     * @param options - Search options
     * @returns Promise resolving to array of messages
     */
    abstract getMessages(channelId: UUID, options?: MessageSearchOptions): Promise<MessageInfo[]>;
    /**
     * Get a specific message by ID
     * @param messageId - Message ID
     * @returns Promise resolving to message
     */
    abstract getMessage(messageId: UUID): Promise<MessageInfo>;
    /**
     * Edit a message
     * @param messageId - Message ID
     * @param content - New message content
     * @returns Promise resolving when edit completes
     */
    abstract editMessage(messageId: UUID, content: MessageContent): Promise<void>;
    /**
     * Delete a message
     * @param messageId - Message ID
     * @returns Promise resolving when deletion completes
     */
    abstract deleteMessage(messageId: UUID): Promise<void>;
    /**
     * Add a reaction to a message
     * @param messageId - Message ID
     * @param emoji - Reaction emoji
     * @returns Promise resolving when reaction is added
     */
    abstract addReaction(messageId: UUID, emoji: string): Promise<void>;
    /**
     * Remove a reaction from a message
     * @param messageId - Message ID
     * @param emoji - Reaction emoji
     * @returns Promise resolving when reaction is removed
     */
    abstract removeReaction(messageId: UUID, emoji: string): Promise<void>;
    /**
     * Pin a message
     * @param messageId - Message ID
     * @returns Promise resolving when message is pinned
     */
    abstract pinMessage(messageId: UUID): Promise<void>;
    /**
     * Unpin a message
     * @param messageId - Message ID
     * @returns Promise resolving when message is unpinned
     */
    abstract unpinMessage(messageId: UUID): Promise<void>;
    /**
     * Get available channels
     * @returns Promise resolving to array of channels
     */
    abstract getChannels(): Promise<MessageChannel[]>;
    /**
     * Get channel information
     * @param channelId - Channel ID
     * @returns Promise resolving to channel info
     */
    abstract getChannel(channelId: UUID): Promise<MessageChannel>;
    /**
     * Create a new channel
     * @param name - Channel name
     * @param type - Channel type
     * @param options - Channel options
     * @returns Promise resolving to new channel ID
     */
    abstract createChannel(name: string, type: MessageChannel['type'], options?: {
        description?: string;
        participants?: UUID[];
        private?: boolean;
    }): Promise<UUID>;
    /**
     * Search messages across channels
     * @param query - Search query
     * @param options - Search options
     * @returns Promise resolving to search results
     */
    abstract searchMessages(query: string, options?: MessageSearchOptions): Promise<MessageInfo[]>;
}

interface PostMedia {
    id: UUID;
    url: string;
    type: 'image' | 'video' | 'audio' | 'document';
    mimeType: string;
    size: number;
    width?: number;
    height?: number;
    duration?: number;
    thumbnail?: string;
    description?: string;
    altText?: string;
}
interface PostLocation {
    name: string;
    address?: string;
    coordinates?: {
        latitude: number;
        longitude: number;
    };
    placeId?: string;
}
interface PostAuthor {
    id: UUID;
    username: string;
    displayName: string;
    avatar?: string;
    verified?: boolean;
    followerCount?: number;
    followingCount?: number;
    bio?: string;
    website?: string;
}
interface PostEngagement {
    likes: number;
    shares: number;
    comments: number;
    views?: number;
    hasLiked: boolean;
    hasShared: boolean;
    hasCommented: boolean;
    hasSaved: boolean;
}
interface PostContent {
    text?: string;
    html?: string;
    media?: PostMedia[];
    location?: PostLocation;
    tags?: string[];
    mentions?: UUID[];
    links?: Array<{
        url: string;
        title?: string;
        description?: string;
        image?: string;
    }>;
    poll?: {
        question: string;
        options: Array<{
            text: string;
            votes: number;
        }>;
        expiresAt?: Date;
        multipleChoice?: boolean;
    };
}
interface PostInfo {
    id: UUID;
    author: PostAuthor;
    content: PostContent;
    platform: string;
    platformId: string;
    url: string;
    createdAt: Date;
    editedAt?: Date;
    scheduledAt?: Date;
    engagement: PostEngagement;
    visibility: 'public' | 'private' | 'followers' | 'friends' | 'unlisted';
    replyTo?: UUID;
    thread?: {
        id: UUID;
        position: number;
        total: number;
    };
    crossPosted?: Array<{
        platform: string;
        platformId: string;
        url: string;
    }>;
}
interface PostCreateOptions {
    platforms?: string[];
    scheduledAt?: Date;
    visibility?: PostInfo['visibility'];
    replyTo?: UUID;
    thread?: boolean;
    location?: PostLocation;
    tags?: string[];
    mentions?: UUID[];
    enableComments?: boolean;
    enableSharing?: boolean;
    contentWarning?: string;
    sensitive?: boolean;
}
interface PostSearchOptions {
    query?: string;
    author?: UUID;
    platform?: string;
    tags?: string[];
    mentions?: UUID[];
    since?: Date;
    before?: Date;
    limit?: number;
    offset?: number;
    hasMedia?: boolean;
    hasLocation?: boolean;
    visibility?: PostInfo['visibility'];
    sortBy?: 'date' | 'engagement' | 'relevance';
}
interface PostAnalytics {
    postId: UUID;
    platform: string;
    impressions: number;
    reach: number;
    engagement: PostEngagement;
    clicks: number;
    shares: number;
    saves: number;
    demographics?: {
        age?: Record<string, number>;
        gender?: Record<string, number>;
        location?: Record<string, number>;
    };
    topPerformingHours?: Array<{
        hour: number;
        engagement: number;
    }>;
}
/**
 * Interface for social media posting services
 */
declare abstract class IPostService extends Service {
    static readonly serviceType: "post";
    readonly capabilityDescription = "Social media posting and content management capabilities";
    /**
     * Create and publish a new post
     * @param content - Post content
     * @param options - Publishing options
     * @returns Promise resolving to post ID
     */
    abstract createPost(content: PostContent, options?: PostCreateOptions): Promise<UUID>;
    /**
     * Get posts from timeline or specific user
     * @param options - Search options
     * @returns Promise resolving to array of posts
     */
    abstract getPosts(options?: PostSearchOptions): Promise<PostInfo[]>;
    /**
     * Get a specific post by ID
     * @param postId - Post ID
     * @returns Promise resolving to post info
     */
    abstract getPost(postId: UUID): Promise<PostInfo>;
    /**
     * Edit an existing post
     * @param postId - Post ID
     * @param content - New post content
     * @returns Promise resolving when edit completes
     */
    abstract editPost(postId: UUID, content: PostContent): Promise<void>;
    /**
     * Delete a post
     * @param postId - Post ID
     * @returns Promise resolving when deletion completes
     */
    abstract deletePost(postId: UUID): Promise<void>;
    /**
     * Like/unlike a post
     * @param postId - Post ID
     * @param like - True to like, false to unlike
     * @returns Promise resolving when operation completes
     */
    abstract likePost(postId: UUID, like: boolean): Promise<void>;
    /**
     * Share/repost a post
     * @param postId - Post ID
     * @param comment - Optional comment when sharing
     * @returns Promise resolving to share ID
     */
    abstract sharePost(postId: UUID, comment?: string): Promise<UUID>;
    /**
     * Save/unsave a post
     * @param postId - Post ID
     * @param save - True to save, false to unsave
     * @returns Promise resolving when operation completes
     */
    abstract savePost(postId: UUID, save: boolean): Promise<void>;
    /**
     * Comment on a post
     * @param postId - Post ID
     * @param content - Comment content
     * @returns Promise resolving to comment ID
     */
    abstract commentOnPost(postId: UUID, content: PostContent): Promise<UUID>;
    /**
     * Get comments for a post
     * @param postId - Post ID
     * @param options - Search options
     * @returns Promise resolving to array of comments
     */
    abstract getComments(postId: UUID, options?: PostSearchOptions): Promise<PostInfo[]>;
    /**
     * Schedule a post for later publishing
     * @param content - Post content
     * @param scheduledAt - When to publish
     * @param options - Publishing options
     * @returns Promise resolving to scheduled post ID
     */
    abstract schedulePost(content: PostContent, scheduledAt: Date, options?: PostCreateOptions): Promise<UUID>;
    /**
     * Get analytics for a post
     * @param postId - Post ID
     * @returns Promise resolving to post analytics
     */
    abstract getPostAnalytics(postId: UUID): Promise<PostAnalytics>;
    /**
     * Get trending posts
     * @param options - Search options
     * @returns Promise resolving to trending posts
     */
    abstract getTrendingPosts(options?: PostSearchOptions): Promise<PostInfo[]>;
    /**
     * Search posts across platforms
     * @param query - Search query
     * @param options - Search options
     * @returns Promise resolving to search results
     */
    abstract searchPosts(query: string, options?: PostSearchOptions): Promise<PostInfo[]>;
}

/**
 * Composes a context string by replacing placeholders in a template with corresponding values from the state.
 *
 * This function takes a template string with placeholders in the format `{{placeholder}}` and a state object.
 * It replaces each placeholder with the value from the state object that matches the placeholder's name.
 * If a matching key is not found in the state object for a given placeholder, the placeholder is replaced with an empty string.
 *
 * @param {Object} params - The parameters for composing the context.
 * @param {State} params.state - The state object containing values to replace the placeholders in the template.
 * @param {TemplateType} params.template - The template string or function containing placeholders to be replaced with state values.
 * @returns {string} The composed context string with placeholders replaced by corresponding state values.
 *
 * @example
 * // Given a state object and a template
 * const state = { userName: "Alice", userAge: 30 };
 * const template = "Hello, {{userName}}! You are {{userAge}} years old";
 *
 * // Composing the context with simple string replacement will result in:
 * // "Hello, Alice! You are 30 years old."
 * const contextSimple = composePromptFromState({ state, template });
 *
 * // Using composePromptFromState with a template function for dynamic template
 * const template = ({ state }) => {
 * const tone = Math.random() > 0.5 ? "kind" : "rude";
 *   return `Hello, {{userName}}! You are {{userAge}} years old. Be ${tone}`;
 * };
 * const contextSimple = composePromptFromState({ state, template });
 */
/**
 * Function to compose a prompt using a provided template and state.
 * It compiles the template (upgrading double braces to triple braces for non-HTML escaping)
 * and then populates it with values from the state. Additionally, it processes the
 * resulting string with `composeRandomUser` to replace placeholders like `{{nameX}}`.
 *
 * @param {Object} options - Object containing state and template information.
 * @param {State} options.state - The state object containing values to fill the template.
 * @param {TemplateType} options.template - The template string or function to be used for composing the prompt.
 * @returns {string} The composed prompt output, with state values and random user names populated.
 */
declare const composePrompt: ({ state, template, }: {
    state: {
        [key: string]: string;
    };
    template: TemplateType;
}) => string;
/**
 * Function to compose a prompt using a provided template and state.
 *
 * @param {Object} options - Object containing state and template information.
 * @param {State} options.state - The state object containing values to fill the template.
 * @param {TemplateType} options.template - The template to be used for composing the prompt.
 * @returns {string} The composed prompt output.
 */
declare const composePromptFromState: ({ state, template, }: {
    state: State;
    template: TemplateType;
}) => string;
/**
 * Adds a header to a body of text.
 *
 * This function takes a header string and a body string and returns a new string with the header prepended to the body.
 * If the body string is empty, the header is returned as is.
 *
 * @param {string} header - The header to add to the body.
 * @param {string} body - The body to which to add the header.
 * @returns {string} The body with the header prepended.
 *
 * @example
 * // Given a header and a body
 * const header = "Header";
 * const body = "Body";
 *
 * // Adding the header to the body will result in:
 * // "Header\nBody"
 * const text = addHeader(header, body);
 */
declare const addHeader: (header: string, body: string) => string;
declare const formatPosts: ({ messages, entities, conversationHeader, }: {
    messages: Memory[];
    entities: Entity[];
    conversationHeader?: boolean;
}) => string;
/**
 * Format messages into a string
 * @param {Object} params - The formatting parameters
 * @param {Memory[]} params.messages - List of messages to format
 * @param {Entity[]} params.entities - List of entities for name resolution
 * @returns {string} Formatted message string with timestamps and user information
 */
declare const formatMessages: ({ messages, entities, }: {
    messages: Memory[];
    entities: Entity[];
}) => string;
declare const formatTimestamp: (messageDate: number) => string;
/**
 * Parses key-value pairs from a simple XML structure within a given text.
 * It looks for an XML block (e.g., <response>...</response>) and extracts
 * text content from direct child elements (e.g., <key>value</key>).
 *
 * Note: This uses regex and is suitable for simple, predictable XML structures.
 * For complex XML, a proper parsing library is recommended.
 *
 * @param text - The input text containing the XML structure.
 * @returns An object with key-value pairs extracted from the XML, or null if parsing fails.
 */
declare function parseKeyValueXml(text: string): Record<string, any> | null;
/**
 * Parses a JSON object from a given text. The function looks for a JSON block wrapped in triple backticks
 * with `json` language identifier, and if not found, it searches for an object pattern within the text.
 * It then attempts to parse the JSON string into a JavaScript object. If parsing is successful and the result
 * is an object (but not an array), it returns the object; otherwise, it tries to parse an array if the result
 * is an array, or returns null if parsing is unsuccessful or the result is neither an object nor an array.
 *
 * @param text - The input text from which to extract and parse the JSON object.
 * @returns An object parsed from the JSON string if successful; otherwise, null or the result of parsing an array.
 */
declare function parseJSONObjectFromText(text: string): Record<string, any> | null;
/**
 * Normalizes a JSON-like string by correcting formatting issues:
 * - Removes extra spaces after '{' and before '}'.
 * - Wraps unquoted values in double quotes.
 * - Converts single-quoted values to double-quoted.
 * - Ensures consistency in key-value formatting.
 * - Normalizes mixed adjacent quote pairs.
 *
 * This is useful for cleaning up improperly formatted JSON strings
 * before parsing them into valid JSON.
 *
 * @param str - The JSON-like string to normalize.
 * @returns A properly formatted JSON string.
 */
declare const normalizeJsonString: (str: string) => string;
/**
 * Truncate text to fit within the character limit, ensuring it ends at a complete sentence.
 */
declare function truncateToCompleteSentence(text: string, maxLength: number): string;
declare function splitChunks(content: string, chunkSize?: number, bleed?: number): Promise<string[]>;
/**
 * Trims the provided text prompt to a specified token limit using a tokenizer model and type.
 */
declare function trimTokens(prompt: string, maxTokens: number, runtime: IAgentRuntime): Promise<string>;
declare function safeReplacer(): (_key: string, value: any) => any;
/**
 * Parses a string to determine its boolean equivalent.
 *
 * Recognized affirmative values: "YES", "Y", "TRUE", "T", "1", "ON", "ENABLE"
 * Recognized negative values: "NO", "N", "FALSE", "F", "0", "OFF", "DISABLE"
 *
 * @param {string | undefined | null} value - The input text to parse
 * @returns {boolean} - Returns `true` for affirmative inputs, `false` for negative or unrecognized inputs
 */
declare function parseBooleanFromText(value: string | undefined | null): boolean;
/**
 * Validates a UUID value.
 *
 * @param {unknown} value - The value to validate.
 * @returns {UUID | null} Returns the validated UUID value or null if validation fails.
 */
declare function validateUuid(value: unknown): UUID | null;
/**
 * Converts a string or number to a UUID.
 *
 * @param {string | number} target - The string or number to convert to a UUID.
 * @returns {UUID} The UUID generated from the input target.
 * @throws {TypeError} Throws an error if the input target is not a string.
 */
declare function stringToUuid(target: string | number): UUID;
declare const getContentTypeFromMimeType: (mimeType: string) => ContentType | undefined;
declare function getLocalServerUrl(path: string): string;

declare const characterSchema: z.ZodObject<{
    id: z.ZodOptional<z.ZodString>;
    name: z.ZodString;
    username: z.ZodOptional<z.ZodString>;
    system: z.ZodOptional<z.ZodString>;
    templates: z.ZodOptional<z.ZodRecord<z.ZodString, z.ZodUnion<[z.ZodString, z.ZodOptional<z.ZodFunction<z.ZodTuple<[], z.ZodUnknown>, z.ZodUnknown>>]>>>;
    bio: z.ZodUnion<[z.ZodString, z.ZodArray<z.ZodString, "many">]>;
    messageExamples: z.ZodOptional<z.ZodArray<z.ZodArray<z.ZodObject<{
        name: z.ZodString;
        content: z.ZodObject<{
            text: z.ZodOptional<z.ZodString>;
            thought: z.ZodOptional<z.ZodString>;
            actions: z.ZodOptional<z.ZodArray<z.ZodString, "many">>;
            providers: z.ZodOptional<z.ZodArray<z.ZodString, "many">>;
            source: z.ZodOptional<z.ZodString>;
            target: z.ZodOptional<z.ZodString>;
            url: z.ZodOptional<z.ZodString>;
            inReplyTo: z.ZodOptional<z.ZodString>;
            attachments: z.ZodOptional<z.ZodArray<z.ZodAny, "many">>;
            channelType: z.ZodOptional<z.ZodString>;
        }, "passthrough", z.ZodTypeAny, z.objectOutputType<{
            text: z.ZodOptional<z.ZodString>;
            thought: z.ZodOptional<z.ZodString>;
            actions: z.ZodOptional<z.ZodArray<z.ZodString, "many">>;
            providers: z.ZodOptional<z.ZodArray<z.ZodString, "many">>;
            source: z.ZodOptional<z.ZodString>;
            target: z.ZodOptional<z.ZodString>;
            url: z.ZodOptional<z.ZodString>;
            inReplyTo: z.ZodOptional<z.ZodString>;
            attachments: z.ZodOptional<z.ZodArray<z.ZodAny, "many">>;
            channelType: z.ZodOptional<z.ZodString>;
        }, z.ZodTypeAny, "passthrough">, z.objectInputType<{
            text: z.ZodOptional<z.ZodString>;
            thought: z.ZodOptional<z.ZodString>;
            actions: z.ZodOptional<z.ZodArray<z.ZodString, "many">>;
            providers: z.ZodOptional<z.ZodArray<z.ZodString, "many">>;
            source: z.ZodOptional<z.ZodString>;
            target: z.ZodOptional<z.ZodString>;
            url: z.ZodOptional<z.ZodString>;
            inReplyTo: z.ZodOptional<z.ZodString>;
            attachments: z.ZodOptional<z.ZodArray<z.ZodAny, "many">>;
            channelType: z.ZodOptional<z.ZodString>;
        }, z.ZodTypeAny, "passthrough">>;
    }, "strip", z.ZodTypeAny, {
        name?: string;
        content?: {
            thought?: string;
            text?: string;
            actions?: string[];
            providers?: string[];
            source?: string;
            target?: string;
            url?: string;
            inReplyTo?: string;
            attachments?: any[];
            channelType?: string;
        } & {
            [k: string]: unknown;
        };
    }, {
        name?: string;
        content?: {
            thought?: string;
            text?: string;
            actions?: string[];
            providers?: string[];
            source?: string;
            target?: string;
            url?: string;
            inReplyTo?: string;
            attachments?: any[];
            channelType?: string;
        } & {
            [k: string]: unknown;
        };
    }>, "many">, "many">>;
    postExamples: z.ZodOptional<z.ZodArray<z.ZodString, "many">>;
    topics: z.ZodOptional<z.ZodArray<z.ZodString, "many">>;
    adjectives: z.ZodOptional<z.ZodArray<z.ZodString, "many">>;
    knowledge: z.ZodOptional<z.ZodArray<z.ZodUnion<[z.ZodString, z.ZodObject<{
        path: z.ZodString;
        shared: z.ZodOptional<z.ZodBoolean>;
    }, "strip", z.ZodTypeAny, {
        shared?: boolean;
        path?: string;
    }, {
        shared?: boolean;
        path?: string;
    }>, z.ZodObject<{
        directory: z.ZodString;
        shared: z.ZodOptional<z.ZodBoolean>;
    }, "strip", z.ZodTypeAny, {
        shared?: boolean;
        directory?: string;
    }, {
        shared?: boolean;
        directory?: string;
    }>]>, "many">>;
    plugins: z.ZodOptional<z.ZodArray<z.ZodString, "many">>;
    settings: z.ZodOptional<z.ZodRecord<z.ZodString, z.ZodUnion<[z.ZodString, z.ZodBoolean, z.ZodNumber, z.ZodAny]>>>;
    secrets: z.ZodOptional<z.ZodRecord<z.ZodString, z.ZodUnion<[z.ZodString, z.ZodBoolean, z.ZodNumber]>>>;
    style: z.ZodOptional<z.ZodObject<{
        all: z.ZodOptional<z.ZodArray<z.ZodString, "many">>;
        chat: z.ZodOptional<z.ZodArray<z.ZodString, "many">>;
        post: z.ZodOptional<z.ZodArray<z.ZodString, "many">>;
    }, "strip", z.ZodTypeAny, {
        post?: string[];
        all?: string[];
        chat?: string[];
    }, {
        post?: string[];
        all?: string[];
        chat?: string[];
    }>>;
}, "strict", z.ZodTypeAny, {
    knowledge?: (string | {
        shared?: boolean;
        directory?: string;
    } | {
        shared?: boolean;
        path?: string;
    })[];
    username?: string;
    name?: string;
    id?: string;
    system?: string;
    templates?: Record<string, string | ((...args: unknown[]) => unknown)>;
    bio?: string | string[];
    messageExamples?: {
        name?: string;
        content?: {
            thought?: string;
            text?: string;
            actions?: string[];
            providers?: string[];
            source?: string;
            target?: string;
            url?: string;
            inReplyTo?: string;
            attachments?: any[];
            channelType?: string;
        } & {
            [k: string]: unknown;
        };
    }[][];
    postExamples?: string[];
    topics?: string[];
    adjectives?: string[];
    plugins?: string[];
    settings?: Record<string, any>;
    secrets?: Record<string, string | number | boolean>;
    style?: {
        post?: string[];
        all?: string[];
        chat?: string[];
    };
}, {
    knowledge?: (string | {
        shared?: boolean;
        directory?: string;
    } | {
        shared?: boolean;
        path?: string;
    })[];
    username?: string;
    name?: string;
    id?: string;
    system?: string;
    templates?: Record<string, string | ((...args: unknown[]) => unknown)>;
    bio?: string | string[];
    messageExamples?: {
        name?: string;
        content?: {
            thought?: string;
            text?: string;
            actions?: string[];
            providers?: string[];
            source?: string;
            target?: string;
            url?: string;
            inReplyTo?: string;
            attachments?: any[];
            channelType?: string;
        } & {
            [k: string]: unknown;
        };
    }[][];
    postExamples?: string[];
    topics?: string[];
    adjectives?: string[];
    plugins?: string[];
    settings?: Record<string, any>;
    secrets?: Record<string, string | number | boolean>;
    style?: {
        post?: string[];
        all?: string[];
        chat?: string[];
    };
}>;
interface CharacterValidationResult {
    success: boolean;
    data?: Character;
    error?: {
        message: string;
        issues?: z.ZodIssue[];
    };
}
/**
 * Safely validates character data using Zod schema
 * @param data - Raw character data to validate
 * @returns Validation result with success flag and either data or error
 */
declare function validateCharacter(data: unknown): CharacterValidationResult;
/**
 * Safely parses JSON string and validates as character
 * @param jsonString - JSON string to parse and validate
 * @returns Validation result with success flag and either data or error
 */
declare function parseAndValidateCharacter(jsonString: string): CharacterValidationResult;
/**
 * Type guard to check if data is a valid Character
 * @param data - Data to check
 * @returns True if data is a valid Character
 */
declare function isValidCharacter(data: unknown): data is Character;

/**
 * Composes a set of example conversations based on provided actions and a specified count.
 * It randomly selects examples from the provided actions and formats them with generated names.
 *
 * @param actionsData - An array of `Action` objects from which to draw examples.
 * @param count - The number of examples to generate.
 * @returns A string containing formatted examples of conversations.
 */
declare const composeActionExamples: (actionsData: Action[], count: number) => string;
/**
 * Formats the names of the provided actions into a comma-separated string.
 * @param actions - An array of `Action` objects from which to extract names.
 * @returns A comma-separated string of action names.
 */
declare function formatActionNames(actions: Action[]): string;
/**
 * Formats the provided actions into a detailed string listing each action's name and description.
 * @param actions - An array of `Action` objects to format.
 * @returns A detailed string of actions, including names and descriptions.
 */
declare function formatActions(actions: Action[]): string;

/**
 * An abstract class representing a database adapter for managing various entities
 * like entities, memories, entities, goals, and rooms.
 */
/**
 * Database adapter class to be extended by individual database adapters.
 *
 * @template DB - The type of the database instance.
 * @abstract
 * implements IDatabaseAdapter
 */
declare abstract class DatabaseAdapter<DB = unknown> implements IDatabaseAdapter {
    /**
     * The database instance.
     */
    db: DB;
    /**
     * Initialize the database adapter.
     * @returns A Promise that resolves when initialization is complete.
     */
    abstract initialize(config?: any): Promise<void>;
    /**
     * Initialize the database adapter.
     * @returns A Promise that resolves when initialization is complete.
     */
    abstract init(): Promise<void>;
    /**
     * Run database migrations
     * @param migrationsPaths Optional array of paths to migration folders
     * @returns A Promise that resolves when migrations are complete.
     */
    abstract runMigrations(migrationsPaths?: string[]): Promise<void>;
    /**
     * Check if the database connection is ready.
     * @returns A Promise that resolves to true if the database is ready, false otherwise.
     */
    abstract isReady(): Promise<boolean>;
    /**
     * Optional close method for the database adapter.
     * @returns A Promise that resolves when closing is complete.
     */
    abstract close(): Promise<void>;
    /**
     * Retrieves a connection to the database.
     * @returns A Promise that resolves to the database connection.
     */
    abstract getConnection(): Promise<unknown>;
    /**
     * Retrieves an account by its ID.
     * @param entityIds The UUIDs of the user account to retrieve.
     * @returns A Promise that resolves to the Entity object or null if not found.
     */
    abstract getEntitiesByIds(entityIds: UUID[]): Promise<Entity[] | null>;
    abstract getEntitiesForRoom(roomId: UUID, includeComponents?: boolean): Promise<Entity[]>;
    /**
     * Creates a new entities in the database.
     * @param entities The entity objects to create.
     * @returns A Promise that resolves when the account creation is complete.
     */
    abstract createEntities(entities: Entity[]): Promise<boolean>;
    /**
     * Updates an existing entity in the database.
     * @param entity The entity object with updated properties.
     * @returns A Promise that resolves when the account update is complete.
     */
    abstract updateEntity(entity: Entity): Promise<void>;
    /**
     * Retrieves a single component by entity ID and type.
     * @param entityId The UUID of the entity the component belongs to
     * @param type The type identifier for the component
     * @param worldId Optional UUID of the world the component belongs to
     * @param sourceEntityId Optional UUID of the source entity
     * @returns Promise resolving to the Component if found, null otherwise
     */
    abstract getComponent(entityId: UUID, type: string, worldId?: UUID, sourceEntityId?: UUID): Promise<Component | null>;
    /**
     * Retrieves all components for an entity.
     * @param entityId The UUID of the entity to get components for
     * @param worldId Optional UUID of the world to filter components by
     * @param sourceEntityId Optional UUID of the source entity to filter by
     * @returns Promise resolving to array of Component objects
     */
    abstract getComponents(entityId: UUID, worldId?: UUID, sourceEntityId?: UUID): Promise<Component[]>;
    /**
     * Creates a new component in the database.
     * @param component The component object to create
     * @returns Promise resolving to true if creation was successful
     */
    abstract createComponent(component: Component): Promise<boolean>;
    /**
     * Updates an existing component in the database.
     * @param component The component object with updated properties
     * @returns Promise that resolves when the update is complete
     */
    abstract updateComponent(component: Component): Promise<void>;
    /**
     * Deletes a component from the database.
     * @param componentId The UUID of the component to delete
     * @returns Promise that resolves when the deletion is complete
     */
    abstract deleteComponent(componentId: UUID): Promise<void>;
    /**
     * Retrieves memories based on the specified parameters.
     * @param params An object containing parameters for the memory retrieval.
     * @returns A Promise that resolves to an array of Memory objects.
     */
    abstract getMemories(params: {
        entityId?: UUID;
        agentId?: UUID;
        count?: number;
        unique?: boolean;
        tableName: string;
        start?: number;
        end?: number;
        roomId?: UUID;
        worldId?: UUID;
    }): Promise<Memory[]>;
    abstract getMemoriesByRoomIds(params: {
        roomIds: UUID[];
        tableName: string;
        limit?: number;
    }): Promise<Memory[]>;
    abstract getMemoryById(id: UUID): Promise<Memory | null>;
    /**
     * Retrieves multiple memories by their IDs
     * @param memoryIds Array of UUIDs of the memories to retrieve
     * @param tableName Optional table name to filter memories by type
     * @returns Promise resolving to array of Memory objects
     */
    abstract getMemoriesByIds(memoryIds: UUID[], tableName?: string): Promise<Memory[]>;
    /**
     * Retrieves cached embeddings based on the specified query parameters.
     * @param params An object containing parameters for the embedding retrieval.
     * @returns A Promise that resolves to an array of objects containing embeddings and levenshtein scores.
     */
    abstract getCachedEmbeddings({ query_table_name, query_threshold, query_input, query_field_name, query_field_sub_name, query_match_count, }: {
        query_table_name: string;
        query_threshold: number;
        query_input: string;
        query_field_name: string;
        query_field_sub_name: string;
        query_match_count: number;
    }): Promise<{
        embedding: number[];
        levenshtein_score: number;
    }[]>;
    /**
     * Logs an event or action with the specified details.
     * @param params An object containing parameters for the log entry.
     * @returns A Promise that resolves when the log entry has been saved.
     */
    abstract log(params: {
        body: {
            [key: string]: unknown;
        };
        entityId: UUID;
        roomId: UUID;
        type: string;
    }): Promise<void>;
    /**
     * Retrieves logs based on the specified parameters.
     * @param params An object containing parameters for the log retrieval.
     * @returns A Promise that resolves to an array of Log objects.
     */
    abstract getLogs(params: {
        entityId: UUID;
        roomId?: UUID;
        type?: string;
        count?: number;
        offset?: number;
    }): Promise<Log[]>;
    /**
     * Deletes a log from the database.
     * @param logId The UUID of the log to delete.
     * @returns A Promise that resolves when the log has been deleted.
     */
    abstract deleteLog(logId: UUID): Promise<void>;
    /**
     * Searches for memories based on embeddings and other specified parameters.
     * @param params An object containing parameters for the memory search.
     * @returns A Promise that resolves to an array of Memory objects.
     */
    abstract searchMemories(params: {
        tableName: string;
        embedding: number[];
        match_threshold?: number;
        count?: number;
        unique?: boolean;
        query?: string;
        roomId?: UUID;
        worldId?: UUID;
        entityId?: UUID;
    }): Promise<Memory[]>;
    /**
     * Creates a new memory in the database.
     * @param memory The memory object to create.
     * @param tableName The table where the memory should be stored.
     * @param unique Indicates if the memory should be unique.
     * @returns A Promise that resolves when the memory has been created.
     */
    abstract createMemory(memory: Memory, tableName: string, unique?: boolean): Promise<UUID>;
    /**
     * Updates an existing memory in the database.
     * @param memory The memory object with updated content and optional embedding
     * @returns Promise resolving to boolean indicating success
     */
    abstract updateMemory(memory: Partial<Memory> & {
        id: UUID;
        metadata?: MemoryMetadata;
    }): Promise<boolean>;
    /**
     * Removes a specific memory from the database.
     * @param memoryId The UUID of the memory to remove.
     * @returns A Promise that resolves when the memory has been removed.
     */
    abstract deleteMemory(memoryId: UUID): Promise<void>;
    /**
     * Removes multiple memories from the database in a single batch operation.
     * @param memoryIds An array of UUIDs of the memories to remove.
     * @returns A Promise that resolves when all memories have been removed.
     */
    abstract deleteManyMemories(memoryIds: UUID[]): Promise<void>;
    /**
     * Removes all memories associated with a specific room.
     * @param roomId The UUID of the room whose memories should be removed.
     * @param tableName The table from which the memories should be removed.
     * @returns A Promise that resolves when all memories have been removed.
     */
    abstract deleteAllMemories(roomId: UUID, tableName: string): Promise<void>;
    /**
     * Counts the number of memories in a specific room.
     * @param roomId The UUID of the room for which to count memories.
     * @param unique Specifies whether to count only unique memories.
     * @param tableName Optional table name to count memories from.
     * @returns A Promise that resolves to the number of memories.
     */
    abstract countMemories(roomId: UUID, unique?: boolean, tableName?: string): Promise<number>;
    /**
     * Retrieves a world by its ID.
     * @param id The UUID of the world to retrieve.
     * @returns A Promise that resolves to the World object or null if not found.
     */
    abstract getWorld(id: UUID): Promise<World | null>;
    /**
     * Retrieves all worlds for an agent.
     * @returns A Promise that resolves to an array of World objects.
     */
    abstract getAllWorlds(): Promise<World[]>;
    /**
     * Creates a new world in the database.
     * @param world The world object to create.
     * @returns A Promise that resolves to the UUID of the created world.
     */
    abstract createWorld(world: World): Promise<UUID>;
    /**
     * Updates an existing world in the database.
     * @param world The world object with updated properties.
     * @returns A Promise that resolves when the world has been updated.
     */
    abstract updateWorld(world: World): Promise<void>;
    /**
     * Removes a specific world from the database.
     * @param id The UUID of the world to remove.
     * @returns A Promise that resolves when the world has been removed.
     */
    abstract removeWorld(id: UUID): Promise<void>;
    /**
     * Retrieves the room ID for a given room, if it exists.
     * @param roomIds The UUIDs of the rooms to retrieve.
     * @returns A Promise that resolves to the room ID or null if not found.
     */
    abstract getRoomsByIds(roomIds: UUID[]): Promise<Room[] | null>;
    /**
     * Retrieves all rooms for a given world.
     * @param worldId The UUID of the world to retrieve rooms for.
     * @returns A Promise that resolves to an array of Room objects.
     */
    abstract getRoomsByWorld(worldId: UUID): Promise<Room[]>;
    /**
     * Creates new rooms in the database.
     * @param rooms Array of Room objects to create.
     * @returns A Promise that resolves to the UUIDs of the created rooms.
     */
    abstract createRooms(rooms: Room[]): Promise<UUID[]>;
    /**
     * Updates a specific room in the database.
     * @param room The room object with updated properties.
     * @returns A Promise that resolves when the room has been updated.
     */
    abstract updateRoom(room: Room): Promise<void>;
    /**
     * Removes a specific room from the database.
     * @param roomId The UUID of the room to remove.
     * @returns A Promise that resolves when the room has been removed.
     */
    abstract deleteRoom(roomId: UUID): Promise<void>;
    /**
     * Retrieves room IDs for which a specific user is a participant.
     * @param entityId The UUID of the user.
     * @returns A Promise that resolves to an array of room IDs.
     */
    abstract getRoomsForParticipant(entityId: UUID): Promise<UUID[]>;
    /**
     * Retrieves room IDs for which specific users are participants.
     * @param userIds An array of UUIDs of the users.
     * @returns A Promise that resolves to an array of room IDs.
     */
    abstract getRoomsForParticipants(userIds: UUID[]): Promise<UUID[]>;
    /**
     * Adds users as a participant to a specific room.
     * @param entityIds The UUIDs of the users to add as a participant.
     * @param roomId The UUID of the room to which the user will be added.
     * @returns A Promise that resolves to a boolean indicating success or failure.
     */
    abstract addParticipantsRoom(entityIds: UUID[], roomId: UUID): Promise<boolean>;
    /**
     * Removes a user as a participant from a specific room.
     * @param entityId The UUID of the user to remove as a participant.
     * @param roomId The UUID of the room from which the user will be removed.
     * @returns A Promise that resolves to a boolean indicating success or failure.
     */
    abstract removeParticipant(entityId: UUID, roomId: UUID): Promise<boolean>;
    /**
     * Retrieves participants associated with a specific account.
     * @param entityId The UUID of the account.
     * @returns A Promise that resolves to an array of Participant objects.
     */
    abstract getParticipantsForEntity(entityId: UUID): Promise<Participant[]>;
    /**
     * Retrieves participants for a specific room.
     * @param roomId The UUID of the room for which to retrieve participants.
     * @returns A Promise that resolves to an array of UUIDs representing the participants.
     */
    abstract getParticipantsForRoom(roomId: UUID): Promise<UUID[]>;
    abstract getParticipantUserState(roomId: UUID, entityId: UUID): Promise<'FOLLOWED' | 'MUTED' | null>;
    abstract setParticipantUserState(roomId: UUID, entityId: UUID, state: 'FOLLOWED' | 'MUTED' | null): Promise<void>;
    /**
     * Creates a new relationship between two users.
     * @param params Object containing the relationship details including entity IDs, agent ID, optional tags and metadata
     * @returns A Promise that resolves to a boolean indicating success or failure of the creation.
     */
    abstract createRelationship(params: {
        sourceEntityId: UUID;
        targetEntityId: UUID;
        tags?: string[];
        metadata?: Record<string, unknown>;
    }): Promise<boolean>;
    /**
     * Retrieves a relationship between two users if it exists.
     * @param params Object containing the entity IDs and agent ID
     * @returns A Promise that resolves to the Relationship object or null if not found.
     */
    abstract getRelationship(params: {
        sourceEntityId: UUID;
        targetEntityId: UUID;
    }): Promise<Relationship | null>;
    /**
     * Retrieves all relationships for a specific user.
     * @param params Object containing the user ID, agent ID and optional tags to filter by
     * @returns A Promise that resolves to an array of Relationship objects.
     */
    abstract getRelationships(params: {
        entityId: UUID;
        tags?: string[];
    }): Promise<Relationship[]>;
    /**
     * Updates an existing relationship between two users.
     * @param params Object containing the relationship details to update including entity IDs, agent ID, optional tags and metadata
     * @returns A Promise that resolves to a boolean indicating success or failure of the update.
     */
    abstract updateRelationship(params: {
        sourceEntityId: UUID;
        targetEntityId: UUID;
        tags?: string[];
        metadata?: Record<string, unknown>;
    }): Promise<void>;
    /**
     * Retrieves an agent by its ID.
     * @param agentId The UUID of the agent to retrieve.
     * @returns A Promise that resolves to the Agent object or null if not found.
     */
    abstract getAgent(agentId: UUID): Promise<Agent | null>;
    /**
     * Retrieves all agents from the database.
     * @returns A Promise that resolves to an array of Agent objects.
     */
    abstract getAgents(): Promise<Partial<Agent>[]>;
    /**
     * Creates a new agent in the database.
     * @param agent The agent object to create.
     * @returns A Promise that resolves to a boolean indicating success or failure of the creation.
     */
    abstract createAgent(agent: Partial<Agent>): Promise<boolean>;
    /**
     * Updates an existing agent in the database.
     * @param agentId The UUID of the agent to update.
     * @param agent The agent object with updated properties.
     * @returns A Promise that resolves to a boolean indicating success or failure of the update.
     */
    abstract updateAgent(agentId: UUID, agent: Partial<Agent>): Promise<boolean>;
    /**
     * Deletes an agent from the database.
     * @param agentId The UUID of the agent to delete.
     * @returns A Promise that resolves to a boolean indicating success or failure of the deletion.
     */
    abstract deleteAgent(agentId: UUID): Promise<boolean>;
    /**
     * Ensures an embedding dimension exists in the database.
     * @param dimension The dimension to ensure exists.
     * @returns A Promise that resolves when the embedding dimension has been ensured to exist.
     */
    abstract ensureEmbeddingDimension(dimension: number): Promise<void>;
    /**
     * Retrieves a cached value by key from the database.
     * @param key The key to look up in the cache
     * @returns Promise resolving to the cached string value
     */
    abstract getCache<T>(key: string): Promise<T | undefined>;
    /**
     * Sets a value in the cache with the given key.
     * @param key The key to store the value under
     * @param value The value to cache
     * @returns Promise resolving to true if the cache was set successfully
     */
    abstract setCache<T>(key: string, value: T): Promise<boolean>;
    /**
     * Deletes a value from the cache by key.
     * @param key The key to delete from the cache
     * @returns Promise resolving to true if the value was successfully deleted
     */
    abstract deleteCache(key: string): Promise<boolean>;
    /**
     * Creates a new task instance in the database.
     * @param task The task object to create
     * @returns Promise resolving to the UUID of the created task
     */
    abstract createTask(task: Task): Promise<UUID>;
    /**
     * Retrieves tasks based on specified parameters.
     * @param params Object containing optional roomId and tags to filter tasks
     * @returns Promise resolving to an array of Task objects
     */
    abstract getTasks(params: {
        roomId?: UUID;
        tags?: string[];
        entityId?: UUID;
    }): Promise<Task[]>;
    /**
     * Retrieves a specific task by its ID.
     * @param id The UUID of the task to retrieve
     * @returns Promise resolving to the Task object if found, null otherwise
     */
    abstract getTask(id: UUID): Promise<Task | null>;
    /**
     * Retrieves a specific task by its name.
     * @param name The name of the task to retrieve
     * @returns Promise resolving to the Task object if found, null otherwise
     */
    abstract getTasksByName(name: string): Promise<Task[]>;
    /**
     * Updates an existing task in the database.
     * @param id The UUID of the task to update
     * @param task Partial Task object containing the fields to update
     * @returns Promise resolving when the update is complete
     */
    abstract updateTask(id: UUID, task: Partial<Task>): Promise<void>;
    /**
     * Deletes a task from the database.
     * @param id The UUID of the task to delete
     * @returns Promise resolving when the deletion is complete
     */
    abstract deleteTask(id: UUID): Promise<void>;
    abstract getMemoriesByWorldId(params: {
        worldId: UUID;
        count?: number;
        tableName?: string;
    }): Promise<Memory[]>;
    abstract deleteRoomsByWorldId(worldId: UUID): Promise<void>;
}

/**
 * Finds an entity by name in the given runtime environment.
 *
 * @param {IAgentRuntime} runtime - The agent runtime environment.
 * @param {Memory} message - The memory message containing relevant information.
 * @param {State} state - The current state of the system.
 * @returns {Promise<Entity | null>} A promise that resolves to the found entity or null if not found.
 */
declare function findEntityByName(runtime: IAgentRuntime, message: Memory, state: State): Promise<Entity | null>;
/**
 * Function to create a unique UUID based on the runtime and base user ID.
 *
 * @param {RuntimeContext} runtime - The runtime context object.
 * @param {UUID|string} baseUserId - The base user ID to use in generating the UUID.
 * @returns {UUID} - The unique UUID generated based on the runtime and base user ID.
 */
declare const createUniqueUuid: (runtime: any, baseUserId: UUID | string) => UUID;
/**
 * Get details for a list of entities.
 */
/**
 * Retrieves entity details for a specific room from the database.
 *
 * @param {Object} params - The input parameters
 * @param {IAgentRuntime} params.runtime - The Agent Runtime instance
 * @param {UUID} params.roomId - The ID of the room to retrieve entity details for
 * @returns {Promise<Array>} - A promise that resolves to an array of unique entity details
 */
declare function getEntityDetails({ runtime, roomId, }: {
    runtime: IAgentRuntime;
    roomId: UUID;
}): Promise<any[]>;
/**
 * Format entities into a string
 * @param entities - list of entities
 * @returns string
 */
/**
 * Format the given entities into a string representation.
 *
 * @param {Object} options - The options object.
 * @param {Entity[]} options.entities - The list of entities to format.
 * @returns {string} A formatted string representing the entities.
 */
declare function formatEntities({ entities }: {
    entities: Entity[];
}): string;

declare const createLogger: (bindings?: any | boolean) => pino.Logger<never, boolean>;
declare let logger: pino.Logger<string, boolean>;

declare const elizaLogger: pino.Logger<string, boolean>;

declare const shouldRespondTemplate = "<task>Decide on behalf of {{agentName}} whether they should respond to the message, ignore it or stop the conversation.</task>\n\n<providers>\n{{providers}}\n</providers>\n\n<instructions>Decide if {{agentName}} should respond to or interact with the conversation.\nIf the message is directed at or relevant to {{agentName}}, respond with RESPOND action.\nIf a user asks {{agentName}} to be quiet, respond with STOP action.\nIf {{agentName}} should ignore the message, respond with IGNORE action.</instructions>\n\n<output>\nDo NOT include any thinking, reasoning, or <think> sections in your response. \nGo directly to the XML response format without any preamble or explanation.\n\nRespond using XML format like this:\n<response>\n  <name>{{agentName}}</name>\n  <reasoning>Your reasoning here</reasoning>\n  <action>RESPOND | IGNORE | STOP</action>\n</response>\n\nIMPORTANT: Your response must ONLY contain the <response></response> XML block above. Do not include any text, thinking, or reasoning before or after this XML block. Start your response immediately with <response> and end with </response>.\n</output>";
declare const messageHandlerTemplate = "<task>Generate dialog and actions for the character {{agentName}}.</task>\n\n<providers>\n{{providers}}\n</providers>\n\nThese are the available valid actions:\n<actionNames>\n{{actionNames}}\n</actionNames>\n\n<instructions>\nWrite a thought and plan for {{agentName}} and decide what actions to take. Also include the providers that {{agentName}} will use to have the right context for responding and acting, if any.\n\nIMPORTANT ACTION ORDERING RULES:\n- Actions are executed in the ORDER you list them - the order MATTERS!\n- REPLY should come FIRST to acknowledge the user's request before executing other actions\n- Common patterns:\n  - For requests requiring tool use: REPLY,CALL_MCP_TOOL (acknowledge first, then gather info)\n  - For task execution: REPLY,SEND_MESSAGE or REPLY,EVM_SWAP_TOKENS (acknowledge first, then do the task)\n  - For multi-step operations: REPLY,ACTION1,ACTION2 (acknowledge first, then complete all steps)\n- REPLY is used to acknowledge and inform the user about what you're going to do\n- Follow-up actions execute the actual tasks after acknowledgment\n- Use IGNORE only when you should not respond at all\n- If you use IGNORE, do not include any other actions. IGNORE should be used alone when you should not respond or take any actions.\n\nIMPORTANT PROVIDER SELECTION RULES:\n- Only include providers if they are needed to respond accurately.\n- If the message mentions images, photos, pictures, attachments, or visual content, OR if you see \"(Attachments:\" in the conversation, you MUST include \"ATTACHMENTS\" in your providers list\n- If the message asks about or references specific people, include \"ENTITIES\" in your providers list  \n- If the message asks about relationships or connections between people, include \"RELATIONSHIPS\" in your providers list\n- If the message asks about facts or specific information, include \"FACTS\" in your providers list\n- If the message asks about the environment or world context, include \"WORLD\" in your providers list\n- If no additional context is needed, you may leave the providers list empty.\n\nIMPORTANT CODE BLOCK FORMATTING RULES:\n- If {{agentName}} includes code examples, snippets, or multi-line code in the response, ALWAYS wrap the code with ``` fenced code blocks (specify the language if known, e.g., ```python).\n- ONLY use fenced code blocks for actual code. Do NOT wrap non-code text, instructions, or single words in fenced code blocks.\n- If including inline code (short single words or function names), use single backticks (`) as appropriate.\n- This ensures the user sees clearly formatted and copyable code when relevant.\n\nFirst, think about what you want to do next and plan your actions. Then, write the next message and include the actions you plan to take.\n</instructions>\n\n<keys>\n\"thought\" should be a short description of what the agent is thinking about and planning.\n\"actions\" should be a comma-separated list of the actions {{agentName}} plans to take based on the thought, IN THE ORDER THEY SHOULD BE EXECUTED (if none, use IGNORE, if simply responding with text, use REPLY)\n\"providers\" should be a comma-separated list of the providers that {{agentName}} will use to have the right context for responding and acting (NEVER use \"IGNORE\" as a provider - use specific provider names like ATTACHMENTS, ENTITIES, FACTS, KNOWLEDGE, etc.)\n\"text\" should be the text of the next message for {{agentName}} which they will send to the conversation.\n</keys>\n\n<output>\nDo NOT include any thinking, reasoning, or <think> sections in your response. \nGo directly to the XML response format without any preamble or explanation.\n\nRespond using XML format like this:\n<response>\n    <thought>Your thought here</thought>\n    <actions>ACTION1,ACTION2</actions>\n    <providers>PROVIDER1,PROVIDER2</providers>\n    <text>Your response text here</text>\n</response>\n\nIMPORTANT: Your response must ONLY contain the <response></response> XML block above. Do not include any text, thinking, or reasoning before or after this XML block. Start your response immediately with <response> and end with </response>.\n</output>";
declare const postCreationTemplate = "# Task: Create a post in the voice and style and perspective of {{agentName}} @{{twitterUserName}}.\n\nExample task outputs:\n1. A post about the importance of AI in our lives\n<response>\n  <thought>I am thinking about writing a post about the importance of AI in our lives</thought>\n  <post>AI is changing the world and it is important to understand how it works</post>\n  <imagePrompt>A futuristic cityscape with flying cars and people using AI to do things</imagePrompt>\n</response>\n\n2. A post about dogs\n<response>\n  <thought>I am thinking about writing a post about dogs</thought>\n  <post>Dogs are man's best friend and they are loyal and loving</post>\n  <imagePrompt>A dog playing with a ball in a park</imagePrompt>\n</response>\n\n3. A post about finding a new job\n<response>\n  <thought>Getting a job is hard, I bet there's a good tweet in that</thought>\n  <post>Just keep going!</post>\n  <imagePrompt>A person looking at a computer screen with a job search website</imagePrompt>\n</response>\n\n{{providers}}\n\nWrite a post that is {{adjective}} about {{topic}} (without mentioning {{topic}} directly), from the perspective of {{agentName}}. Do not add commentary or acknowledge this request, just write the post.\nYour response should be 1, 2, or 3 sentences (choose the length at random).\nYour response should not contain any questions. Brief, concise statements only. The total character count MUST be less than 280. No emojis. Use \\n\\n (double spaces) between statements if there are multiple statements in your response.\n\nYour output should be formatted in XML like this:\n<response>\n  <thought>Your thought here</thought>\n  <post>Your post text here</post>\n  <imagePrompt>Optional image prompt here</imagePrompt>\n</response>\n\nThe \"post\" field should be the post you want to send. Do not including any thinking or internal reflection in the \"post\" field.\nThe \"imagePrompt\" field is optional and should be a prompt for an image that is relevant to the post. It should be a single sentence that captures the essence of the post. ONLY USE THIS FIELD if it makes sense that the post would benefit from an image.\nThe \"thought\" field should be a short description of what the agent is thinking about before responding, including a brief justification for the response. Includate an explanation how the post is relevant to the topic but unique and different than other posts.\n\nDo NOT include any thinking, reasoning, or <think> sections in your response. \nGo directly to the XML response format without any preamble or explanation.\n\nIMPORTANT: Your response must ONLY contain the <response></response> XML block above. Do not include any text, thinking, or reasoning before or after this XML block. Start your response immediately with <response> and end with </response>.";
declare const booleanFooter = "Respond with only a YES or a NO.";
declare const imageDescriptionTemplate = "<task>Analyze the provided image and generate a comprehensive description with multiple levels of detail.</task>\n\n<instructions>\nCarefully examine the image and provide:\n1. A concise, descriptive title that captures the main subject or scene\n2. A brief summary description (1-2 sentences) highlighting the key elements\n3. An extensive, detailed description that covers all visible elements, composition, lighting, colors, mood, and any other relevant details\n\nBe objective and descriptive. Focus on what you can actually see in the image rather than making assumptions about context or meaning.\n</instructions>\n\n<output>\nDo NOT include any thinking, reasoning, or <think> sections in your response. \nGo directly to the XML response format without any preamble or explanation.\n\nRespond using XML format like this:\n<response>\n  <title>A concise, descriptive title for the image</title>\n  <description>A brief 1-2 sentence summary of the key elements in the image</description>\n  <text>An extensive, detailed description covering all visible elements, composition, lighting, colors, mood, setting, objects, people, activities, and any other relevant details you can observe in the image</text>\n</response>\n\nIMPORTANT: Your response must ONLY contain the <response></response> XML block above. Do not include any text, thinking, or reasoning before or after this XML block. Start your response immediately with <response> and end with </response>.\n</output>";

/**
 * Represents the state of server ownership, including a mapping of server IDs to their respective World objects.
 */
/**
 * Interface representing the ownership state of servers.
 * @property {Object.<string, World>} servers - The servers and their corresponding worlds, where the key is the server ID and the value is the World object.
 */
interface ServerOwnershipState {
    servers: {
        [serverId: string]: World;
    };
}
/**
 * Gets a user's role from world metadata
 */
/**
 * Retrieve the server role of a specified user entity within a given server.
 *
 * @param {IAgentRuntime} runtime - The runtime object containing necessary configurations and services.
 * @param {string} entityId - The unique identifier of the user entity.
 * @param {string} serverId - The unique identifier of the server.
 * @returns {Promise<Role>} The role of the user entity within the server, resolved as a Promise.
 */
declare function getUserServerRole(runtime: IAgentRuntime, entityId: string, serverId: string): Promise<Role>;
/**
 * Finds a server where the given user is the owner
 */
declare function findWorldsForOwner(runtime: IAgentRuntime, entityId: string): Promise<World[] | null>;

declare class Semaphore {
    private permits;
    private waiting;
    constructor(count: number);
    acquire(): Promise<void>;
    release(): void;
}
declare class AgentRuntime implements IAgentRuntime {
    #private;
    readonly agentId: UUID;
    readonly character: Character;
    adapter: IDatabaseAdapter;
    readonly actions: Action[];
    readonly evaluators: Evaluator[];
    readonly providers: Provider[];
    readonly plugins: Plugin[];
    private isInitialized;
    events: Map<string, ((params: any) => Promise<void>)[]>;
    stateCache: Map<`${string}-${string}-${string}-${string}-${string}`, {
        values: {
            [key: string]: any;
        };
        data: {
            [key: string]: any;
        };
        text: string;
    }>;
    readonly fetch: typeof fetch;
    services: Map<ServiceTypeName, Service[]>;
    private serviceTypes;
    models: Map<string, ModelHandler[]>;
    routes: Route[];
    private taskWorkers;
    private sendHandlers;
    private eventHandlers;
    private allAvailablePlugins;
    private characterPlugins;
    logger: any;
    private settings;
    private servicesInitQueue;
    private currentRunId?;
    private currentActionContext?;
    private maxWorkingMemoryEntries;
    constructor(opts: {
        conversationLength?: number;
        agentId?: UUID;
        character?: Character;
        plugins?: Plugin[];
        fetch?: typeof fetch;
        adapter?: IDatabaseAdapter;
        settings?: RuntimeSettings;
        events?: {
            [key: string]: ((params: any) => void)[];
        };
        allAvailablePlugins?: Plugin[];
    });
    /**
     * Create a new run ID for tracking a sequence of model calls
     */
    createRunId(): UUID;
    /**
     * Start a new run for tracking prompts
     */
    startRun(): UUID;
    /**
     * End the current run
     */
    endRun(): void;
    /**
     * Get the current run ID (creates one if it doesn't exist)
     */
    getCurrentRunId(): UUID;
    registerPlugin(plugin: Plugin): Promise<void>;
    getAllServices(): Map<ServiceTypeName, Service[]>;
    stop(): Promise<void>;
    initialize(): Promise<void>;
    runPluginMigrations(): Promise<void>;
    getConnection(): Promise<unknown>;
    setSetting(key: string, value: string | boolean | null | any, secret?: boolean): void;
    getSetting(key: string): string | boolean | null | any;
    getConversationLength(): number;
    registerDatabaseAdapter(adapter: IDatabaseAdapter): void;
    registerProvider(provider: Provider): void;
    registerAction(action: Action): void;
    registerEvaluator(evaluator: Evaluator): void;
    private updateActionPlan;
    private updateActionStep;
    processActions(message: Memory, responses: Memory[], state?: State, callback?: HandlerCallback): Promise<void>;
    evaluate(message: Memory, state: State, didRespond?: boolean, callback?: HandlerCallback, responses?: Memory[]): Promise<Evaluator[]>;
    ensureConnections(entities: any, rooms: any, source: any, world: any): Promise<void>;
    ensureConnection({ entityId, roomId, worldId, worldName, userName, name, source, type, channelId, serverId, userId, metadata, }: {
        entityId: UUID;
        roomId: UUID;
        worldId: UUID;
        worldName?: string;
        userName?: string;
        name?: string;
        source?: string;
        type?: ChannelType;
        channelId?: string;
        serverId?: string;
        userId?: UUID;
        metadata?: Record<string, any>;
    }): Promise<void>;
    ensureParticipantInRoom(entityId: UUID, roomId: UUID): Promise<void>;
    removeParticipant(entityId: UUID, roomId: UUID): Promise<boolean>;
    getParticipantsForEntity(entityId: UUID): Promise<Participant[]>;
    getParticipantsForRoom(roomId: UUID): Promise<UUID[]>;
    addParticipant(entityId: UUID, roomId: UUID): Promise<boolean>;
    addParticipantsRoom(entityIds: UUID[], roomId: UUID): Promise<boolean>;
    /**
     * Ensure the existence of a world.
     */
    ensureWorldExists({ id, name, serverId, metadata }: World): Promise<void>;
    ensureRoomExists({ id, name, source, type, channelId, serverId, worldId, metadata }: Room): Promise<void>;
    composeState(message: Memory, includeList?: string[] | null, onlyInclude?: boolean, skipCache?: boolean): Promise<State>;
    getService<T extends Service = Service>(serviceName: ServiceTypeName | string): T | null;
    /**
     * Type-safe service getter that ensures the correct service type is returned
     * @template T - The expected service class type
     * @param serviceName - The service type name
     * @returns The service instance with proper typing, or null if not found
     */
    getTypedService<T extends Service = Service>(serviceName: ServiceTypeName | string): T | null;
    /**
     * Get all services of a specific type
     * @template T - The expected service class type
     * @param serviceName - The service type name
     * @returns Array of service instances with proper typing
     */
    getServicesByType<T extends Service = Service>(serviceName: ServiceTypeName | string): T[];
    /**
     * Get all registered service types
     * @returns Array of registered service type names
     */
    getRegisteredServiceTypes(): ServiceTypeName[];
    /**
     * Check if a service type is registered
     * @param serviceType - The service type to check
     * @returns true if the service is registered
     */
    hasService(serviceType: ServiceTypeName | string): boolean;
    registerService(serviceDef: typeof Service): Promise<void>;
    registerModel(modelType: ModelTypeName, handler: (params: any) => Promise<any>, provider: string, priority?: number): void;
    getModel(modelType: ModelTypeName, provider?: string): ((runtime: IAgentRuntime, params: any) => Promise<any>) | undefined;
    /**
     * Retrieves model configuration settings from character settings with support for
     * model-specific overrides and default fallbacks.
     *
     * Precedence order (highest to lowest):
     * 1. Model-specific settings (e.g., TEXT_SMALL_TEMPERATURE)
     * 2. Default settings (e.g., DEFAULT_TEMPERATURE)
     * 3. Legacy settings for backwards compatibility (e.g., MODEL_TEMPERATURE)
     *
     * @param modelType The specific model type to get settings for
     * @returns Object containing model parameters if they exist, or null if no settings are configured
     */
    private getModelSettings;
    useModel<T extends ModelTypeName, R = ModelResultMap[T]>(modelType: T, params: Omit<ModelParamsMap[T], 'runtime'> | any, provider?: string): Promise<R>;
    registerEvent(event: string, handler: (params: any) => Promise<void>): void;
    getEvent(event: string): ((params: any) => Promise<void>)[] | undefined;
    emitEvent(event: string | string[], params: any): Promise<void>;
    ensureEmbeddingDimension(): Promise<void>;
    registerTaskWorker(taskHandler: TaskWorker): void;
    getTaskWorker(name: string): TaskWorker | undefined;
    get db(): any;
    init(): Promise<void>;
    close(): Promise<void>;
    getAgent(agentId: UUID): Promise<Agent | null>;
    getAgents(): Promise<Partial<Agent>[]>;
    createAgent(agent: Partial<Agent>): Promise<boolean>;
    updateAgent(agentId: UUID, agent: Partial<Agent>): Promise<boolean>;
    deleteAgent(agentId: UUID): Promise<boolean>;
    ensureAgentExists(agent: Partial<Agent>): Promise<Agent>;
    getEntityById(entityId: UUID): Promise<Entity | null>;
    getEntitiesByIds(entityIds: UUID[]): Promise<Entity[] | null>;
    getEntitiesForRoom(roomId: UUID, includeComponents?: boolean): Promise<Entity[]>;
    createEntity(entity: Entity): Promise<boolean>;
    createEntities(entities: Entity[]): Promise<boolean>;
    updateEntity(entity: Entity): Promise<void>;
    getComponent(entityId: UUID, type: string, worldId?: UUID, sourceEntityId?: UUID): Promise<Component | null>;
    getComponents(entityId: UUID, worldId?: UUID, sourceEntityId?: UUID): Promise<Component[]>;
    createComponent(component: Component): Promise<boolean>;
    updateComponent(component: Component): Promise<void>;
    deleteComponent(componentId: UUID): Promise<void>;
    addEmbeddingToMemory(memory: Memory): Promise<Memory>;
    getMemories(params: {
        entityId?: UUID;
        agentId?: UUID;
        roomId?: UUID;
        count?: number;
        unique?: boolean;
        tableName: string;
        start?: number;
        end?: number;
    }): Promise<Memory[]>;
    getAllMemories(): Promise<Memory[]>;
    getMemoryById(id: UUID): Promise<Memory | null>;
    getMemoriesByIds(ids: UUID[], tableName?: string): Promise<Memory[]>;
    getMemoriesByRoomIds(params: {
        tableName: string;
        roomIds: UUID[];
        limit?: number;
    }): Promise<Memory[]>;
    getCachedEmbeddings(params: {
        query_table_name: string;
        query_threshold: number;
        query_input: string;
        query_field_name: string;
        query_field_sub_name: string;
        query_match_count: number;
    }): Promise<{
        embedding: number[];
        levenshtein_score: number;
    }[]>;
    log(params: {
        body: {
            [key: string]: unknown;
        };
        entityId: UUID;
        roomId: UUID;
        type: string;
    }): Promise<void>;
    searchMemories(params: {
        embedding: number[];
        query?: string;
        match_threshold?: number;
        count?: number;
        roomId?: UUID;
        unique?: boolean;
        worldId?: UUID;
        entityId?: UUID;
        tableName: string;
    }): Promise<Memory[]>;
    rerankMemories(query: string, memories: Memory[]): Promise<Memory[]>;
    createMemory(memory: Memory, tableName: string, unique?: boolean): Promise<UUID>;
    updateMemory(memory: Partial<Memory> & {
        id: UUID;
        metadata?: MemoryMetadata;
    }): Promise<boolean>;
    deleteMemory(memoryId: UUID): Promise<void>;
    deleteManyMemories(memoryIds: UUID[]): Promise<void>;
    clearAllAgentMemories(): Promise<void>;
    deleteAllMemories(roomId: UUID, tableName: string): Promise<void>;
    countMemories(roomId: UUID, unique?: boolean, tableName?: string): Promise<number>;
    getLogs(params: {
        entityId: UUID;
        roomId?: UUID;
        type?: string;
        count?: number;
        offset?: number;
    }): Promise<Log[]>;
    deleteLog(logId: UUID): Promise<void>;
    createWorld(world: World): Promise<UUID>;
    getWorld(id: UUID): Promise<World | null>;
    removeWorld(worldId: UUID): Promise<void>;
    getAllWorlds(): Promise<World[]>;
    updateWorld(world: World): Promise<void>;
    getRoom(roomId: UUID): Promise<Room | null>;
    getRoomsByIds(roomIds: UUID[]): Promise<Room[] | null>;
    createRoom({ id, name, source, type, channelId, serverId, worldId }: Room): Promise<UUID>;
    createRooms(rooms: Room[]): Promise<UUID[]>;
    deleteRoom(roomId: UUID): Promise<void>;
    deleteRoomsByWorldId(worldId: UUID): Promise<void>;
    updateRoom(room: Room): Promise<void>;
    getRoomsForParticipant(entityId: UUID): Promise<UUID[]>;
    getRoomsForParticipants(userIds: UUID[]): Promise<UUID[]>;
    getRooms(worldId: UUID): Promise<Room[]>;
    getRoomsByWorld(worldId: UUID): Promise<Room[]>;
    getParticipantUserState(roomId: UUID, entityId: UUID): Promise<'FOLLOWED' | 'MUTED' | null>;
    setParticipantUserState(roomId: UUID, entityId: UUID, state: 'FOLLOWED' | 'MUTED' | null): Promise<void>;
    createRelationship(params: {
        sourceEntityId: UUID;
        targetEntityId: UUID;
        tags?: string[];
        metadata?: {
            [key: string]: any;
        };
    }): Promise<boolean>;
    updateRelationship(relationship: Relationship): Promise<void>;
    getRelationship(params: {
        sourceEntityId: UUID;
        targetEntityId: UUID;
    }): Promise<Relationship | null>;
    getRelationships(params: {
        entityId: UUID;
        tags?: string[];
    }): Promise<Relationship[]>;
    getCache<T>(key: string): Promise<T | undefined>;
    setCache<T>(key: string, value: T): Promise<boolean>;
    deleteCache(key: string): Promise<boolean>;
    createTask(task: Task): Promise<UUID>;
    getTasks(params: {
        roomId?: UUID;
        tags?: string[];
        entityId?: UUID;
    }): Promise<Task[]>;
    getTask(id: UUID): Promise<Task | null>;
    getTasksByName(name: string): Promise<Task[]>;
    updateTask(id: UUID, task: Partial<Task>): Promise<void>;
    deleteTask(id: UUID): Promise<void>;
    on(event: string, callback: (data: any) => void): void;
    off(event: string, callback: (data: any) => void): void;
    emit(event: string, data: any): void;
    sendControlMessage(params: {
        roomId: UUID;
        action: 'enable_input' | 'disable_input';
        target?: string;
    }): Promise<void>;
    registerSendHandler(source: string, handler: SendHandlerFunction): void;
    sendMessageToTarget(target: TargetInfo, content: Content): Promise<void>;
    getMemoriesByWorldId(params: {
        worldId: UUID;
        count?: number;
        tableName?: string;
    }): Promise<Memory[]>;
    runMigrations(migrationsPaths?: string[]): Promise<void>;
    isReady(): Promise<boolean>;
}

/**
 * Creates a new Setting object based on provided config settings.
 * @param {Omit<Setting, "value">} configSetting - The configuration settings for the new Setting object.
 * @returns {Setting} - The newly created Setting object.
 */
/**
 * Creates a Setting object from a configSetting object by omitting the 'value' property.
 *
 * @param {Omit<Setting, 'value'>} configSetting - The configSetting object to create the Setting from.
 * @returns {Setting} A new Setting object created from the provided configSetting object.
 */
declare function createSettingFromConfig(configSetting: Omit<Setting, 'value'>): Setting;
/**
 * Retrieves the salt based on env variable SECRET_SALT
 *
 * @returns {string} The salt for the agent.
 */
declare function getSalt(): string;
/**
 * Common encryption function for string values
 * @param {string} value - The string value to encrypt
 * @param {string} salt - The salt to use for encryption
 * @returns {string} - The encrypted value in 'iv:encrypted' format
 */
declare function encryptStringValue(value: string, salt: string): string;
/**
 * Common decryption function for string values
 * @param {string} value - The encrypted value in 'iv:encrypted' format
 * @param {string} salt - The salt to use for decryption
 * @returns {string} - The decrypted string value
 */
declare function decryptStringValue(value: string, salt: string): string;
/**
 * Applies salt to the value of a setting
 * Only applies to secret settings with string values
 */
declare function saltSettingValue(setting: Setting, salt: string): Setting;
/**
 * Removes salt from the value of a setting
 * Only applies to secret settings with string values
 */
declare function unsaltSettingValue(setting: Setting, salt: string): Setting;
/**
 * Applies salt to all settings in a WorldSettings object
 */
declare function saltWorldSettings(worldSettings: WorldSettings, salt: string): WorldSettings;
/**
 * Removes salt from all settings in a WorldSettings object
 */
declare function unsaltWorldSettings(worldSettings: WorldSettings, salt: string): WorldSettings;
/**
 * Updates settings state in world metadata
 */
declare function updateWorldSettings(runtime: IAgentRuntime, serverId: string, worldSettings: WorldSettings): Promise<boolean>;
/**
 * Gets settings state from world metadata
 */
declare function getWorldSettings(runtime: IAgentRuntime, serverId: string): Promise<WorldSettings | null>;
/**
 * Initializes settings configuration for a server
 */
declare function initializeOnboarding(runtime: IAgentRuntime, world: World, config: OnboardingConfig): Promise<WorldSettings | null>;
/**
 * Encrypts sensitive data in a Character object
 * @param {Character} character - The character object to encrypt secrets for
 * @returns {Character} - A copy of the character with encrypted secrets
 */
declare function encryptedCharacter(character: Character): Character;
/**
 * Decrypts sensitive data in a Character object
 * @param {Character} character - The character object with encrypted secrets
 * @param {IAgentRuntime} runtime - The runtime information needed for salt generation
 * @returns {Character} - A copy of the character with decrypted secrets
 */
declare function decryptedCharacter(character: Character, _runtime: IAgentRuntime): Character;
/**
 * Helper function to encrypt all string values in an object
 * @param {Record<string, any>} obj - Object with values to encrypt
 * @param {string} salt - The salt to use for encryption
 * @returns {Record<string, any>} - Object with encrypted values
 */
declare function encryptObjectValues(obj: Record<string, any>, salt: string): Record<string, any>;
/**
 * Helper function to decrypt all string values in an object
 * @param {Record<string, any>} obj - Object with encrypted values
 * @param {string} salt - The salt to use for decryption
 * @returns {Record<string, any>} - Object with decrypted values
 */
declare function decryptObjectValues(obj: Record<string, any>, salt: string): Record<string, any>;

/**
 * Service builder class that provides type-safe service creation
 * with automatic type inference
 */
declare class ServiceBuilder<TService extends Service = Service> {
    protected serviceType: ServiceTypeName | string;
    protected startFn: (runtime: IAgentRuntime) => Promise<TService>;
    protected stopFn?: () => Promise<void>;
    protected description: string;
    constructor(serviceType: ServiceTypeName | string);
    /**
     * Set the service description
     */
    withDescription(description: string): this;
    /**
     * Set the start function for the service
     */
    withStart(startFn: (runtime: IAgentRuntime) => Promise<TService>): this;
    /**
     * Set the stop function for the service
     */
    withStop(stopFn: () => Promise<void>): this;
    /**
     * Build the service class with all configured properties
     */
    build(): new (runtime?: IAgentRuntime) => TService;
}
/**
 * Create a type-safe service builder
 * @param serviceType - The service type name
 * @returns A new ServiceBuilder instance
 */
declare function createService<TService extends Service = Service>(serviceType: ServiceTypeName | string): ServiceBuilder<TService>;
/**
 * Type-safe service definition helper
 */
interface ServiceDefinition<T extends Service = Service> {
    serviceType: ServiceTypeName;
    description: string;
    start: (runtime: IAgentRuntime) => Promise<T>;
    stop?: () => Promise<void>;
}
/**
 * Define a service with type safety
 */
declare function defineService<T extends Service = Service>(definition: ServiceDefinition<T>): new (runtime?: IAgentRuntime) => T;

export { type Action, type ActionContext, type ActionEventPayload, type ActionExample, type ActionResult, type Agent, AgentRuntime, AgentStatus, type AudioProcessingParams, type BaseMetadata, type BaseModelParams, type BrowserNavigationOptions, CacheKeyPrefix, type ChannelClearedPayload, ChannelType, type Character, type CharacterValidationResult, type ChunkRow, type ClickOptions, type Component, type Content, ContentType, type ControlMessage, type CustomMetadata, DatabaseAdapter, type DbConnection, type DeriveKeyAttestationData, type DescriptionMetadata, type DetokenizeTextParams, type DirectoryItem, type DocumentMetadata, type ElementSelector, type EmailAccount, type EmailAddress, type EmailAttachment, type EmailFolder, type EmailMessage, type EmailSearchOptions, type EmailSendOptions, type EmbeddingSearchResult, type EnhancedState, type Entity, type EntityPayload, type EvaluationExample, type Evaluator, type EvaluatorEventPayload, type EventHandler, type EventPayload, type EventPayloadMap, EventType, type ExtractedContent, type FragmentMetadata, type GenerateTextParams, type Handler, type HandlerCallback, type IAgentRuntime, IBrowserService, type IDatabaseAdapter, IEmailService, ILpService, IMessageService, IPdfService, IPostService, ITokenDataService, ITranscriptionService, IVideoService, IWalletService, IWebSearchService, type ImageDescriptionParams, type ImageGenerationParams, type ImageSearchOptions, type InvokePayload, type IsValidServiceType, type JSONSchema, type KnowledgeItem, KnowledgeScope, type Log, type LpPositionDetails, MODEL_SETTINGS, type Media, type Memory, type MemoryMetadata, type MemoryRetrievalOptions, type MemoryScope, type MemorySearchOptions, MemoryType, type MemoryTypeAlias, type MessageAttachment, type MessageChannel, type MessageContent, type MessageExample, type MessageInfo, type MessageMemory, type MessageMetadata, type MessageParticipant, type MessagePayload, type MessageReaction, type MessageReceivedHandlerParams, type MessageReference, type MessageSearchOptions, type MessageSendOptions, type Metadata, type ModelEventPayload, type ModelHandler, type ModelParamsMap, type ModelResultMap, ModelType, type ModelTypeName, type MultiRoomMemoryOptions, type NewsSearchOptions, type ObjectGenerationParams, type OnboardingConfig, type Participant, type PdfConversionOptions, type PdfExtractionResult, type PdfGenerationOptions, PlatformPrefix, type Plugin, type PluginEvents, type PoolInfo, type PostAnalytics, type PostAuthor, type PostContent, type PostCreateOptions, type PostEngagement, type PostInfo, type PostLocation, type PostMedia, type PostSearchOptions, type Project, type ProjectAgent, type Provider, type ProviderResult, type Relationship, type RemoteAttestationMessage, type RemoteAttestationQuote, Role, type Room, type RoomMetadata, type Route, type RunEventPayload, type RuntimeSettings, SOCKET_MESSAGE_TYPE, type ScreenshotOptions, type SearchOptions, type SearchResponse, type SearchResult, Semaphore, type SendHandlerFunction, type ServerOwnershipState, Service, ServiceBuilder, type ServiceClassMap, type ServiceDefinition, type ServiceError, type ServiceInstance, type ServiceRegistry, ServiceType, type ServiceTypeName, type ServiceTypeRegistry, type ServiceTypeValue, type Setting, type SpeechToTextOptions, type State, type StateArray, type StateObject, type StateValue, TEEMode, type TargetInfo, type Task, type TaskMetadata, type TaskWorker, type TeeAgent, type TeePluginConfig, TeeType, type TemplateType, type TestCase, type TestSuite, type TextEmbeddingParams, type TextGenerationParams, type TextToSpeechOptions, type TextToSpeechParams, type TokenBalance, type TokenData, type TokenizeTextParams, type TransactionResult, type TranscriptionOptions, type TranscriptionParams, type TranscriptionResult, type TranscriptionSegment, type TranscriptionWord, type TypeOptions, type TypedEventHandler, type TypedService, type TypedServiceClass, type UUID, type UnifiedMemoryOptions, type UnifiedSearchOptions, VECTOR_DIMS, type Validator, type VideoDownloadOptions, type VideoFormat, type VideoInfo, type VideoProcessingOptions, type VideoProcessingParams, type VideoSearchOptions, type WalletAsset, type WalletPortfolio, type World, type WorldPayload, type WorldSettings, addHeader, asUUID, booleanFooter, characterSchema, composeActionExamples, composePrompt, composePromptFromState, createActionResult, createLogger, createMessageMemory, createService, createServiceError, createSettingFromConfig, createUniqueUuid, decryptObjectValues, decryptStringValue as decryptSecret, decryptStringValue, decryptedCharacter, defineService, elizaLogger, encryptObjectValues, encryptStringValue, encryptedCharacter, findEntityByName, findWorldsForOwner, formatActionNames, formatActions, formatEntities, formatMessages, formatPosts, formatTimestamp, getContentTypeFromMimeType, getEntityDetails, getLocalServerUrl, getMemoryText, getModelSpecificSettingKey, getSalt, getTypedService, getUserServerRole, getWorldSettings, imageDescriptionTemplate, initializeOnboarding, isCustomMetadata, isDescriptionMetadata, isDocumentMemory, isDocumentMetadata, isFragmentMemory, isFragmentMetadata, isMessageMetadata, isValidCharacter, logger, messageHandlerTemplate, normalizeJsonString, parseAndValidateCharacter, parseBooleanFromText, parseJSONObjectFromText, parseKeyValueXml, postCreationTemplate, safeReplacer, saltSettingValue, saltWorldSettings, shouldRespondTemplate, splitChunks, stringToUuid, trimTokens, truncateToCompleteSentence, unsaltSettingValue, unsaltWorldSettings, updateWorldSettings, validateCharacter, validateUuid };
